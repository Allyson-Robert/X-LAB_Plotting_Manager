# Main.py
import importlib
from PyQt5 import QtWidgets, uic, QtCore, QtGui
import datetime
import json
import logging
import sys
import fileset as fs
import DataCreatorWindow
from utils.get_class_methods import get_class_methods
from utils.console_colours import ConsoleColours
from utils.logging import with_logging
from utils.get_qwidget_value import get_qwidget_value
from utils.errors.errors import IncompatibleDeviceTypeFound

# Read the JSON config file
with open('config.json') as f:
    config = json.load(f)

# Get the analysis package path
analysis_path = config['analysis_path']

# Add the analysis package path to the system path and import it
sys.path.insert(0, analysis_path)
sys.path.append("..")
import analysis.devices

class UiMainWindow(QtWidgets.QMainWindow):
    """
        gui for automated plotting of various types of data.
        MainWindow.ui is generated by QtDesigner version 6.4.1
    """
    def __init__(self):
        super(UiMainWindow, self).__init__()
        self.thread = None
        self.experiment_worker = None
        self.fileset = None
        self.fileset_location = None

        # Load the UI, Note that loadUI adds objects to 'self' using objectName
        self.dataWindow = None
        uic.loadUi("MainWindow.ui", self)

        # Create/Get a logger with the desired settings
        self.logger = logging.getLogger("my_logger")
        self.consoleTextEdit.setFormatter(
            logging.Formatter(
                "%(asctime)s [%(levelname)8.8s] %(message)s",
                datefmt='%d/%m/%Y %H.%M.%S: '
            )
        )
        self.logger.addHandler(self.consoleTextEdit)
        log_level = getattr(logging, config["log_level"])
        self.logger.setLevel(log_level)

        # FEATURE REQUEST: Perhaps pass this logger to an external thing?
        # Decorate methods with the with_logging decorator
        self.load_data = with_logging(self.load_data)

        self.plot_types = {}
        self.devices = {}
        # Get list of devices as defined manually in the analysis.devices __init__.py file
        for entry in analysis.devices.__all__:
            # Find and load the widget for any given device and add it to the stackedWidget
            entry_ui_file = entry.lower() + ".ui"
            entry_widget = uic.loadUi(config["widgets_path"] + entry_ui_file)
            entry_index = self.stackedWidget.addWidget(entry_widget)
            self.devices[entry] = entry_index

            # Import the corresponding module and get the class methods to add to the plot_types combobox when needed
            module = importlib.import_module(f"{analysis.devices.workers.__name__}.{entry.lower()}")
            entry_cls = getattr(module, entry)
            self.plot_types[entry] = get_class_methods(entry_cls, ignore=["run"])

        # Reset stacked widget to empty page
        self.stackedWidget.setCurrentWidget(self.stackedWidget.widget(0))

        # Define menubar actions
        self.actionCreate_Set.triggered.connect(self.create_data)
        self.actionSave_Set.triggered.connect(self.save_data)
        self.actionLoad_Set.triggered.connect(self.open_data_file)
        self.actionQuit.triggered.connect(self.quit)

        self.actionSave_format.triggered.connect(self.not_implemented)
        self.actionColour_scheme.triggered.connect(self.not_implemented)
        self.actionLine_width.triggered.connect(self.not_implemented)

        self.actionDocumentation.triggered.connect(self.not_implemented)
        self.actionAbout.triggered.connect(self.show_about)

        # Define gui button actions
        self.showDataBtn.clicked.connect(self.display_data)
        self.showHistoryBtn.clicked.connect(self.display_history)
        self.addNotesBtn.clicked.connect(self.add_notes)

        self.appendBtn.clicked.connect(self.append_console_to_set)
        self.clearBtn.clicked.connect(self.clear_data)
        self.clearAllBtn.clicked.connect(self.clear_all)
        self.quitBtn.clicked.connect(self.quit)

        # Define stackedWidget widget actions
        self.plotBtn.clicked.connect(self.plot_manager)

        # Make sure the progress bar is cleared
        self.progressBar.setValue(0)

        # Show the app
        self.show()
        self.console_print("Program Started")

    def create_data(self):
        # Run the DataCreatorWindow
        self.dataWindow = DataCreatorWindow.UiDataCreatorWindow(devices = [k for k in self.devices])
        self.dataWindow.show()

        if self.dataWindow.exec() == 1:
            # If the window was properly closed (Done button) then creation was successful
            #     Copy data and print to console
            self.clear_data()
            self.fileset = self.dataWindow.fileset
            self.console_print(f"ExperimentDB created")
            self.load_data()
            self.update_header()
            self.save_data()
        else:
            # Warn user that window was improperly closed and that no data was created
            self.console_print("No data was created")

    def autosave(self):
        file_name = self.fileset_location
        if file_name is None:
            return self.console_print("Cannot autosave, no file location known. Open or create dataset first")

        with open(file_name, "w") as json_file:
            json.dump(self.fileset, json_file, cls=fs.FilesetJSONEncoder)
        json_file.close()
        return self.console_print(f"Saved data to {file_name}")

    def save_data(self):
        # Make sure there is data to save
        if self.fileset is None:
            return self.console_print("Err: Must first load data", level="warning")

        # Run the file dialog
        file_name = QtWidgets.QFileDialog.getSaveFileName(self, "Save file to disk")[0]
        if file_name != "":
            # Dump the data into a json file and remember the location
            self.fileset_location = file_name
            with open(file_name, "w") as json_file:
                json.dump(self.fileset, json_file, cls=fs.FilesetJSONEncoder)
            json_file.close()

            return self.console_print(f"Saved data to {file_name}")
        else:
            # File dialog was exited without choosing a file
            return self.console_print(f"No file selected")

    def open_data_file(self):

        # Choose file
        file_name = QtWidgets.QFileDialog.getOpenFileName(self, "Open Files")[0]
        if file_name != '':
            # Reset data
            self.clear_data()
            self.consoleTextEdit.clear()

            # Open then load the json file, remember the location and update gui
            self.fileset_location = file_name
            with open(file_name) as json_file:
                self.fileset = json.load(json_file, cls=fs.FilesetJSONDecoder)
                self.console_print(f"Opened {file_name}")
            try:
                self.notesPlainText.setPlainText(self.fileset.get_notes())
                self.load_data()
                self.update_header()
            except IncompatibleDeviceTypeFound:
                self.clear_data()
        else:
            # File not chosen
            self.console_print(f"Err: No file loaded", level="warning")

    def load_data(self):
        # Add all top level keys to the selection list of the gui
        for label in self.fileset.get_labels():
            self.selectedFilesList.addItem(label)

        # FEATURE REQUEST: Make this a setting
        # Select all items by default
        self.selectedFilesList.selectAll()

        # Edit combobox to show all available plot types
        try:
            for plot_type in self.plot_types[self.fileset.get_device()]:
                self.plotTypeCombo.addItem(plot_type)
        except KeyError:
            self.console_print(f"Incompatible device type [{self.fileset.get_device()}] found in {self.fileset.get_name()}, select another fileset or implement the device type. Fileset path: N/A")
            raise IncompatibleDeviceTypeFound

        self.console_print("ExperimentDB loaded")

    def display_data(self):
        # Abort if no data was loaded
        if self.fileset is None:
            return self.console_print("Err: Must first load data", level="warning")

        # Pretty print the data in a simple dialog
        pretty_json = json.dumps(
            self.fileset,
            indent=4,
            separators=(',', ': '),
            cls=fs.FilesetJSONEncoder
        )
        self.dialog_print(title=f"ExperimentDB RAW: {self.fileset.get_name()}", contents=pretty_json)

    def display_history(self):
        if self.fileset is None:
            return self.console_print("Err: Must first load data", level="warning")

        # Prints only the console history to a simple dialog
        pretty_history = ""
        for k, v in sorted(self.fileset.get_console().items()):
            line = f"{v}\n"
            pretty_history += line

        self.dialog_print(title=f"ExperimentDB History: {self.fileset.get_name()}", contents=pretty_history)

    def add_notes(self):
        if self.fileset is None:
            return self.console_print("Err: Must first load data", level="warning")

        # Add any notes to the fileset
        self.fileset.add_notes(self.notesPlainText.toPlainText())
        self.console_print("Notes added to fileset")
        self.autosave()

    def update_header(self):
        # Header should reflect opened data
        self.currSetNameLineEdit.setText(self.fileset.get_name())
        self.currDeviceLineEdit.setText(self.fileset.get_device())

        # Stacked widget should show the correct widget for the opened data
        new_page = self.stackedWidget.widget(self.devices[self.fileset.get_device()])
        self.stackedWidget.setCurrentWidget(new_page)

    def report_progress(self, progress: int):
        assert isinstance(progress, int)
        assert 0 <= progress <= 100
        self.progressBar.setValue(progress)

    def plot_manager(self):
        """
            This can last a long time and will therefore instantiate a QThread to leave the gui responsive.
        """
        # Grab the selected files for plotting
        fileset_time = datetime.datetime.now().strftime("%Y.%m.%d_%H.%M.%S")
        experiment_time = self.fileset.get_experiment_date().strftime("%Y.%m.%d_%H.%M.%S")
        selected_fileset = fs.Fileset(fileset_time)
        selected_fileset.set_experiment_date(experiment_time)

        for item in self.selectedFilesList.selectedItems():
            lbl = item.text()
            path = self.fileset.get_filepath(lbl)
            selected_fileset.add_filepath(path, lbl)
            colour = self.fileset.get_colour(lbl)
            selected_fileset.add_colour(colour, lbl)

        selected_fileset.set_device(self.fileset.get_device())
        selected_fileset.set_structure_type(self.fileset.get_structure_type())
        selected_fileset.set_name(self.fileset.get_name())

        # Recursively search for QWidget children with an alias to collect options and get their values
        options_dict = {}
        for option in self.stackedWidget.currentWidget().findChildren(QtWidgets.QWidget):
            alias = option.property("alias")
            if alias is not None:
                options_dict[alias] = get_qwidget_value(option)
        options_dict["presentation"] = get_qwidget_value(self.presentationCheckBox)
        options_dict["legend_title"] = get_qwidget_value(self.legendTitleLineEdit)

        # Instantiate proper device class and set the data
        current_device_class = self.fileset.get_device()
        device_module = getattr(analysis.devices.workers, current_device_class.lower())
        experiment_cls = getattr(device_module, current_device_class)

        # # Grab the correct plotting function and pass all options to it
        plot_type = self.plotTypeCombo.currentText()
        self.console_print(f"Producing {current_device_class}-{plot_type} plot for {self.fileset.get_name()} with options {options_dict}")

        # Create a new thread for the device class to run in
        self.thread = QtCore.QThread()
        self.experiment_worker = experiment_cls(current_device_class, selected_fileset, plot_type, options=options_dict)
        self.experiment_worker.moveToThread(self.thread)

        # Connect signals and slots for the worker thread
        self.thread.started.connect(self.experiment_worker.run)
        self.experiment_worker.finished.connect(self.thread.quit)
        self.experiment_worker.finished.connect(self.experiment_worker.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)
        self.experiment_worker.progress.connect(self.report_progress)

        # Start the thread
        self.thread.start()

        # FIXME: Final resets
        # self.longRunningBtn.setEnabled(False)
        # self.thread.finished.connect(
        #     lambda: self.longRunningBtn.setEnabled(True)
        # )
        # self.thread.finished.connect(
        #     lambda: self.stepLabel.setText("Long-Running Step: 0")
        # )

    # def toggle_lbic_profile(self):
    #     # Allow the profile position to be selected (LBIC specific)
    #     if self.lbicProfilesCheckBox.isChecked():
    #         self.lbicProfilesSpinBox.setEnabled(True)
    #     else:
    #         self.lbicProfilesSpinBox.setDisabled(True)

    def dialog_print(self, title, contents):
        # Prepare a text edit widget to host the contents
        history_text_edit = QtWidgets.QTextEdit(self)
        history_text_edit.setPlainText(contents)

        # Initialise the window
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle(title)

        # Set a default width and minimum height for the dialog
        dialog.resize(600, 400)

        # Create a QVBoxLayout for the dialog
        layout = QtWidgets.QVBoxLayout(dialog)

        # Add the QTextEdit widget to the layout
        layout.addWidget(history_text_edit)

        # Create a QHBoxLayout and host buttons
        button_layout = QtWidgets.QHBoxLayout()
        ok_button = QtWidgets.QPushButton("OK")
        save_button = QtWidgets.QPushButton("SAVE")
        button_layout.addWidget(ok_button)
        button_layout.addWidget(save_button)

        # Add the button layout to the main layout
        layout.addLayout(button_layout)

        # Connect the "OK" button to close the dialog
        ok_button.clicked.connect(dialog.accept)
        save_button.clicked.connect(lambda: self.save_to_file(contents))

        # Show the dialog
        dialog.exec_()

    def save_to_file(self, plaintext: str):
        file_dialog = QtWidgets.QFileDialog.getSaveFileName(self, "Save File", "", "Text Files (*.txt);;All Files (*)")
        if file_dialog[0]:  # Check if a file was selected
            file_path = file_dialog[0]
            with open(file_path, 'w') as file:
                file.write(plaintext)

    def console_print(self, fstring, level="normal"):
        # Print a message to the gui console
        now = datetime.datetime.now()
        fstring_to_print = now.strftime("%d/%m/%Y %H.%M.%S: ") + fstring

        c = ConsoleColours()

        self.consoleTextEdit.setTextColor(c.get_colour(level))
        self.consoleTextEdit.append(fstring_to_print)
        self.consoleTextEdit.setTextColor(c.get_colour("normal"))

    def append_console_to_set(self):
        if self.fileset is None:
            return self.console_print("Err: Must first load data", level="warning")

        # Append console contents to the fileset
        console_text = self.consoleTextEdit.toPlainText()
        now = datetime.datetime.now()
        self.fileset.add_console(now.strftime("%d%m%Y_%H%M%S"), console_text)
        self.console_print("Added console contents to set")
        self.autosave()

    def clear_data(self):
        # Reset fields and properties related to data
        self.fileset = None
        self.fileset_location = None

        self.currSetNameLineEdit.clear()
        self.currDeviceLineEdit.clear()
        self.notesPlainText.clear()
        self.console_print("Cleared data from memory")

        self.stackedWidget.setCurrentWidget(self.stackedWidget.widget(0))
        self.selectedFilesList.clear()
        self.plotTypeCombo.clear()

    def clear_all(self):
        # Reset complete gui
        self.clear_data()
        self.consoleTextEdit.clear()
        self.console_print("Cleared memory")

    def show_about(self):
        """
            Shows a simple window with licence, authorship and build information
        """
        # Grab the "about" info from about.txt
        with open("about.txt") as about_file:
            about_contents = about_file.read()

        # Create a custom QDialog for the about information
        about_dialog = QtWidgets.QDialog(self.centralwidget)
        about_dialog.setWindowTitle("About")

        # Set the fixed size of the dialog
        about_dialog.setFixedSize(650, 700)  # Adjust the dimensions as needed

        # Load and set the image using QPixmap (make sure the path is correct)
        pixmap = QtGui.QPixmap(config["logos_path"] + "X_logo_x-lab_baseline_KL.png")
        pixmap = pixmap.scaled(600, 200, QtCore.Qt.KeepAspectRatio)
        image_label = QtWidgets.QLabel(about_dialog)
        image_label.setPixmap(pixmap)

        # Create a QLabel for the text (using HTML formatting)
        text_label = QtWidgets.QLabel(about_dialog)
        text_label.setWordWrap(True)
        text_label.setText(about_contents)

        # Create a QVBoxLayout for the dialog and add the image and text labels
        layout = QtWidgets.QVBoxLayout(about_dialog)
        layout.addWidget(image_label)
        layout.addWidget(text_label)

        about_dialog.setLayout(layout)

        # Show the about dialog
        about_dialog.exec_()

    def not_implemented(self):
        """
            Shows the user a message that the current feature is planned but not yet implemented.
        """
        self.console_print("Feature not implemented", level='warning')

    # ESC now triggers a program exit
    def keyPressEvent(self, event) -> None:
        if event.key() == QtCore.Qt.Key.Key_Escape:
            self.quit()
        else:
            super(UiMainWindow, self).keyPressEvent(event)

    # CHECK: Program exit is not safe
    @staticmethod
    def quit():
        # Terminate the application
        sys.exit()


if __name__ == "__main__":
    # Initialise app, window and start execution
    app = QtWidgets.QApplication(sys.argv)
    window = UiMainWindow()
    app.exec_()
