{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"X\u2011LAB Plotting Manager The X-LAB Plotting Manager is a modular framework for turning raw scientific measurements into clean, reusable, publication-ready plots. It was created to address a common research problem: as experiments pile up, so do ad-hoc scripts, commented-out file lists, duplicated plotting code and \u201cjust tweak this one\u201d workflows that quickly become unmaintainable and impossible to reproduce. This framework offers a structured, scalable alternative. By enforcing modular components with clear responsibilities and a configurable UI, it replaces tangled plotting scripts with a robust and reproducible analysis pipeline. It supports both quick exploratory work and long-term dataset management, making it a practical tool for anyone dealing with experimental data. What this framework provides The system is built around clear contracts that define how devices, processors, and plotters behave. This yields maximum modularity and reusability. At a high level, the framework consists of: \u2022 Dataset creation Define what to load, how to interpret it, and which processor and plotter to apply. Datasets are stored as JSON files that act as portable analysis definitions. \u2022 Analysis/Plotting execution The main window lets you loads a dataset (by creation or by reading from the disk), spawns worker threads, processes the data, and renders the plots. \u2022 Contract\u2011based extensibility You can implement new: Data types (for giving meaning to raw data) DataProcessor classes (for computing derived quantities) Plotter classes (for new visualisations) DeviceWorker classes (for experiment\u2011specific orchestration) Modules stay clean because each class only does one thing , and all pieces work together through stable interfaces. \u2022 Robust UI and threading Long operations (like reading hundreds of files) run in background threads so the UI stays responsive. Structure of these documentation pages The documentation is organised to follow the natural workflow of using \u2014 and eventually extending \u2014 the framework. Each section builds on the previous one: 1. 2. Introduction (this page) Overview of the project, its motivation, and the philosophy behind the framework. Installation Instructions for installing the application, its dependencies, and a baseline implementations module. Getting Started A hands-on walkthrough showing how to load existing implementations and generate your first plot. How to think about this application? The architectural mindset: modularity, reuse, and the reasoning behind the framework\u2019s design. How to implement the contracts? Step-by-step guidance on creating your own Data , DataProcessor , Plotter , and DeviceWorker classes. What are datasets? Explanation of dataset files, their structure, how they define analyses, and why they enable reproducibility. Logging and debugging Tools and patterns for monitoring background workers, diagnosing issues, and keeping the UI stable. API Reference Class and module documentation for deeper integration or custom development. The goal of this structure is to help you understand the framework quickly, use it effectively, and extend it confidently \u2014 giving you a robust foundation for clean, reproducible, and scalable scientific data analysis.","title":"Home"},{"location":"#xlab-plotting-manager","text":"The X-LAB Plotting Manager is a modular framework for turning raw scientific measurements into clean, reusable, publication-ready plots. It was created to address a common research problem: as experiments pile up, so do ad-hoc scripts, commented-out file lists, duplicated plotting code and \u201cjust tweak this one\u201d workflows that quickly become unmaintainable and impossible to reproduce. This framework offers a structured, scalable alternative. By enforcing modular components with clear responsibilities and a configurable UI, it replaces tangled plotting scripts with a robust and reproducible analysis pipeline. It supports both quick exploratory work and long-term dataset management, making it a practical tool for anyone dealing with experimental data.","title":"X\u2011LAB Plotting Manager"},{"location":"#what-this-framework-provides","text":"The system is built around clear contracts that define how devices, processors, and plotters behave. This yields maximum modularity and reusability. At a high level, the framework consists of:","title":"What this framework provides"},{"location":"#dataset-creation","text":"Define what to load, how to interpret it, and which processor and plotter to apply. Datasets are stored as JSON files that act as portable analysis definitions.","title":"\u2022 Dataset creation"},{"location":"#analysisplotting-execution","text":"The main window lets you loads a dataset (by creation or by reading from the disk), spawns worker threads, processes the data, and renders the plots.","title":"\u2022 Analysis/Plotting execution"},{"location":"#contractbased-extensibility","text":"You can implement new: Data types (for giving meaning to raw data) DataProcessor classes (for computing derived quantities) Plotter classes (for new visualisations) DeviceWorker classes (for experiment\u2011specific orchestration) Modules stay clean because each class only does one thing , and all pieces work together through stable interfaces.","title":"\u2022 Contract\u2011based extensibility"},{"location":"#robust-ui-and-threading","text":"Long operations (like reading hundreds of files) run in background threads so the UI stays responsive.","title":"\u2022 Robust UI and threading"},{"location":"#structure-of-these-documentation-pages","text":"The documentation is organised to follow the natural workflow of using \u2014 and eventually extending \u2014 the framework. Each section builds on the previous one: 1. 2. Introduction (this page) Overview of the project, its motivation, and the philosophy behind the framework. Installation Instructions for installing the application, its dependencies, and a baseline implementations module. Getting Started A hands-on walkthrough showing how to load existing implementations and generate your first plot. How to think about this application? The architectural mindset: modularity, reuse, and the reasoning behind the framework\u2019s design. How to implement the contracts? Step-by-step guidance on creating your own Data , DataProcessor , Plotter , and DeviceWorker classes. What are datasets? Explanation of dataset files, their structure, how they define analyses, and why they enable reproducibility. Logging and debugging Tools and patterns for monitoring background workers, diagnosing issues, and keeping the UI stable. API Reference Class and module documentation for deeper integration or custom development. The goal of this structure is to help you understand the framework quickly, use it effectively, and extend it confidently \u2014 giving you a robust foundation for clean, reproducible, and scalable scientific data analysis.","title":"Structure of these documentation pages"},{"location":"datasets/","text":"Datasets A dataset is a small, portable configuration file describing which data belongs together , how it should be interpreted , and how it can be plotted . Datasets are human-readable JSON files with extensions such as: .ds .dataset .json These files are the backbone of the framework\u2019s reproducible analysis system. Why datasets matter Typical ad-hoc analysis involves scattering paths, parameters, units, and processing logic across multiple scripts. Over time, this leads to: inconsistent metadata accidental path mistakes hard-to-reproduce results difficulty sharing analyses across a team A dataset solves this by acting as a single source of truth . It encapsulates: experiment metadata device type datafile grouping labels and colours the experiment timestamp notes and documentation The GUI and framework then build the correct: data readers processors plotters \u2026automatically and consistently. Typical lifecycle of a dataset 1. Creation Datasets are primarily created using the Data Creation Window in the GUI. This ensures correctness and prevents invalid or incomplete JSON. In this window the user: names the dataset selects the device sets the experiment date & time adds one or more datafiles and assigns labels optionally assigns colours writes notes or comments saves the dataset JSON to disk All required metadata is enforced by the window. 2. Storage A dataset is stored as a compact JSON configuration. Key fields include: dataset name creation timestamp experiment timestamp device identifier list of files and their labels optional colours notes A custom encoder and decoder handle the saving and loading of DataSet instances from JSON files on disk. Example (illustrative only): { \"location\": null, \"name\": \"Example Set\", \"creation_date\": \"2025.12.02_14.19.54\", \"experiment_date_time\": \"2023.03.30_13.19.54\", \"device\": \"Generic\", \"notes\": \"\", \"console\": {}, \"structure_type\": \"flat\", \"filepaths\": { \"Example IV Curve\": \"path/to/IV_2023_03_30_13_17_28.txt\" }, \"colours\": {} } (This example demonstrates the structure only. Do not use it directly.) 3. Execution Once a dataset is loaded in the main GUI: Its files are automatically listed The user selects a subset of files to plot The device determines which plots are valid Plot options appear immediately The run happens in a background worker thread The reader, processor, and plotter cooperate automatically The result is displayed to the user TL;DR Datasets provide a clean, structured, reproducible way to define: what the data is where it lives how it should be interpreted which device and plots apply how files relate to one another metadata needed for processing Together with the Data Creation Window, datasets transform analysis workflows from scattered scripts into a declarative, maintainable, and shareable system .","title":"What are datasets"},{"location":"datasets/#datasets","text":"A dataset is a small, portable configuration file describing which data belongs together , how it should be interpreted , and how it can be plotted . Datasets are human-readable JSON files with extensions such as: .ds .dataset .json These files are the backbone of the framework\u2019s reproducible analysis system.","title":"Datasets"},{"location":"datasets/#why-datasets-matter","text":"Typical ad-hoc analysis involves scattering paths, parameters, units, and processing logic across multiple scripts. Over time, this leads to: inconsistent metadata accidental path mistakes hard-to-reproduce results difficulty sharing analyses across a team A dataset solves this by acting as a single source of truth . It encapsulates: experiment metadata device type datafile grouping labels and colours the experiment timestamp notes and documentation The GUI and framework then build the correct: data readers processors plotters \u2026automatically and consistently.","title":"Why datasets matter"},{"location":"datasets/#typical-lifecycle-of-a-dataset","text":"","title":"Typical lifecycle of a dataset"},{"location":"datasets/#1-creation","text":"Datasets are primarily created using the Data Creation Window in the GUI. This ensures correctness and prevents invalid or incomplete JSON. In this window the user: names the dataset selects the device sets the experiment date & time adds one or more datafiles and assigns labels optionally assigns colours writes notes or comments saves the dataset JSON to disk All required metadata is enforced by the window.","title":"1. Creation"},{"location":"datasets/#2-storage","text":"A dataset is stored as a compact JSON configuration. Key fields include: dataset name creation timestamp experiment timestamp device identifier list of files and their labels optional colours notes A custom encoder and decoder handle the saving and loading of DataSet instances from JSON files on disk. Example (illustrative only): { \"location\": null, \"name\": \"Example Set\", \"creation_date\": \"2025.12.02_14.19.54\", \"experiment_date_time\": \"2023.03.30_13.19.54\", \"device\": \"Generic\", \"notes\": \"\", \"console\": {}, \"structure_type\": \"flat\", \"filepaths\": { \"Example IV Curve\": \"path/to/IV_2023_03_30_13_17_28.txt\" }, \"colours\": {} } (This example demonstrates the structure only. Do not use it directly.)","title":"2. Storage"},{"location":"datasets/#3-execution","text":"Once a dataset is loaded in the main GUI: Its files are automatically listed The user selects a subset of files to plot The device determines which plots are valid Plot options appear immediately The run happens in a background worker thread The reader, processor, and plotter cooperate automatically The result is displayed to the user","title":"3. Execution"},{"location":"datasets/#tldr","text":"Datasets provide a clean, structured, reproducible way to define: what the data is where it lives how it should be interpreted which device and plots apply how files relate to one another metadata needed for processing Together with the Data Creation Window, datasets transform analysis workflows from scattered scripts into a declarative, maintainable, and shareable system .","title":"TL;DR"},{"location":"design_philosophy/","text":"How to think about this application? Some general notes to consider Modular, Reusable Components with Single Responsibility The goal of the X\u2011LAB plotting framework is to help you turn raw scientific measurements into meaningful, reusable visualisations with minimal effort. The most important philosophy behind the entire system is reuse . This application is best integrated in your workflow by remembering to approach it from a modular angle. You should always ask yourself: \u201cCan I reuse something that already exists?\u201d Because over time your lab will accumulate: - reusable readers , - reusable DataCore , DataProcessorCore and Plotter subclasses, - portable DeviceWorkerCore subclasses with their widgets This reuse-first mindset ensures that even complex analyses remain understandable and maintainable. It is also further enhanced by the concept of single responsibility, which is core to the structure defined by the contracts. Keep this single responsibility and modularity in mind when extending this application to suit your needs. Abstract Base Classes (ABCs) vs Core Implementations The framework exposes four architectural building blocks: Data DataProcessor DeviceWorker Plotter Each defines what a new implementation must provide . On top of these, the framework offers recommended Core versions : DataCore DataProcessorCore DeviceWorkerCore The Core versions implement conventions and mechanisms encouraging structure and single-responsibility programming. You are free to implement the ABCs directly, but using the Core classes requires far less code as it provides a foundational interaction between the various components of this application. A Bidirectional Way of Thinking Developing a new implementation is not a bottom\u2011up process. It is bidirectional : Data \u2192 Observables \u2192 Processing \u2192 Derived quantities Device \u2192 Visualisations \u2192 Plot functions \u2192 Plotters As a scientist, you will switch constantly between these two directions: What does my data contain? What can I read from the file? Which quantities can I derive from it? and What do I want to visualise? How do I want to visualise it? What must I access to show this? This interplay is what shapes your implementation. You Already Have a Working Default Implementation If you installed the default module, you should already be able to: create a dataset, pointing to two\u2011column files (e.g. voltage\u2013current, time\u2013signal, wavelength\u2013intensity), and plot those directly from the GUI. This documentation helps you go beyond that\u2014building your own scientific visualisation workflows. Building Your Own Implementation: A Scientist\u2019s Workflow This section walks through the thought patterns you should follow when designing new analysis tools in the X\u2011LAB framework. It mirrors the real reasoning process I typically use in the lab. Step 1 \u2014 Understand Your Data Before coding anything, inspect your raw files, what do they look like? Are these columnar text files or maybe matrices encoding an image? Do they contain headers, timestamps or metadata? Which quantities are present and are they labelled?? What units are used? And most importantly: Can the raw file already be successfully loaded by an existing file reader? Examples - An IV curve: Voltage (V) vs Current (A) - Time\u2011dependent signal: Time (s) vs intensity - LBIC: a 2D grid of currents - Spectra: wavelength vs counts - Temperature measurements: timestamp vs sensor value Step 2 \u2014 Map Raw Data to Observables Using a DataCore Subclass Subclassing DataCore lets you define: which file reader is used to import the raw data how observables map to the general/agnostic structure returned by the reader what each observable\u2019s units are optional extraction of timestamps storage of raw values in the standard observable dictionary structure Your Thought Process Might Look Like This: \u201cThis file has two columns \u2192 I can reuse the csv reader I already have.\u201d \u201cColumn 0 is voltage \u2192 observable voltage , units V .\u201d \u201cColumn 1 is current \u2192 observable current , units A .\u201d \u201cI need the measurement timestamp \u2192 extract it from the filename or from the metadata.\u201d This gives the processor a clean, structured interface. Step 3 \u2014 Decide What Derived Quantities You Need And Let DataProcessorCore Subclasses Compute them Once raw observables exist, you think: \u201cWhat quantities do I need from this data? Is the raw data enough or can I compute any derived quantities\u201d Examples - IV: Aside from current-voltage curve one might want to know the open-circuit voltage, short-circuit current, fill factor, and maximum power point - Light-beam Induced Current scans give you axes and a current map, but you might want to extract a profile or look at the distribution of currents. - Time\u2011dependent IV: power conversion over time - Spectra: peak wavelength, full width at half maximum, integrated intensity A DataProcessorCore subclass allows you to add processing functions: self._processing_functions = { \"isc\": self.compute_short_circuit_current, \"voc\": self.compute_open_circuit_voltage, \"pce\": self.compute_power_conversion_efficiency, } The processor: - requests raw data from Data subclasses - computes derived quantities when needed - returns them in the same structured observable format - caches results for efficiency Your scientific reasoning\u2014\u201cwhat do I want to calculate?\u201d\u2014maps directly onto this class. Step 4 \u2014 Think About the Visualisations You Want This is where the bidirectional aspect of the implementation starts becoming important: \u201cGiven the data and derived observables, what plots do I want to be able to produce?\u201d One dataset \u2192 many plots. Examples IV Device - Raw IV curve - Efficiency extracted parameters - Time dependent behaviour LBIC Device - Heatmap of current density - Histogram of pixel values - Profiles along x and y Each of these can be obtained from the same basic data files but must be handled differently, usually by a dedicated DeviceWorker and DataProcessor , to produce the desired visualisation. Each DeviceWorker subclass is therefore coupled to a DataProcessor and Data class and plots becomes dedicated plot_{name} method inside your DeviceWorker subclass. These names also populate the GUI\u2019s \u201cplot selector\u201d, so choosing clear names helps users understand what each plot does. Step 5 \u2014 Build the DeviceWorker (The Orchestrator) A DeviceWorker does four things: Sets the data_type (your DataCore subclass) and processor_type (your Processor subclass) during initialisation Defines multiple plot functions , one for each plot type (named plot_{name} as these are automatically detected by the GUI) Instantiates the needed Plotter inside each plot function, passing options and processors to it as needed. Your Internal Monologue Might Be : - \u201cThis LBIC device should expose: image, histogram, and profile plots.\u201d - \u201cEach is a separate plot function.\u201d - \u201cEach plot function will instantiate the appropriate plotter.\u201d - \u201cThe plotter only gets processors and options\u2014it never reads files directly.\u201d Workers never implement scientific logic and plotters should never need to know the desired observables. It is the task of the DeviceWorker to tell the plotter which observables to request from the DataProcessor . This ensures plotters stay reusable between devices and measurement types. In short they connect data \u2192 processors \u2192 plotters. Step 6 \u2014 Provide a Widget for User Options Each device needs its own widget, these are searched for by the GUI. It serves as the user\u2019s scientific control panel. Thought Process - \u201cShould the user choose the axis?\u201d \u2192 combo box with option_alias=\"x_axis\" - \u201cShould they toggle log\u2011scale?\u201d \u2192 check box with option_alias=\"log_y\" - \u201cDo they need a threshold?\u201d \u2192 spin box with option_alias=\"threshold\" The GUI automatically gathers these into a PlotterOptions object and passes it to the worker, which hands it over to the plotter to read and use if appropriate. This keeps plotters GUI\u2011independent. You can build widgets using: - Qt Designer (recommended) - A simple XML template you can copy and edit Step 7 \u2014 Choose or Reuse a Plotter Plotters turn processed data into visuals. They should be as dumb and reusable as possible. Typical plotters include: - ScatterPlotter - HeatmapPlotter - HistogramPlotter If your visualisation matches any of these \u2192 reuse . Only create a new plotter when the visualisation is fundamentally different. Note that Plotters don\u2019t maintain state between plots, they are instantiated by the GUI and removed when the plot has been generated. Understanding the Dataset These datasets are fundamental to the GUI and are the main reason everything is interoperable. They can be created using the data creation window, are rebuilt when selecting files from any set to plot, and are used by all Cores to know where to find data. But one might wonder what they are, in short they are small metadata files containing: labelled paths to raw measurement files, optional colours or other needed metadata, an experiment reference date, Raw data is never modified, overwritten, or copied. It stays wherever you keep it\u2014your folder structure, your naming scheme, your archive. A dataset is just a pointer + metadata . It allows the worker to collect the correct files and instantiate a processor for each. This separation makes your workflow repeatable and safe. For more details see the dataset page . Final Thoughts Use Core Classes When Possible They: - implement standard observable format - implement processing\u2011function patterns - implement multi\u2011file handling - implement worker threading - integrate cleanly with the GUI Using them means you only implement the parts that matter scientifically. Deviate Only When Necessary If your data or workflow doesn\u2019t fit the model: - you can use the ABCs directly - but then you must ensure compatibility - plotters cannot assume Core behavior - you must follow observable formatting yourself This is an advanced path\u2014only use it when the science requires it. By following this workflow\u2011oriented design approach, your implementation will naturally fit the X\u2011LAB ecosystem: raw data \u2192 observables \u2192 derived quantities datasets pointing to files + metadata devices offering multiple scientific workflows widgets capturing user intent plotters turning processors into visualisations And throughout the entire process, remember: Always reuse existing readers, processors, plotters, widgets, and devices whenever possible. Subclass only when needed. Implement the ABCs only when absolutely necessary. This is the mindset that keeps your code clean, scientific, powerful\u2014and future\u2011proof.","title":"How to think about this application?"},{"location":"design_philosophy/#how-to-think-about-this-application","text":"","title":"How to think about this application?"},{"location":"design_philosophy/#some-general-notes-to-consider","text":"","title":"Some general notes to consider"},{"location":"design_philosophy/#modular-reusable-components-with-single-responsibility","text":"The goal of the X\u2011LAB plotting framework is to help you turn raw scientific measurements into meaningful, reusable visualisations with minimal effort. The most important philosophy behind the entire system is reuse . This application is best integrated in your workflow by remembering to approach it from a modular angle. You should always ask yourself: \u201cCan I reuse something that already exists?\u201d Because over time your lab will accumulate: - reusable readers , - reusable DataCore , DataProcessorCore and Plotter subclasses, - portable DeviceWorkerCore subclasses with their widgets This reuse-first mindset ensures that even complex analyses remain understandable and maintainable. It is also further enhanced by the concept of single responsibility, which is core to the structure defined by the contracts. Keep this single responsibility and modularity in mind when extending this application to suit your needs.","title":"Modular, Reusable Components with Single Responsibility"},{"location":"design_philosophy/#abstract-base-classes-abcs-vs-core-implementations","text":"The framework exposes four architectural building blocks: Data DataProcessor DeviceWorker Plotter Each defines what a new implementation must provide . On top of these, the framework offers recommended Core versions : DataCore DataProcessorCore DeviceWorkerCore The Core versions implement conventions and mechanisms encouraging structure and single-responsibility programming. You are free to implement the ABCs directly, but using the Core classes requires far less code as it provides a foundational interaction between the various components of this application.","title":"Abstract Base Classes (ABCs) vs Core Implementations"},{"location":"design_philosophy/#a-bidirectional-way-of-thinking","text":"Developing a new implementation is not a bottom\u2011up process. It is bidirectional : Data \u2192 Observables \u2192 Processing \u2192 Derived quantities Device \u2192 Visualisations \u2192 Plot functions \u2192 Plotters As a scientist, you will switch constantly between these two directions: What does my data contain? What can I read from the file? Which quantities can I derive from it? and What do I want to visualise? How do I want to visualise it? What must I access to show this? This interplay is what shapes your implementation.","title":"A Bidirectional Way of Thinking"},{"location":"design_philosophy/#you-already-have-a-working-default-implementation","text":"If you installed the default module, you should already be able to: create a dataset, pointing to two\u2011column files (e.g. voltage\u2013current, time\u2013signal, wavelength\u2013intensity), and plot those directly from the GUI. This documentation helps you go beyond that\u2014building your own scientific visualisation workflows.","title":"You Already Have a Working Default Implementation"},{"location":"design_philosophy/#building-your-own-implementation-a-scientists-workflow","text":"This section walks through the thought patterns you should follow when designing new analysis tools in the X\u2011LAB framework. It mirrors the real reasoning process I typically use in the lab.","title":"Building Your Own Implementation: A Scientist\u2019s Workflow"},{"location":"design_philosophy/#step-1-understand-your-data","text":"Before coding anything, inspect your raw files, what do they look like? Are these columnar text files or maybe matrices encoding an image? Do they contain headers, timestamps or metadata? Which quantities are present and are they labelled?? What units are used? And most importantly: Can the raw file already be successfully loaded by an existing file reader? Examples - An IV curve: Voltage (V) vs Current (A) - Time\u2011dependent signal: Time (s) vs intensity - LBIC: a 2D grid of currents - Spectra: wavelength vs counts - Temperature measurements: timestamp vs sensor value","title":"Step 1 \u2014 Understand Your Data"},{"location":"design_philosophy/#step-2-map-raw-data-to-observables-using-a-datacore-subclass","text":"Subclassing DataCore lets you define: which file reader is used to import the raw data how observables map to the general/agnostic structure returned by the reader what each observable\u2019s units are optional extraction of timestamps storage of raw values in the standard observable dictionary structure","title":"Step 2 \u2014 Map Raw Data to Observables Using a DataCore Subclass"},{"location":"design_philosophy/#your-thought-process-might-look-like-this","text":"\u201cThis file has two columns \u2192 I can reuse the csv reader I already have.\u201d \u201cColumn 0 is voltage \u2192 observable voltage , units V .\u201d \u201cColumn 1 is current \u2192 observable current , units A .\u201d \u201cI need the measurement timestamp \u2192 extract it from the filename or from the metadata.\u201d This gives the processor a clean, structured interface.","title":"Your Thought Process Might Look Like This:"},{"location":"design_philosophy/#step-3-decide-what-derived-quantities-you-need-and-let-dataprocessorcore-subclasses-compute-them","text":"Once raw observables exist, you think: \u201cWhat quantities do I need from this data? Is the raw data enough or can I compute any derived quantities\u201d Examples - IV: Aside from current-voltage curve one might want to know the open-circuit voltage, short-circuit current, fill factor, and maximum power point - Light-beam Induced Current scans give you axes and a current map, but you might want to extract a profile or look at the distribution of currents. - Time\u2011dependent IV: power conversion over time - Spectra: peak wavelength, full width at half maximum, integrated intensity A DataProcessorCore subclass allows you to add processing functions: self._processing_functions = { \"isc\": self.compute_short_circuit_current, \"voc\": self.compute_open_circuit_voltage, \"pce\": self.compute_power_conversion_efficiency, } The processor: - requests raw data from Data subclasses - computes derived quantities when needed - returns them in the same structured observable format - caches results for efficiency Your scientific reasoning\u2014\u201cwhat do I want to calculate?\u201d\u2014maps directly onto this class.","title":"Step 3 \u2014 Decide What Derived Quantities You Need And Let DataProcessorCore Subclasses Compute them"},{"location":"design_philosophy/#step-4-think-about-the-visualisations-you-want","text":"This is where the bidirectional aspect of the implementation starts becoming important: \u201cGiven the data and derived observables, what plots do I want to be able to produce?\u201d One dataset \u2192 many plots. Examples IV Device - Raw IV curve - Efficiency extracted parameters - Time dependent behaviour LBIC Device - Heatmap of current density - Histogram of pixel values - Profiles along x and y Each of these can be obtained from the same basic data files but must be handled differently, usually by a dedicated DeviceWorker and DataProcessor , to produce the desired visualisation. Each DeviceWorker subclass is therefore coupled to a DataProcessor and Data class and plots becomes dedicated plot_{name} method inside your DeviceWorker subclass. These names also populate the GUI\u2019s \u201cplot selector\u201d, so choosing clear names helps users understand what each plot does.","title":"Step 4 \u2014 Think About the Visualisations You Want"},{"location":"design_philosophy/#step-5-build-the-deviceworker-the-orchestrator","text":"A DeviceWorker does four things: Sets the data_type (your DataCore subclass) and processor_type (your Processor subclass) during initialisation Defines multiple plot functions , one for each plot type (named plot_{name} as these are automatically detected by the GUI) Instantiates the needed Plotter inside each plot function, passing options and processors to it as needed. Your Internal Monologue Might Be : - \u201cThis LBIC device should expose: image, histogram, and profile plots.\u201d - \u201cEach is a separate plot function.\u201d - \u201cEach plot function will instantiate the appropriate plotter.\u201d - \u201cThe plotter only gets processors and options\u2014it never reads files directly.\u201d Workers never implement scientific logic and plotters should never need to know the desired observables. It is the task of the DeviceWorker to tell the plotter which observables to request from the DataProcessor . This ensures plotters stay reusable between devices and measurement types. In short they connect data \u2192 processors \u2192 plotters.","title":"Step 5 \u2014 Build the DeviceWorker (The Orchestrator)"},{"location":"design_philosophy/#step-6-provide-a-widget-for-user-options","text":"Each device needs its own widget, these are searched for by the GUI. It serves as the user\u2019s scientific control panel. Thought Process - \u201cShould the user choose the axis?\u201d \u2192 combo box with option_alias=\"x_axis\" - \u201cShould they toggle log\u2011scale?\u201d \u2192 check box with option_alias=\"log_y\" - \u201cDo they need a threshold?\u201d \u2192 spin box with option_alias=\"threshold\" The GUI automatically gathers these into a PlotterOptions object and passes it to the worker, which hands it over to the plotter to read and use if appropriate. This keeps plotters GUI\u2011independent. You can build widgets using: - Qt Designer (recommended) - A simple XML template you can copy and edit","title":"Step 6 \u2014 Provide a Widget for User Options"},{"location":"design_philosophy/#step-7-choose-or-reuse-a-plotter","text":"Plotters turn processed data into visuals. They should be as dumb and reusable as possible. Typical plotters include: - ScatterPlotter - HeatmapPlotter - HistogramPlotter If your visualisation matches any of these \u2192 reuse . Only create a new plotter when the visualisation is fundamentally different. Note that Plotters don\u2019t maintain state between plots, they are instantiated by the GUI and removed when the plot has been generated.","title":"Step 7 \u2014 Choose or Reuse a Plotter"},{"location":"design_philosophy/#understanding-the-dataset","text":"These datasets are fundamental to the GUI and are the main reason everything is interoperable. They can be created using the data creation window, are rebuilt when selecting files from any set to plot, and are used by all Cores to know where to find data. But one might wonder what they are, in short they are small metadata files containing: labelled paths to raw measurement files, optional colours or other needed metadata, an experiment reference date, Raw data is never modified, overwritten, or copied. It stays wherever you keep it\u2014your folder structure, your naming scheme, your archive. A dataset is just a pointer + metadata . It allows the worker to collect the correct files and instantiate a processor for each. This separation makes your workflow repeatable and safe. For more details see the dataset page .","title":"Understanding the Dataset"},{"location":"design_philosophy/#final-thoughts","text":"","title":"Final Thoughts"},{"location":"design_philosophy/#use-core-classes-when-possible","text":"They: - implement standard observable format - implement processing\u2011function patterns - implement multi\u2011file handling - implement worker threading - integrate cleanly with the GUI Using them means you only implement the parts that matter scientifically.","title":"Use Core Classes When Possible"},{"location":"design_philosophy/#deviate-only-when-necessary","text":"If your data or workflow doesn\u2019t fit the model: - you can use the ABCs directly - but then you must ensure compatibility - plotters cannot assume Core behavior - you must follow observable formatting yourself This is an advanced path\u2014only use it when the science requires it. By following this workflow\u2011oriented design approach, your implementation will naturally fit the X\u2011LAB ecosystem: raw data \u2192 observables \u2192 derived quantities datasets pointing to files + metadata devices offering multiple scientific workflows widgets capturing user intent plotters turning processors into visualisations And throughout the entire process, remember: Always reuse existing readers, processors, plotters, widgets, and devices whenever possible. Subclass only when needed. Implement the ABCs only when absolutely necessary. This is the mindset that keeps your code clean, scientific, powerful\u2014and future\u2011proof.","title":"Deviate Only When Necessary"},{"location":"getting_started/","text":"Getting started The X-LAB Plotting Manager is a PyQt-based desktop application for managing scientific data and generating publication-ready plots. It is designed around a clean separation between: Core GUI + contracts (this repository), and Device/experiment-specific implementations (separate package you provide) Install the software For instructions on installation see the installation page . \u2728 Make sure that you have an implementations module ready before proceeding. This can be done by writing your own or by cloning the provided implementation . \ud83d\ude80 Launch the GUI You can launch the GUI from your favourite IDE by pointing to gui.windows.MainWindow or by running the following command from the terminal: python -m gui.windows.MainWindow This opens the main application window: \ud83d\udce6 Creating a Dataset From the menu bar: File \u2192 Create Set This opens the Data Creation Window , where you build datasets based on structured datasets that define required data inputs and metadata. \ud83d\udcc9 Generating a plot Once you have created a DataSet , it will appear in the main window with a list of the available data, the device information is already loaded. From here, generating a plot is quick and interactive. 1\ufe0f\u20e3 Select the Files You Want to Plot The application is already aware of - the available plot types for the device associated with the set - the associated Data and DataProcessor types (from the implementations module) - all device-specific options on the right are loaded from the correct widget Inside the Set Contents panel , tick the files you want to include. You can select: a single file (e.g., one heatmap, one IV curve), or\\ multiple files (for overlays, comparisons, etc.), depending on your device's capabilities. This compatibility logic comes directly from how your device's DeviceWorker and Plotter implementations declare supported plots. 2\ufe0f\u20e3 Adjust Plot Options The Options panel on the right shows all customizable parameters for the chosen plot. This panel is defined by the widget for each device, meaning your implementation decides what appears here. Common options include: z-ranges, profiles normalisation etc. Two options are always available: - legend title - presentation I use the latter to format my plots to be clearer in a presentation context where I want line traces to be thicker for example. These options are gathered automatically into a PlotterOptions object: Plotters retrieve these values using: options.get_option(\"legend_title\") For example, a heatmap plotter can use these options to configure colour scales, ranges, and layout. 3\ufe0f\u20e3 Choose a Plot Type Open the Plot Type dropdown. Examples: - A 2D scan might enable plot_image and plot_distribution - A time-varying measurement might enable plot - IV measurements might enable plot_forward or plot_forward_and_reverse Internally, the selected plot corresponds to a method defined inside your device's worker. This makes the system extensible: any worker method named plot_* can become a selectable plot. 4\ufe0f\u20e3 Click Plot Press the Plot button to start a worker and generate the visualisation. Behind the scenes, the GUI: Instantiates the device's worker Sends it: a rebuilt DataSet containing the selected files the plot type a PlotterOptions instance Moves the worker into a background QThread Begins file reading (shown in the progress bar) and processing Each selected file is read using your concrete Data subclass and associated file reader ( self.file_reader() ) and processed with your DataProcessor subclass ( get_data() , derived observables, validation). A progress bar updates live, and the plot is drawn once the worker emits its finished signal. 5\ufe0f\u20e3 Enjoy Your Plot Depending on your plotter implementation: Plotly figures may open interactively (zoom, hover, export)\\ Static plots can be saved as SVG/PNG/PDF\\ Additional export helpers may run automatically","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"The X-LAB Plotting Manager is a PyQt-based desktop application for managing scientific data and generating publication-ready plots. It is designed around a clean separation between: Core GUI + contracts (this repository), and Device/experiment-specific implementations (separate package you provide)","title":"Getting started"},{"location":"getting_started/#install-the-software","text":"For instructions on installation see the installation page . \u2728 Make sure that you have an implementations module ready before proceeding. This can be done by writing your own or by cloning the provided implementation .","title":"Install the software"},{"location":"getting_started/#launch-the-gui","text":"You can launch the GUI from your favourite IDE by pointing to gui.windows.MainWindow or by running the following command from the terminal: python -m gui.windows.MainWindow This opens the main application window:","title":"\ud83d\ude80 Launch the GUI"},{"location":"getting_started/#creating-a-dataset","text":"From the menu bar: File \u2192 Create Set This opens the Data Creation Window , where you build datasets based on structured datasets that define required data inputs and metadata.","title":"\ud83d\udce6 Creating a Dataset"},{"location":"getting_started/#generating-a-plot","text":"Once you have created a DataSet , it will appear in the main window with a list of the available data, the device information is already loaded. From here, generating a plot is quick and interactive.","title":"\ud83d\udcc9 Generating a plot"},{"location":"getting_started/#1-select-the-files-you-want-to-plot","text":"The application is already aware of - the available plot types for the device associated with the set - the associated Data and DataProcessor types (from the implementations module) - all device-specific options on the right are loaded from the correct widget Inside the Set Contents panel , tick the files you want to include. You can select: a single file (e.g., one heatmap, one IV curve), or\\ multiple files (for overlays, comparisons, etc.), depending on your device's capabilities. This compatibility logic comes directly from how your device's DeviceWorker and Plotter implementations declare supported plots.","title":"1\ufe0f\u20e3 Select the Files You Want to Plot"},{"location":"getting_started/#2-adjust-plot-options","text":"The Options panel on the right shows all customizable parameters for the chosen plot. This panel is defined by the widget for each device, meaning your implementation decides what appears here. Common options include: z-ranges, profiles normalisation etc. Two options are always available: - legend title - presentation I use the latter to format my plots to be clearer in a presentation context where I want line traces to be thicker for example. These options are gathered automatically into a PlotterOptions object: Plotters retrieve these values using: options.get_option(\"legend_title\") For example, a heatmap plotter can use these options to configure colour scales, ranges, and layout.","title":"2\ufe0f\u20e3 Adjust Plot Options"},{"location":"getting_started/#3-choose-a-plot-type","text":"Open the Plot Type dropdown. Examples: - A 2D scan might enable plot_image and plot_distribution - A time-varying measurement might enable plot - IV measurements might enable plot_forward or plot_forward_and_reverse Internally, the selected plot corresponds to a method defined inside your device's worker. This makes the system extensible: any worker method named plot_* can become a selectable plot.","title":"3\ufe0f\u20e3 Choose a Plot Type"},{"location":"getting_started/#4-click-plot","text":"Press the Plot button to start a worker and generate the visualisation. Behind the scenes, the GUI: Instantiates the device's worker Sends it: a rebuilt DataSet containing the selected files the plot type a PlotterOptions instance Moves the worker into a background QThread Begins file reading (shown in the progress bar) and processing Each selected file is read using your concrete Data subclass and associated file reader ( self.file_reader() ) and processed with your DataProcessor subclass ( get_data() , derived observables, validation). A progress bar updates live, and the plot is drawn once the worker emits its finished signal.","title":"4\ufe0f\u20e3 Click Plot"},{"location":"getting_started/#5-enjoy-your-plot","text":"Depending on your plotter implementation: Plotly figures may open interactively (zoom, hover, export)\\ Static plots can be saved as SVG/PNG/PDF\\ Additional export helpers may run automatically","title":"5\ufe0f\u20e3 Enjoy Your Plot"},{"location":"implementing_contracts/","text":"How to Implement Contracts This page explains how to go from \u201cidea\u201d to a working implementation by wiring together the four main contracts: Data / DataCore DataProcessor / DataProcessorCore DeviceWorker / DeviceWorkerCore Plotter and its subclasses plus their supporting pieces: PlotterOptions , widgets, and datasets. This is the \u201chow to implement it in code\u201d companion to How to think about this application? . It assumes you\u2019ve read that first and now want something more concrete. 1. Overview of the Contracts 1.1 Data / DataCore \u2013 reading files and exposing observables The Data contract defines how raw files are turned into named observables . Key responsibilities: Read one raw file ( self.file_reader(filepath) ). Store raw values internally (e.g. in self.raw_data ). Provide values and units for each observable: get_data(observable) get_units(observable) get_allowed_observables() (names you support) DataCore implements all of this except read_file , and provides a standard internal format: self.raw_data[observable] = {\"units\": \"...\", \"data\": ...} You normally subclass DataCore , implement read_file , and fill self.raw_data . 1.2 DataProcessor / DataProcessorCore \u2013 derived quantities The DataProcessor contract defines how you compute derived observables from raw data . Key responsibilities: get_data(observable, *args, **kwargs) \u2013 returns raw or processed data. get_units(observable) \u2013 units for any observable. validate_observables(*args) \u2013 sanity checks. Use a reference to a Data instance. DataProcessorCore : Talks to Data for raw values. Contains a dictionary of processing functions: python self._processing_functions = { \"elapsed_time\": self.elapsed_time, # your functions here\u2026 } Caches results in self.processed_data to avoid recomputation. You usually subclass DataProcessorCore , add entries to _processing_functions , and implement the corresponding methods. 1.3 DeviceWorker / DeviceWorkerCore \u2013 orchestrating the workflow The DeviceWorker contract defines how one device turns a dataset into one or more plots , typically in a background thread. Responsibilities: Know which Data and DataProcessor subclasses to use ( set_data_type , set_processor_type ). Read all files from a dataset and build a processor per file ( set_data(dataspec) ). Expose plot functions (named plot_{something} ) that: instantiate a plotter call ready_plot with processors and options call draw_plot DeviceWorkerCore already: Manages Qt signals ( finished , progress ). Reads all files from a DataSpec into self.data_processors . Injects useful options (e.g. experiment datetime, colours) into PlotterOptions . You generally subclass DeviceWorkerCore , set the types, and implement a few plot_* methods. 1.4 Plotter and its subclasses \u2013 turning processors into figures The Plotter contract is minimal: ready_plot(processors, options) \u2013 configure everything. draw_plot() \u2013 actually build and show the figure. Concrete plotters like HeatmapPlotter : Expect a mapping of keys \u2192 processors. Use processor.get_data() and processor.get_units() to get values and labels. Configure Plotly/Matplotlib objects and show them. You can reuse existing plotters (scatter, heatmap, histogram, \u2026) or implement your own when the visualisation is new. 1.5 PlotterOptions \u2013 options bridge PlotterOptions is a simple key\u2013value store for options coming from the GUI: add_option(label, value) get_option(label) has_options(labels) The GUI builds this from widget elements with an option_alias . The worker passes it on to the plotter. Plotters read it to configure axes, ranges, log scales, etc. 2. Step-by-Step: Implementing All Contracts We\u2019ll implement a simple IV device that: reads two-column IV data (voltage, current), computes voc and isc , exposes two plots: raw IV curve, a small \u201cparameters\u201d view. This mirrors the workflow you described in the \u201cHow to think about this application?\u201d page. Step 0 \u2013 Decide what you want Before touching code, answer: What do the files look like? Two columns: V (voltage), I (current). What observables do I need? Raw: voltage , current . Derived: voc , isc . What plots should the device offer? plot_iv_curve plot_iv_parameters Which visualisation type fits? IV curve \u2192 scatter/line plot. Parameters \u2192 maybe a simple text summary. We\u2019ll assume a generic ScatterPlotter already exists (similar in spirit to HeatmapPlotter ). Step 1 \u2013 Implement the Data contract with a DataCore subclass Create a class (e.g. IVData ) that: subclasses DataCore , implements read_file , fills self.raw_data with the right observables. Skeleton: from analysis.data.data_types.data_types import DataCore # path adjusted to your project class IVData(DataCore): def __init__(self, label): super().__init__(file_reader=read_two_column_file) self.raw_data = { \"voltage\": None, \"current\": None, } self._allowed_observables = self.raw_data.keys() def read_file(self, filepath: str) -> None: # 1. Reuse an existing reader (csv, etc.) file_results = self.file_reader(filepath) # your reader # 2. Store observables using the standard structure if self.raw_data[\"voltage\"] is None: self.raw_data[\"voltage\"] = {\"units\": \"V\", \"data\": file_results['0']} if self.raw_data[\"current\"] is None: self.raw_data[\"current\"] = {\"units\": \"A\", \"data\": file_results['1']} Notes: DataCore.get_data , get_units , and get_allowed_observables are already implemented for you. The important part is populating self.raw_data and _allowed_observables . Step 2 \u2013 Implement DataProcessor with a DataProcessorCore subclass Next, create an IVProcessor that: uses your IVData , computes voc and isc , reuses the core behavior for everything else. from contracts.data_processors import DataProcessorCore from implementations.data.data_types.iv_data import IVData class IVProcessor(DataProcessorCore): def __init__(self, data: IVData): super().__init__(data) # Add your own processing functions self._processing_functions.update({ \"voc\": self.compute_open_circuit_voltage, \"isc\": self.compute_short_circuit_current, }) # Reset processed_data & keys after updating self.processed_data = {key: None for key in self._processing_functions} self._processed_observables = self.processed_data.keys() def compute_open_circuit_voltage(self): voltage = self.get_data(\"voltage\") current = self.get_data(\"current\") # Very naive example: find V where I is closest to 0 idx = min(range(len(current)), key=lambda i: abs(current[i])) return {\"units\": \"V\", \"data\": voltage[idx]} def compute_short_circuit_current(self): voltage = self.get_data(\"voltage\") current = self.get_data(\"current\") # Naive example: find I where V is closest to 0 idx = min(range(len(voltage)), key=lambda i: abs(voltage[i])) return {\"units\": \"A\", \"data\": current[idx]} def validate_observables(self, *observables) -> None: \"\"\"Optional: sanity checks before plotting.\"\"\" for obs in observables: if ( obs not in self.data.get_allowed_observables() and obs not in self._processed_observables ): raise ValueError(f\"Observable '{obs}' not available for IVProcessor\") This uses the DataProcessorCore machinery: raw requests are delegated to data by the DataProcessorCore, processed requests computed on demand and cached, units resolved consistently. Step 3 \u2013 Implement a DeviceWorker using DeviceWorkerCore Now we glue everything together with an IVDeviceWorker . It should: set the data_type and processor_type , define plot_iv_curve and plot_iv_parameters , use existing plotters. from contracts.device_worker import DeviceWorkerCore from implementations.data.data_types.iv_data import IVData from implementations.data.data_processors.iv_processor import IVProcessor from implementations.plotters.scatter_plotter import ScatterPlotter # hypothetical from contracts.plotter_options import PlotterOptions # or wherever it lives class IVDeviceWorker(DeviceWorkerCore): def __init__(self, device, dataspec, plot_type, options: PlotterOptions): super().__init__(device, dataspec, plot_type, options) # Connect contracts self.set_data_type(IVData) self.set_processor_type(IVProcessor) def plot_iv_curve(self, title: str): \"\"\"Plot V-I curve for all selected files.\"\"\" plotter = ScatterPlotter(title=title) # self.data_processors is a dict: label \u2192 IVProcessor plotter.ready_plot(self.data_processors, self.options) plotter.draw_plot() def plot_iv_parameters(self, title: str): \"\"\"Plot Voc and Isc as points or bars.\"\"\" # You could reuse ScatterPlotter or something more tailored plotter = ScatterPlotter(title=title) # You might pre-process values into a form the plotter expects, # or let it call get_data(\"voc\") / get_data(\"isc\") directly. plotter.ready_plot(self.data_processors, self.options) plotter.draw_plot() Notes: DeviceWorkerCore.run() will call the method referenced by self.plot_type (e.g. \"plot_iv_curve\" ) and handle threading and signals. Each plot function must instantiate its own plotter to keep plotters stateless and reusable. Step 4 \u2013 Implement or reuse a Plotter If you already have a generic ScatterPlotter , use it. A minimal custom plotter implementing the Plotter contract might look like: from contracts.plotter import Plotter from contracts.plotter_options import PlotterOptions import plotly.graph_objects as go class ScatterPlotter(Plotter): def __init__(self, title: str): self.title = title self.fig = go.Figure() self.processors = None self.options = None def ready_plot(self, processors, options: PlotterOptions): # Store for later use self.processors = processors self.options = options self.fig.update_layout(title=self.title) def draw_plot(self): for label, processor in self.processors.items(): x = processor.get_data(\"voltage\") y = processor.get_data(\"current\") self.fig.add_trace( go.Scatter( x=x, y=y, mode=\"lines+markers\", name=label, ) ) self.fig.update_xaxes(title=processor.get_units(\"voltage\")) self.fig.update_yaxes(title=processor.get_units(\"current\")) self.fig.show() Step 5 \u2013 Add a widget and option_alias es For the IV device you might want: a checkbox for \u201clog y-axis\u201d a checkbox for \u201cshow markers\u201d maybe a dropdown for which derived parameter to show in the parameters plot In your Qt Designer / XML file, set: option_alias=\"log_y\" on the log-scale checkbox option_alias=\"show_markers\" on the markers checkbox The GUI will read those, build a PlotterOptions : options.add_option(\"log_y\", True or False) options.add_option(\"show_markers\", True or False) Your plotter can then react: if options.get_option(\"log_y\"): self.fig.update_yaxes(type=\"log\") PlotterOptions is just a small dict wrapper with helper methods, but it\u2019s the key bridge between GUI choices and plotting logic. Recap To implement a new workflow in the X-LAB framework, you: Define a DataCore subclass to read files and expose raw observables. Define a DataProcessorCore subclass to compute derived quantities needed for your science. Define a DeviceWorkerCore subclass that sets types, exposes plot_* methods, and instantiates plotters. Reuse or implement Plotter subclasses to convert processors into visualisations. Add a widget with option_alias es so users can control plots via the GUI, flowing through PlotterOptions . At every step, keep asking: Can I reuse an existing reader, DataCore, processor, plotter, or widget? If the answer is \u201cyes\u201d, your implementation will stay small, robust, and easy for the next scientist to understand.","title":"How do I implement contracts?"},{"location":"implementing_contracts/#how-to-implement-contracts","text":"This page explains how to go from \u201cidea\u201d to a working implementation by wiring together the four main contracts: Data / DataCore DataProcessor / DataProcessorCore DeviceWorker / DeviceWorkerCore Plotter and its subclasses plus their supporting pieces: PlotterOptions , widgets, and datasets. This is the \u201chow to implement it in code\u201d companion to How to think about this application? . It assumes you\u2019ve read that first and now want something more concrete.","title":"How to Implement Contracts"},{"location":"implementing_contracts/#1-overview-of-the-contracts","text":"","title":"1. Overview of the Contracts"},{"location":"implementing_contracts/#11-data-datacore-reading-files-and-exposing-observables","text":"The Data contract defines how raw files are turned into named observables . Key responsibilities: Read one raw file ( self.file_reader(filepath) ). Store raw values internally (e.g. in self.raw_data ). Provide values and units for each observable: get_data(observable) get_units(observable) get_allowed_observables() (names you support) DataCore implements all of this except read_file , and provides a standard internal format: self.raw_data[observable] = {\"units\": \"...\", \"data\": ...} You normally subclass DataCore , implement read_file , and fill self.raw_data .","title":"1.1 Data / DataCore \u2013 reading files and exposing observables"},{"location":"implementing_contracts/#12-dataprocessor-dataprocessorcore-derived-quantities","text":"The DataProcessor contract defines how you compute derived observables from raw data . Key responsibilities: get_data(observable, *args, **kwargs) \u2013 returns raw or processed data. get_units(observable) \u2013 units for any observable. validate_observables(*args) \u2013 sanity checks. Use a reference to a Data instance. DataProcessorCore : Talks to Data for raw values. Contains a dictionary of processing functions: python self._processing_functions = { \"elapsed_time\": self.elapsed_time, # your functions here\u2026 } Caches results in self.processed_data to avoid recomputation. You usually subclass DataProcessorCore , add entries to _processing_functions , and implement the corresponding methods.","title":"1.2 DataProcessor / DataProcessorCore \u2013 derived quantities"},{"location":"implementing_contracts/#13-deviceworker-deviceworkercore-orchestrating-the-workflow","text":"The DeviceWorker contract defines how one device turns a dataset into one or more plots , typically in a background thread. Responsibilities: Know which Data and DataProcessor subclasses to use ( set_data_type , set_processor_type ). Read all files from a dataset and build a processor per file ( set_data(dataspec) ). Expose plot functions (named plot_{something} ) that: instantiate a plotter call ready_plot with processors and options call draw_plot DeviceWorkerCore already: Manages Qt signals ( finished , progress ). Reads all files from a DataSpec into self.data_processors . Injects useful options (e.g. experiment datetime, colours) into PlotterOptions . You generally subclass DeviceWorkerCore , set the types, and implement a few plot_* methods.","title":"1.3 DeviceWorker / DeviceWorkerCore \u2013 orchestrating the workflow"},{"location":"implementing_contracts/#14-plotter-and-its-subclasses-turning-processors-into-figures","text":"The Plotter contract is minimal: ready_plot(processors, options) \u2013 configure everything. draw_plot() \u2013 actually build and show the figure. Concrete plotters like HeatmapPlotter : Expect a mapping of keys \u2192 processors. Use processor.get_data() and processor.get_units() to get values and labels. Configure Plotly/Matplotlib objects and show them. You can reuse existing plotters (scatter, heatmap, histogram, \u2026) or implement your own when the visualisation is new.","title":"1.4 Plotter and its subclasses \u2013 turning processors into figures"},{"location":"implementing_contracts/#15-plotteroptions-options-bridge","text":"PlotterOptions is a simple key\u2013value store for options coming from the GUI: add_option(label, value) get_option(label) has_options(labels) The GUI builds this from widget elements with an option_alias . The worker passes it on to the plotter. Plotters read it to configure axes, ranges, log scales, etc.","title":"1.5 PlotterOptions \u2013 options bridge"},{"location":"implementing_contracts/#2-step-by-step-implementing-all-contracts","text":"We\u2019ll implement a simple IV device that: reads two-column IV data (voltage, current), computes voc and isc , exposes two plots: raw IV curve, a small \u201cparameters\u201d view. This mirrors the workflow you described in the \u201cHow to think about this application?\u201d page.","title":"2. Step-by-Step: Implementing All Contracts"},{"location":"implementing_contracts/#step-0-decide-what-you-want","text":"Before touching code, answer: What do the files look like? Two columns: V (voltage), I (current). What observables do I need? Raw: voltage , current . Derived: voc , isc . What plots should the device offer? plot_iv_curve plot_iv_parameters Which visualisation type fits? IV curve \u2192 scatter/line plot. Parameters \u2192 maybe a simple text summary. We\u2019ll assume a generic ScatterPlotter already exists (similar in spirit to HeatmapPlotter ).","title":"Step 0 \u2013 Decide what you want"},{"location":"implementing_contracts/#step-1-implement-the-data-contract-with-a-datacore-subclass","text":"Create a class (e.g. IVData ) that: subclasses DataCore , implements read_file , fills self.raw_data with the right observables. Skeleton: from analysis.data.data_types.data_types import DataCore # path adjusted to your project class IVData(DataCore): def __init__(self, label): super().__init__(file_reader=read_two_column_file) self.raw_data = { \"voltage\": None, \"current\": None, } self._allowed_observables = self.raw_data.keys() def read_file(self, filepath: str) -> None: # 1. Reuse an existing reader (csv, etc.) file_results = self.file_reader(filepath) # your reader # 2. Store observables using the standard structure if self.raw_data[\"voltage\"] is None: self.raw_data[\"voltage\"] = {\"units\": \"V\", \"data\": file_results['0']} if self.raw_data[\"current\"] is None: self.raw_data[\"current\"] = {\"units\": \"A\", \"data\": file_results['1']} Notes: DataCore.get_data , get_units , and get_allowed_observables are already implemented for you. The important part is populating self.raw_data and _allowed_observables .","title":"Step 1 \u2013 Implement the Data contract with a DataCore subclass"},{"location":"implementing_contracts/#step-2-implement-dataprocessor-with-a-dataprocessorcore-subclass","text":"Next, create an IVProcessor that: uses your IVData , computes voc and isc , reuses the core behavior for everything else. from contracts.data_processors import DataProcessorCore from implementations.data.data_types.iv_data import IVData class IVProcessor(DataProcessorCore): def __init__(self, data: IVData): super().__init__(data) # Add your own processing functions self._processing_functions.update({ \"voc\": self.compute_open_circuit_voltage, \"isc\": self.compute_short_circuit_current, }) # Reset processed_data & keys after updating self.processed_data = {key: None for key in self._processing_functions} self._processed_observables = self.processed_data.keys() def compute_open_circuit_voltage(self): voltage = self.get_data(\"voltage\") current = self.get_data(\"current\") # Very naive example: find V where I is closest to 0 idx = min(range(len(current)), key=lambda i: abs(current[i])) return {\"units\": \"V\", \"data\": voltage[idx]} def compute_short_circuit_current(self): voltage = self.get_data(\"voltage\") current = self.get_data(\"current\") # Naive example: find I where V is closest to 0 idx = min(range(len(voltage)), key=lambda i: abs(voltage[i])) return {\"units\": \"A\", \"data\": current[idx]} def validate_observables(self, *observables) -> None: \"\"\"Optional: sanity checks before plotting.\"\"\" for obs in observables: if ( obs not in self.data.get_allowed_observables() and obs not in self._processed_observables ): raise ValueError(f\"Observable '{obs}' not available for IVProcessor\") This uses the DataProcessorCore machinery: raw requests are delegated to data by the DataProcessorCore, processed requests computed on demand and cached, units resolved consistently.","title":"Step 2 \u2013 Implement DataProcessor with a DataProcessorCore subclass"},{"location":"implementing_contracts/#step-3-implement-a-deviceworker-using-deviceworkercore","text":"Now we glue everything together with an IVDeviceWorker . It should: set the data_type and processor_type , define plot_iv_curve and plot_iv_parameters , use existing plotters. from contracts.device_worker import DeviceWorkerCore from implementations.data.data_types.iv_data import IVData from implementations.data.data_processors.iv_processor import IVProcessor from implementations.plotters.scatter_plotter import ScatterPlotter # hypothetical from contracts.plotter_options import PlotterOptions # or wherever it lives class IVDeviceWorker(DeviceWorkerCore): def __init__(self, device, dataspec, plot_type, options: PlotterOptions): super().__init__(device, dataspec, plot_type, options) # Connect contracts self.set_data_type(IVData) self.set_processor_type(IVProcessor) def plot_iv_curve(self, title: str): \"\"\"Plot V-I curve for all selected files.\"\"\" plotter = ScatterPlotter(title=title) # self.data_processors is a dict: label \u2192 IVProcessor plotter.ready_plot(self.data_processors, self.options) plotter.draw_plot() def plot_iv_parameters(self, title: str): \"\"\"Plot Voc and Isc as points or bars.\"\"\" # You could reuse ScatterPlotter or something more tailored plotter = ScatterPlotter(title=title) # You might pre-process values into a form the plotter expects, # or let it call get_data(\"voc\") / get_data(\"isc\") directly. plotter.ready_plot(self.data_processors, self.options) plotter.draw_plot() Notes: DeviceWorkerCore.run() will call the method referenced by self.plot_type (e.g. \"plot_iv_curve\" ) and handle threading and signals. Each plot function must instantiate its own plotter to keep plotters stateless and reusable.","title":"Step 3 \u2013 Implement a DeviceWorker using DeviceWorkerCore"},{"location":"implementing_contracts/#step-4-implement-or-reuse-a-plotter","text":"If you already have a generic ScatterPlotter , use it. A minimal custom plotter implementing the Plotter contract might look like: from contracts.plotter import Plotter from contracts.plotter_options import PlotterOptions import plotly.graph_objects as go class ScatterPlotter(Plotter): def __init__(self, title: str): self.title = title self.fig = go.Figure() self.processors = None self.options = None def ready_plot(self, processors, options: PlotterOptions): # Store for later use self.processors = processors self.options = options self.fig.update_layout(title=self.title) def draw_plot(self): for label, processor in self.processors.items(): x = processor.get_data(\"voltage\") y = processor.get_data(\"current\") self.fig.add_trace( go.Scatter( x=x, y=y, mode=\"lines+markers\", name=label, ) ) self.fig.update_xaxes(title=processor.get_units(\"voltage\")) self.fig.update_yaxes(title=processor.get_units(\"current\")) self.fig.show()","title":"Step 4 \u2013 Implement or reuse a Plotter"},{"location":"implementing_contracts/#step-5-add-a-widget-and-option_aliases","text":"For the IV device you might want: a checkbox for \u201clog y-axis\u201d a checkbox for \u201cshow markers\u201d maybe a dropdown for which derived parameter to show in the parameters plot In your Qt Designer / XML file, set: option_alias=\"log_y\" on the log-scale checkbox option_alias=\"show_markers\" on the markers checkbox The GUI will read those, build a PlotterOptions : options.add_option(\"log_y\", True or False) options.add_option(\"show_markers\", True or False) Your plotter can then react: if options.get_option(\"log_y\"): self.fig.update_yaxes(type=\"log\") PlotterOptions is just a small dict wrapper with helper methods, but it\u2019s the key bridge between GUI choices and plotting logic.","title":"Step 5 \u2013 Add a widget and option_aliases"},{"location":"implementing_contracts/#recap","text":"To implement a new workflow in the X-LAB framework, you: Define a DataCore subclass to read files and expose raw observables. Define a DataProcessorCore subclass to compute derived quantities needed for your science. Define a DeviceWorkerCore subclass that sets types, exposes plot_* methods, and instantiates plotters. Reuse or implement Plotter subclasses to convert processors into visualisations. Add a widget with option_alias es so users can control plots via the GUI, flowing through PlotterOptions . At every step, keep asking: Can I reuse an existing reader, DataCore, processor, plotter, or widget? If the answer is \u201cyes\u201d, your implementation will stay small, robust, and easy for the next scientist to understand.","title":"Recap"},{"location":"installing/","text":"Installing the Application 1) Install Python Ensure you have Python 3.10+ installed: https://www.python.org/downloads/ 2) Clone the project git clone https://github.com/Allyson-Robert/X-LAB_Plotting_Manager.git 3) Set up a virtual environment and install dependencies cd X-LAB_Plotting_Manager python -m venv .venv source .venv/bin/activate # Windows: .venv\\Scripts\\activate # Example for Python 3.12 pip install -r requirements-312.txt 4) Add an implementation package The GUI requires an implementation of the device/data/processor/plotter contracts. You may: Provide your own implementation inside implementations/ Or clone the official example implementation: git clone https://github.com/Allyson-Robert/X-LAB_Plotting_Manager_Implementations.git implementations/ pip install -r implementations/requirements-312.txt Without an implementation, the application will exit with an error on startup. \u2728 Yes\u2014you can write your own full implementation! The documentation explains how to implement devices, datasets, data classes, processors, and plotters.","title":"Installing"},{"location":"installing/#installing-the-application","text":"","title":"Installing the Application"},{"location":"installing/#1-install-python","text":"Ensure you have Python 3.10+ installed: https://www.python.org/downloads/","title":"1) Install Python"},{"location":"installing/#2-clone-the-project","text":"git clone https://github.com/Allyson-Robert/X-LAB_Plotting_Manager.git","title":"2) Clone the project"},{"location":"installing/#3-set-up-a-virtual-environment-and-install-dependencies","text":"cd X-LAB_Plotting_Manager python -m venv .venv source .venv/bin/activate # Windows: .venv\\Scripts\\activate # Example for Python 3.12 pip install -r requirements-312.txt","title":"3) Set up a virtual environment and install dependencies"},{"location":"installing/#4-add-an-implementation-package","text":"The GUI requires an implementation of the device/data/processor/plotter contracts. You may: Provide your own implementation inside implementations/ Or clone the official example implementation: git clone https://github.com/Allyson-Robert/X-LAB_Plotting_Manager_Implementations.git implementations/ pip install -r implementations/requirements-312.txt Without an implementation, the application will exit with an error on startup. \u2728 Yes\u2014you can write your own full implementation! The documentation explains how to implement devices, datasets, data classes, processors, and plotters.","title":"4) Add an implementation package"},{"location":"logging/","text":"Logging Logging provides insight into what the framework is doing , both internally and in your own extensions. It is especially important when: Running long or complex analyses Debugging failing devices, processors or plotters Understanding what happened in a past run This project provides a central logging setup that can write to the UI console , so users can see messages directly in the application Design goals The logging system is designed to: Feed logs into the GUI console for live feedback Make it easy to add logging to user defined methods and classes Enables logging by default on Data, DataProcessor, and Worker Core classes Conceptually, there are three main pieces: A shared logging configuration and helpers Pre-decorated framework components (especially worker cores) Decorators you can use on your own code (plotters, custom methods, etc.) Plotters and other user code Unlike workers, plotters do not have a core class that is pre-decorated. This is an intentional design choice: Plotters can be very simple or very complex Users may want fine-grained control over what is logged and when As a result: Plotters must be explicitly decorated by the user if they should participate in the logging system. The same is true for any other user-defined methods or classes that you want to show up in the logs (and optionally in the UI console): Custom data processors not deriving from DataProcessorCore Helper functions Utility classes By decorating them yourself, you decide: Which functions are logged At what level (info, debug, warning, error) How verbose the output should be Logging decorators The utilities module exposes decorators that do the heavy lifting. Typical patterns include: A function decorator \u2013 logs entry and exit of a function, plus optional details. A class decorator \u2013 automatically decorates every (or selected) method of a class. At a conceptual level, usage looks like this: from utils.logging import with_logging, decorate_class_with_logging @with_logging def my_helper_function(...): # your helper logic here ... @decorate_class_with_logging class MyCustomPlotter: def draw_plot(self, ...): Summary: Decorators are provided to decorate classes @decorate_class_with_logging and functions @with_logging . Cores come pre-decorated with logging, and their messages go to the UI console without extra effort. Plotters, and any other user-defined components, must be decorated explicitly to participate in the logging ecosystem. The logging utilities make it easy to track the execution of your code in a consistent way, providing a unified view of the system\u2019s behaviour. By using the logging system thoughtfully, you get a transparent, traceable view of your data analysis runs, from dataset-driven configuration through to final plots.","title":"Logging & debugging"},{"location":"logging/#logging","text":"Logging provides insight into what the framework is doing , both internally and in your own extensions. It is especially important when: Running long or complex analyses Debugging failing devices, processors or plotters Understanding what happened in a past run This project provides a central logging setup that can write to the UI console , so users can see messages directly in the application","title":"Logging"},{"location":"logging/#design-goals","text":"The logging system is designed to: Feed logs into the GUI console for live feedback Make it easy to add logging to user defined methods and classes Enables logging by default on Data, DataProcessor, and Worker Core classes Conceptually, there are three main pieces: A shared logging configuration and helpers Pre-decorated framework components (especially worker cores) Decorators you can use on your own code (plotters, custom methods, etc.)","title":"Design goals"},{"location":"logging/#plotters-and-other-user-code","text":"Unlike workers, plotters do not have a core class that is pre-decorated. This is an intentional design choice: Plotters can be very simple or very complex Users may want fine-grained control over what is logged and when As a result: Plotters must be explicitly decorated by the user if they should participate in the logging system. The same is true for any other user-defined methods or classes that you want to show up in the logs (and optionally in the UI console): Custom data processors not deriving from DataProcessorCore Helper functions Utility classes By decorating them yourself, you decide: Which functions are logged At what level (info, debug, warning, error) How verbose the output should be","title":"Plotters and other user code"},{"location":"logging/#logging-decorators","text":"The utilities module exposes decorators that do the heavy lifting. Typical patterns include: A function decorator \u2013 logs entry and exit of a function, plus optional details. A class decorator \u2013 automatically decorates every (or selected) method of a class. At a conceptual level, usage looks like this: from utils.logging import with_logging, decorate_class_with_logging @with_logging def my_helper_function(...): # your helper logic here ... @decorate_class_with_logging class MyCustomPlotter: def draw_plot(self, ...): Summary: Decorators are provided to decorate classes @decorate_class_with_logging and functions @with_logging . Cores come pre-decorated with logging, and their messages go to the UI console without extra effort. Plotters, and any other user-defined components, must be decorated explicitly to participate in the logging ecosystem. The logging utilities make it easy to track the execution of your code in a consistent way, providing a unified view of the system\u2019s behaviour. By using the logging system thoughtfully, you get a transparent, traceable view of your data analysis runs, from dataset-driven configuration through to final plots.","title":"Logging decorators"},{"location":"api/dataset_manager/","text":"DataSet Manager API Documentation Container for experiment metadata and associated data file locations. A DataSet instance describes a single experiment or dataset in terms of: - Basic metadata: name, creation date, experiment date/time, device identifier. - User annotations: free-form notes and a simple time-stamped console log. - File layout: a mapping from human-readable labels to absolute file paths. - Optional colour mapping: label-to-colour mapping for consistent plotting. - Structure type: how files are organised on disk (e.g. flat vs. directory-labelled). The class does not interpret the contents of the files; it only tracks their locations and minimal metadata. Filepaths can be: - Added manually via add_filepath , or - Auto-populated from a root directory using construct_filepaths(...) . Structure types \"flat\" : A simple one-level mapping from label -> file path. This is the default and most common mode; construct_filepaths_nrecursive will scan a single directory and register all supported files using their stem as label. \"dirlabelled\" : A directory-labelled mode where each top-level directory becomes a label and contains its own mapping of files. This is handled by construct_structured_filepaths and is considered deprecated in favour of the generic construct_filepaths . \"structured\" : Reserved for legacy/experimental layouts; treated as an allowed but user-managed structure type. Validation All paths added to the dataset are checked for: - Existence on disk. - Being a file (not a directory). - Having an extension in the accepted set ( xlsx , xls , csv , txt , dpt , json ). Two DataSet instances are considered equal if all their attributes (including filepaths, colours, and metadata) match exactly. Source code in dataset_manager\\dataset.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 @decorate_class_with_logging ( log_level = DEBUG ) class DataSet : \"\"\" Container for experiment metadata and associated data file locations. A `DataSet` instance describes a single experiment or dataset in terms of: - Basic metadata: name, creation date, experiment date/time, device identifier. - User annotations: free-form notes and a simple time-stamped console log. - File layout: a mapping from human-readable labels to absolute file paths. - Optional colour mapping: label-to-colour mapping for consistent plotting. - Structure type: how files are organised on disk (e.g. flat vs. directory-labelled). The class does *not* interpret the contents of the files; it only tracks their locations and minimal metadata. Filepaths can be: - Added manually via `add_filepath`, or - Auto-populated from a root directory using `construct_filepaths(...)`. Structure types ---------------- - ``\"flat\"``: A simple one-level mapping from label -> file path. This is the default and most common mode; `construct_filepaths_nrecursive` will scan a single directory and register all supported files using their stem as label. - ``\"dirlabelled\"``: A directory-labelled mode where each top-level directory becomes a label and contains its own mapping of files. This is handled by `construct_structured_filepaths` and is considered deprecated in favour of the generic `construct_filepaths`. - ``\"structured\"``: Reserved for legacy/experimental layouts; treated as an allowed but user-managed structure type. Validation ---------- All paths added to the dataset are checked for: - Existence on disk. - Being a file (not a directory). - Having an extension in the accepted set (``xlsx``, ``xls``, ``csv``, ``txt``, ``dpt``, ``json``). Two `DataSet` instances are considered equal if all their attributes (including filepaths, colours, and metadata) match exactly. \"\"\" # TODO: properly deprecate structured, assume flat for now _allowed_structure_types = ( \"flat\" , \"dirlabelled\" , \"structured\" ) _accepted_extensions = ( \"xlsx\" , \"xls\" , \"csv\" , \"txt\" , \"dpt\" , \"json\" ) def __init__ ( self , creation_date : str ): if not isinstance ( creation_date , str ): raise ValueError ( \"creation_date must be a string in format YYYY.MM.DD_HH.MM.SS\" ) self . location = None self . name = \"\" self . creation_date = datetime . strptime ( creation_date , \"%Y.%m. %d _%H.%M.%S\" ) self . experiment_date_time = None # FEATURE REQUEST: Allow multiple device types to be compatible with the same set self . device = \"\" self . notes = \"\" self . console = {} self . structure_type = None self . filepaths = {} self . colours = {} # Setters def set_name ( self , name : str ): if not isinstance ( name , str ): raise ValueError ( \"name must be a string\" ) self . name = name def set_experiment_date ( self , experiment_date_time : str ): if not isinstance ( experiment_date_time , str ): raise ValueError ( \"experiment_date_time must be a string in format YYYY.MM.DD_HH.MM.SS\" ) self . experiment_date_time = datetime . strptime ( experiment_date_time , \"%Y.%m. %d _%H.%M.%S\" ) def set_device ( self , device : str ): if not isinstance ( device , str ): raise ValueError ( \"device must be a string\" ) self . device = device def set_structure_type ( self , desired_type : str ): if not desired_type in self . _allowed_structure_types : raise ValueError if self . structure_type is None : self . structure_type = desired_type # Warn users when trying to overwrite the structure type def set_notes ( self , notes_content : str ): if not isinstance ( notes_content , str ): raise ValueError ( \"notes_content must be a string\" ) self . notes = notes_content def set_console ( self , console_content : dict ): if not isinstance ( console_content , dict ): raise ValueError ( \"console_content must be a dict\" ) self . console = console_content def set_filepaths ( self , filepaths : dict ): if not isinstance ( filepaths , dict ): raise ValueError ( \"filepaths must be a dict\" ) self . filepaths = filepaths def set_colours ( self , colours : dict ): if not isinstance ( colours , dict ): raise ValueError ( \"colours must be a dict\" ) self . colours = colours def set_location ( self , location : str ): if not isinstance ( location , str ): raise ValueError ( \"location must be a string/path\" ) self . location = location def construct_filepaths ( self , root_dir : str , type : str ) -> str : warnings . warn ( \"New function construct_filepaths_nrecursive not implemented recursively\" ) # TODO: Should depend on experiment type (making structure redundant)? # TODO: Something about the experiment type compatibility here. if type in self . _allowed_structure_types : self . set_structure_type ( type ) else : return f \"Incompatible structure type ( { type } ). Choose from { self . _allowed_structure_types } \" match type : case \"flat\" : return self . construct_filepaths_nrecursive ( root_dir ) case \"dirlabelled\" : return self . construct_structured_filepaths ( root_dir ) def construct_filepaths_nrecursive ( self , root_dir ) -> str : \"\"\" Will generate a flat file set and add it to the current filepaths. This will seek all files and of the giver root_dir and append all dataset files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" errors = \"\" # Checks which files are contained in the root dir items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : # Ignores duplicates if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Only add valid files path = f \" { root_dir } / { item } \" is_path_valid , error_msg = self . _check_valid_path ( path ) if is_path_valid : # Use filename as path label self . add_filepath ( path = path , label = Path ( path ) . stem ) else : errors += error_msg return errors def construct_filepaths_recursive ( self , root_dir ) -> str : raise NotImplementedError def construct_structured_filepaths ( self , root_dir : str ) -> str : \"\"\" Will generate a dirlabelled file set and add it to the current filepaths. This will seek all files and subdirectories of the giver root_dir and append all dataset files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" warnings . warn ( \"Function construct_structured_filepaths is deprecated use construct_filepaths instead\" , DeprecationWarning ) if self . get_structure_type () != \"flat\" : errors = \"\" items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Create nested dict for subdirectories path = f \" { root_dir } / { item } \" if not os . path . isfile ( path ): self . filepaths [ item ] = {} for file in natsort . natsorted ( os . listdir ( path )): # Only append to dataset if file is actually a file with an accepted extension filepath = f \" { path } / { file } \" is_path_valid , error_msg = self . _check_valid_path ( filepath ) if is_path_valid : self . filepaths [ item ][ file ] = filepath else : errors += error_msg else : errors = \"Flat dataset_manager cannot use dirlabelled construction\" return errors # Getters def get_filepath ( self , label : str ) -> str : return self . filepaths [ label ] def get_filepaths ( self ) -> dict : return self . filepaths def get_experiment_date ( self ): return self . experiment_date_time def get_single_colour ( self , label : str ) -> str : if label in self . colours . keys (): return self . colours [ label ] return None def get_all_colours ( self ) -> dict : if len ( self . colours ) == 0 : return None return self . colours def get_labels ( self ): return self . filepaths . keys () def get_console ( self ) -> dict : return self . console def get_notes ( self ) -> str : return self . notes def get_structure_type ( self ) -> str : return self . structure_type def get_device ( self ) -> str : return self . device def get_creation_date ( self ) -> datetime : return self . creation_date def get_name ( self ) -> str : return self . name def get_location ( self ) -> str | None : if self . location : return self . location return None # Adding / Appending def add_notes ( self , additional_notes : str ): if not isinstance ( additional_notes , str ): raise ValueError ( \"additional_notes must be a string\" ) self . notes += additional_notes def add_console ( self , date_and_time : str , additional_console : str ): if not isinstance ( date_and_time , str ): raise ValueError ( \"date_and_time must be a string\" ) if not isinstance ( additional_console , str ): raise ValueError ( \"additional_console must be a string\" ) self . console [ date_and_time ] = additional_console # Path management def add_filepath ( self , path : str , label : str ): # Wrap flat paths for validation if self . get_structure_type () == 'flat' : path_to_validate = { label : path } else : path_to_validate = path path_to_store = path # Check for duplicate label if label in self . filepaths . keys (): return \"Duplicate label found in dataset_manager\" # Check that all paths are valid for sublabel in path_to_validate : # Check path before adding: is_path_valid , error_msg = self . _check_valid_path ( path = path_to_validate [ sublabel ]) if not is_path_valid : print ( error_msg ) return \"Will not add file with disallowed extension\" # Add the path self . filepaths [ label ] = path_to_store return \"\" def add_colour ( self , colour : str , label : str ): # Checks for duplicate label if label in self . colours . keys (): return \"Duplicate label found in colours\" else : # Add the file to the dataset and update the gui self . colours [ label ] = colour # Checks are needed before paths are added to the dataset_manager def _check_valid_path ( self , path : str ): if not isinstance ( path , str ): raise ValueError ( \"path must be a string\" ) # Checks whether the path exists and points to a file if os . path . exists ( path ) and os . path . isfile ( path ): # Checks if the file has the proper extension if path . endswith ( self . _accepted_extensions ): return True , \"\" else : return False , f \"DataSet Forbidden Extension: Ignored { path } \\n \" elif os . path . exists ( path ) and not os . path . isfile ( path ): return False , f \"DataSet Not a File: Ignored { path } \\n \" else : return False , f \"DataSet Filesystem Error: Ignored { path } \\n \" def __eq__ ( self , other ): if type ( other ) is type ( self ): return self . __dict__ == other . __dict__ return False construct_filepaths_nrecursive ( root_dir ) Will generate a flat file set and add it to the current filepaths. This will seek all files and of the giver root_dir and append all dataset files to the filepaths attribute. Note that root_dir should be an absolute path. Source code in dataset_manager\\dataset.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def construct_filepaths_nrecursive ( self , root_dir ) -> str : \"\"\" Will generate a flat file set and add it to the current filepaths. This will seek all files and of the giver root_dir and append all dataset files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" errors = \"\" # Checks which files are contained in the root dir items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : # Ignores duplicates if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Only add valid files path = f \" { root_dir } / { item } \" is_path_valid , error_msg = self . _check_valid_path ( path ) if is_path_valid : # Use filename as path label self . add_filepath ( path = path , label = Path ( path ) . stem ) else : errors += error_msg return errors construct_structured_filepaths ( root_dir ) Will generate a dirlabelled file set and add it to the current filepaths. This will seek all files and subdirectories of the giver root_dir and append all dataset files to the filepaths attribute. Note that root_dir should be an absolute path. Source code in dataset_manager\\dataset.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def construct_structured_filepaths ( self , root_dir : str ) -> str : \"\"\" Will generate a dirlabelled file set and add it to the current filepaths. This will seek all files and subdirectories of the giver root_dir and append all dataset files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" warnings . warn ( \"Function construct_structured_filepaths is deprecated use construct_filepaths instead\" , DeprecationWarning ) if self . get_structure_type () != \"flat\" : errors = \"\" items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Create nested dict for subdirectories path = f \" { root_dir } / { item } \" if not os . path . isfile ( path ): self . filepaths [ item ] = {} for file in natsort . natsorted ( os . listdir ( path )): # Only append to dataset if file is actually a file with an accepted extension filepath = f \" { path } / { file } \" is_path_valid , error_msg = self . _check_valid_path ( filepath ) if is_path_valid : self . filepaths [ item ][ file ] = filepath else : errors += error_msg else : errors = \"Flat dataset_manager cannot use dirlabelled construction\" return errors Bases: JSONEncoder JSON encoder for DataSet objects and related dataclasses. This encoder provides two custom behaviours: datetime.datetime instances are serialised to a compact string representation using the format \"%Y.%m.%d_%H.%M.%S\" . This matches the format expected by DataSet and the corresponding JSON decoder. All other objects are serialised via their __dict__ attribute, which is sufficient for simple container-like classes such as DataSet . The encoder is intended to be used together with DataSetJSONEncoder to provide a round-trip-safe JSON representation of datasets. Source code in dataset_manager\\dataset_json_encoder.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @decorate_class_with_logging ( log_level = DEBUG ) class DataSetJSONEncoder ( JSONEncoder ): \"\"\" JSON encoder for `DataSet` objects and related dataclasses. This encoder provides two custom behaviours: - ``datetime.datetime`` instances are serialised to a compact string representation using the format ``\"%Y.%m.%d_%H.%M.%S\"``. This matches the format expected by `DataSet` and the corresponding JSON decoder. - All other objects are serialised via their ``__dict__`` attribute, which is sufficient for simple container-like classes such as `DataSet`. The encoder is intended to be used together with `DataSetJSONEncoder` to provide a round-trip-safe JSON representation of datasets. \"\"\" def default ( self , o ): if isinstance ( o , datetime . datetime ): return o . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) else : return o . __dict__ Bases: JSONDecoder Custom JSON decoder that reconstructs DataSet instances from JSON. This decoder installs an object_hook that: - Detects dictionaries carrying the expected DataSet fields (e.g. creation_date , name , device , experiment_date_time , notes , console , structure_type , filepaths , colours ). - Instantiates a new DataSet using the stored creation date. - Replays all relevant setters to restore metadata, structure type, paths, colours, and annotations. If a JSON object does not match the expected shape, it is returned unchanged, allowing non- DataSet data to be decoded normally. Source code in dataset_manager\\dataset_json_decoder.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @decorate_class_with_logging ( log_level = DEBUG ) class DataSetJSONDecoder ( JSONDecoder ): \"\"\" Custom JSON decoder that reconstructs `DataSet` instances from JSON. This decoder installs an `object_hook` that: - Detects dictionaries carrying the expected `DataSet` fields (e.g. ``creation_date``, ``name``, ``device``, ``experiment_date_time``, ``notes``, ``console``, ``structure_type``, ``filepaths``, ``colours``). - Instantiates a new `DataSet` using the stored creation date. - Replays all relevant setters to restore metadata, structure type, paths, colours, and annotations. If a JSON object does not match the expected shape, it is returned unchanged, allowing non-`DataSet` data to be decoded normally. \"\"\" def __init__ ( self , ** kwargs ): kwargs . setdefault ( \"object_hook\" , self . object_hook ) super () . __init__ ( ** kwargs ) @staticmethod def object_hook ( dct ): try : dataset = DataSet ( dct [ 'creation_date' ]) dataset . set_name ( dct [ 'name' ]) dataset . set_device ( dct [ 'device' ]) dataset . set_experiment_date ( dct [ 'experiment_date_time' ]) dataset . set_notes ( dct [ 'notes' ]) dataset . set_console ( dct [ 'console' ]) dataset . set_structure_type ( dct [ 'structure_type' ]) dataset . set_filepaths ( dct [ 'filepaths' ]) dataset . set_colours ( dct [ 'colours' ]) return dataset except KeyError : return dct Small helper class for persisting DataSet instances to and from JSON files. Responsibilities save_dataset(dataset, file_name) : Serialises a DataSet instance to disk using DataSetJSONDecoder . The method checks that the passed object is a DataSet and writes the encoded JSON to the given file path. open_dataset(file_name) : Opens a JSON file and deserialises it into a DataSet instance using DataSetJSONEncoder . The manager does not interpret the dataset content; it only handles the IO and wiring between JSON encoder/decoder and the underlying DataSet objects. Source code in dataset_manager\\dataset_manager.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @decorate_class_with_logging ( log_level = DEBUG ) class DataSetManager : \"\"\" Small helper class for persisting `DataSet` instances to and from JSON files. Responsibilities ---------------- - `save_dataset(dataset, file_name)`: Serialises a `DataSet` instance to disk using `DataSetJSONDecoder`. The method checks that the passed object is a `DataSet` and writes the encoded JSON to the given file path. - `open_dataset(file_name)`: Opens a JSON file and deserialises it into a `DataSet` instance using `DataSetJSONEncoder`. The manager does not interpret the dataset content; it only handles the IO and wiring between JSON encoder/decoder and the underlying `DataSet` objects. \"\"\" def __init__ ( self ): pass @staticmethod def save_dataset ( dataset , file_name ): \"\"\" Saves the dataset_manager data into a JSON file \"\"\" if not isinstance ( dataset , DataSet ): raise ValueError ( \"dataset must be an instance of DataSet\" ) # Who should check whether the filename is valid? with open ( file_name , \"w\" ) as json_file : json . dump ( dataset , json_file , cls = DataSetJSONDecoder ) json_file . close () @staticmethod def open_dataset ( file_name ): with open ( file_name ) as json_file : return json . load ( json_file , cls = DataSetJSONEncoder ) save_dataset ( dataset , file_name ) staticmethod Saves the dataset_manager data into a JSON file Source code in dataset_manager\\dataset_manager.py 29 30 31 32 33 34 35 36 37 38 @staticmethod def save_dataset ( dataset , file_name ): \"\"\" Saves the dataset_manager data into a JSON file \"\"\" if not isinstance ( dataset , DataSet ): raise ValueError ( \"dataset must be an instance of DataSet\" ) # Who should check whether the filename is valid? with open ( file_name , \"w\" ) as json_file : json . dump ( dataset , json_file , cls = DataSetJSONDecoder ) json_file . close ()","title":"DataSet"},{"location":"api/dataset_manager/#dataset-manager-api-documentation","text":"Container for experiment metadata and associated data file locations. A DataSet instance describes a single experiment or dataset in terms of: - Basic metadata: name, creation date, experiment date/time, device identifier. - User annotations: free-form notes and a simple time-stamped console log. - File layout: a mapping from human-readable labels to absolute file paths. - Optional colour mapping: label-to-colour mapping for consistent plotting. - Structure type: how files are organised on disk (e.g. flat vs. directory-labelled). The class does not interpret the contents of the files; it only tracks their locations and minimal metadata. Filepaths can be: - Added manually via add_filepath , or - Auto-populated from a root directory using construct_filepaths(...) .","title":"DataSet Manager API Documentation"},{"location":"api/dataset_manager/#dataset_manager.dataset.DataSet--structure-types","text":"\"flat\" : A simple one-level mapping from label -> file path. This is the default and most common mode; construct_filepaths_nrecursive will scan a single directory and register all supported files using their stem as label. \"dirlabelled\" : A directory-labelled mode where each top-level directory becomes a label and contains its own mapping of files. This is handled by construct_structured_filepaths and is considered deprecated in favour of the generic construct_filepaths . \"structured\" : Reserved for legacy/experimental layouts; treated as an allowed but user-managed structure type.","title":"Structure types"},{"location":"api/dataset_manager/#dataset_manager.dataset.DataSet--validation","text":"All paths added to the dataset are checked for: - Existence on disk. - Being a file (not a directory). - Having an extension in the accepted set ( xlsx , xls , csv , txt , dpt , json ). Two DataSet instances are considered equal if all their attributes (including filepaths, colours, and metadata) match exactly. Source code in dataset_manager\\dataset.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 @decorate_class_with_logging ( log_level = DEBUG ) class DataSet : \"\"\" Container for experiment metadata and associated data file locations. A `DataSet` instance describes a single experiment or dataset in terms of: - Basic metadata: name, creation date, experiment date/time, device identifier. - User annotations: free-form notes and a simple time-stamped console log. - File layout: a mapping from human-readable labels to absolute file paths. - Optional colour mapping: label-to-colour mapping for consistent plotting. - Structure type: how files are organised on disk (e.g. flat vs. directory-labelled). The class does *not* interpret the contents of the files; it only tracks their locations and minimal metadata. Filepaths can be: - Added manually via `add_filepath`, or - Auto-populated from a root directory using `construct_filepaths(...)`. Structure types ---------------- - ``\"flat\"``: A simple one-level mapping from label -> file path. This is the default and most common mode; `construct_filepaths_nrecursive` will scan a single directory and register all supported files using their stem as label. - ``\"dirlabelled\"``: A directory-labelled mode where each top-level directory becomes a label and contains its own mapping of files. This is handled by `construct_structured_filepaths` and is considered deprecated in favour of the generic `construct_filepaths`. - ``\"structured\"``: Reserved for legacy/experimental layouts; treated as an allowed but user-managed structure type. Validation ---------- All paths added to the dataset are checked for: - Existence on disk. - Being a file (not a directory). - Having an extension in the accepted set (``xlsx``, ``xls``, ``csv``, ``txt``, ``dpt``, ``json``). Two `DataSet` instances are considered equal if all their attributes (including filepaths, colours, and metadata) match exactly. \"\"\" # TODO: properly deprecate structured, assume flat for now _allowed_structure_types = ( \"flat\" , \"dirlabelled\" , \"structured\" ) _accepted_extensions = ( \"xlsx\" , \"xls\" , \"csv\" , \"txt\" , \"dpt\" , \"json\" ) def __init__ ( self , creation_date : str ): if not isinstance ( creation_date , str ): raise ValueError ( \"creation_date must be a string in format YYYY.MM.DD_HH.MM.SS\" ) self . location = None self . name = \"\" self . creation_date = datetime . strptime ( creation_date , \"%Y.%m. %d _%H.%M.%S\" ) self . experiment_date_time = None # FEATURE REQUEST: Allow multiple device types to be compatible with the same set self . device = \"\" self . notes = \"\" self . console = {} self . structure_type = None self . filepaths = {} self . colours = {} # Setters def set_name ( self , name : str ): if not isinstance ( name , str ): raise ValueError ( \"name must be a string\" ) self . name = name def set_experiment_date ( self , experiment_date_time : str ): if not isinstance ( experiment_date_time , str ): raise ValueError ( \"experiment_date_time must be a string in format YYYY.MM.DD_HH.MM.SS\" ) self . experiment_date_time = datetime . strptime ( experiment_date_time , \"%Y.%m. %d _%H.%M.%S\" ) def set_device ( self , device : str ): if not isinstance ( device , str ): raise ValueError ( \"device must be a string\" ) self . device = device def set_structure_type ( self , desired_type : str ): if not desired_type in self . _allowed_structure_types : raise ValueError if self . structure_type is None : self . structure_type = desired_type # Warn users when trying to overwrite the structure type def set_notes ( self , notes_content : str ): if not isinstance ( notes_content , str ): raise ValueError ( \"notes_content must be a string\" ) self . notes = notes_content def set_console ( self , console_content : dict ): if not isinstance ( console_content , dict ): raise ValueError ( \"console_content must be a dict\" ) self . console = console_content def set_filepaths ( self , filepaths : dict ): if not isinstance ( filepaths , dict ): raise ValueError ( \"filepaths must be a dict\" ) self . filepaths = filepaths def set_colours ( self , colours : dict ): if not isinstance ( colours , dict ): raise ValueError ( \"colours must be a dict\" ) self . colours = colours def set_location ( self , location : str ): if not isinstance ( location , str ): raise ValueError ( \"location must be a string/path\" ) self . location = location def construct_filepaths ( self , root_dir : str , type : str ) -> str : warnings . warn ( \"New function construct_filepaths_nrecursive not implemented recursively\" ) # TODO: Should depend on experiment type (making structure redundant)? # TODO: Something about the experiment type compatibility here. if type in self . _allowed_structure_types : self . set_structure_type ( type ) else : return f \"Incompatible structure type ( { type } ). Choose from { self . _allowed_structure_types } \" match type : case \"flat\" : return self . construct_filepaths_nrecursive ( root_dir ) case \"dirlabelled\" : return self . construct_structured_filepaths ( root_dir ) def construct_filepaths_nrecursive ( self , root_dir ) -> str : \"\"\" Will generate a flat file set and add it to the current filepaths. This will seek all files and of the giver root_dir and append all dataset files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" errors = \"\" # Checks which files are contained in the root dir items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : # Ignores duplicates if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Only add valid files path = f \" { root_dir } / { item } \" is_path_valid , error_msg = self . _check_valid_path ( path ) if is_path_valid : # Use filename as path label self . add_filepath ( path = path , label = Path ( path ) . stem ) else : errors += error_msg return errors def construct_filepaths_recursive ( self , root_dir ) -> str : raise NotImplementedError def construct_structured_filepaths ( self , root_dir : str ) -> str : \"\"\" Will generate a dirlabelled file set and add it to the current filepaths. This will seek all files and subdirectories of the giver root_dir and append all dataset files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" warnings . warn ( \"Function construct_structured_filepaths is deprecated use construct_filepaths instead\" , DeprecationWarning ) if self . get_structure_type () != \"flat\" : errors = \"\" items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Create nested dict for subdirectories path = f \" { root_dir } / { item } \" if not os . path . isfile ( path ): self . filepaths [ item ] = {} for file in natsort . natsorted ( os . listdir ( path )): # Only append to dataset if file is actually a file with an accepted extension filepath = f \" { path } / { file } \" is_path_valid , error_msg = self . _check_valid_path ( filepath ) if is_path_valid : self . filepaths [ item ][ file ] = filepath else : errors += error_msg else : errors = \"Flat dataset_manager cannot use dirlabelled construction\" return errors # Getters def get_filepath ( self , label : str ) -> str : return self . filepaths [ label ] def get_filepaths ( self ) -> dict : return self . filepaths def get_experiment_date ( self ): return self . experiment_date_time def get_single_colour ( self , label : str ) -> str : if label in self . colours . keys (): return self . colours [ label ] return None def get_all_colours ( self ) -> dict : if len ( self . colours ) == 0 : return None return self . colours def get_labels ( self ): return self . filepaths . keys () def get_console ( self ) -> dict : return self . console def get_notes ( self ) -> str : return self . notes def get_structure_type ( self ) -> str : return self . structure_type def get_device ( self ) -> str : return self . device def get_creation_date ( self ) -> datetime : return self . creation_date def get_name ( self ) -> str : return self . name def get_location ( self ) -> str | None : if self . location : return self . location return None # Adding / Appending def add_notes ( self , additional_notes : str ): if not isinstance ( additional_notes , str ): raise ValueError ( \"additional_notes must be a string\" ) self . notes += additional_notes def add_console ( self , date_and_time : str , additional_console : str ): if not isinstance ( date_and_time , str ): raise ValueError ( \"date_and_time must be a string\" ) if not isinstance ( additional_console , str ): raise ValueError ( \"additional_console must be a string\" ) self . console [ date_and_time ] = additional_console # Path management def add_filepath ( self , path : str , label : str ): # Wrap flat paths for validation if self . get_structure_type () == 'flat' : path_to_validate = { label : path } else : path_to_validate = path path_to_store = path # Check for duplicate label if label in self . filepaths . keys (): return \"Duplicate label found in dataset_manager\" # Check that all paths are valid for sublabel in path_to_validate : # Check path before adding: is_path_valid , error_msg = self . _check_valid_path ( path = path_to_validate [ sublabel ]) if not is_path_valid : print ( error_msg ) return \"Will not add file with disallowed extension\" # Add the path self . filepaths [ label ] = path_to_store return \"\" def add_colour ( self , colour : str , label : str ): # Checks for duplicate label if label in self . colours . keys (): return \"Duplicate label found in colours\" else : # Add the file to the dataset and update the gui self . colours [ label ] = colour # Checks are needed before paths are added to the dataset_manager def _check_valid_path ( self , path : str ): if not isinstance ( path , str ): raise ValueError ( \"path must be a string\" ) # Checks whether the path exists and points to a file if os . path . exists ( path ) and os . path . isfile ( path ): # Checks if the file has the proper extension if path . endswith ( self . _accepted_extensions ): return True , \"\" else : return False , f \"DataSet Forbidden Extension: Ignored { path } \\n \" elif os . path . exists ( path ) and not os . path . isfile ( path ): return False , f \"DataSet Not a File: Ignored { path } \\n \" else : return False , f \"DataSet Filesystem Error: Ignored { path } \\n \" def __eq__ ( self , other ): if type ( other ) is type ( self ): return self . __dict__ == other . __dict__ return False","title":"Validation"},{"location":"api/dataset_manager/#dataset_manager.dataset.DataSet.construct_filepaths_nrecursive","text":"Will generate a flat file set and add it to the current filepaths. This will seek all files and of the giver root_dir and append all dataset files to the filepaths attribute. Note that root_dir should be an absolute path. Source code in dataset_manager\\dataset.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def construct_filepaths_nrecursive ( self , root_dir ) -> str : \"\"\" Will generate a flat file set and add it to the current filepaths. This will seek all files and of the giver root_dir and append all dataset files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" errors = \"\" # Checks which files are contained in the root dir items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : # Ignores duplicates if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Only add valid files path = f \" { root_dir } / { item } \" is_path_valid , error_msg = self . _check_valid_path ( path ) if is_path_valid : # Use filename as path label self . add_filepath ( path = path , label = Path ( path ) . stem ) else : errors += error_msg return errors","title":"construct_filepaths_nrecursive"},{"location":"api/dataset_manager/#dataset_manager.dataset.DataSet.construct_structured_filepaths","text":"Will generate a dirlabelled file set and add it to the current filepaths. This will seek all files and subdirectories of the giver root_dir and append all dataset files to the filepaths attribute. Note that root_dir should be an absolute path. Source code in dataset_manager\\dataset.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def construct_structured_filepaths ( self , root_dir : str ) -> str : \"\"\" Will generate a dirlabelled file set and add it to the current filepaths. This will seek all files and subdirectories of the giver root_dir and append all dataset files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" warnings . warn ( \"Function construct_structured_filepaths is deprecated use construct_filepaths instead\" , DeprecationWarning ) if self . get_structure_type () != \"flat\" : errors = \"\" items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Create nested dict for subdirectories path = f \" { root_dir } / { item } \" if not os . path . isfile ( path ): self . filepaths [ item ] = {} for file in natsort . natsorted ( os . listdir ( path )): # Only append to dataset if file is actually a file with an accepted extension filepath = f \" { path } / { file } \" is_path_valid , error_msg = self . _check_valid_path ( filepath ) if is_path_valid : self . filepaths [ item ][ file ] = filepath else : errors += error_msg else : errors = \"Flat dataset_manager cannot use dirlabelled construction\" return errors Bases: JSONEncoder JSON encoder for DataSet objects and related dataclasses. This encoder provides two custom behaviours: datetime.datetime instances are serialised to a compact string representation using the format \"%Y.%m.%d_%H.%M.%S\" . This matches the format expected by DataSet and the corresponding JSON decoder. All other objects are serialised via their __dict__ attribute, which is sufficient for simple container-like classes such as DataSet . The encoder is intended to be used together with DataSetJSONEncoder to provide a round-trip-safe JSON representation of datasets. Source code in dataset_manager\\dataset_json_encoder.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @decorate_class_with_logging ( log_level = DEBUG ) class DataSetJSONEncoder ( JSONEncoder ): \"\"\" JSON encoder for `DataSet` objects and related dataclasses. This encoder provides two custom behaviours: - ``datetime.datetime`` instances are serialised to a compact string representation using the format ``\"%Y.%m.%d_%H.%M.%S\"``. This matches the format expected by `DataSet` and the corresponding JSON decoder. - All other objects are serialised via their ``__dict__`` attribute, which is sufficient for simple container-like classes such as `DataSet`. The encoder is intended to be used together with `DataSetJSONEncoder` to provide a round-trip-safe JSON representation of datasets. \"\"\" def default ( self , o ): if isinstance ( o , datetime . datetime ): return o . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) else : return o . __dict__ Bases: JSONDecoder Custom JSON decoder that reconstructs DataSet instances from JSON. This decoder installs an object_hook that: - Detects dictionaries carrying the expected DataSet fields (e.g. creation_date , name , device , experiment_date_time , notes , console , structure_type , filepaths , colours ). - Instantiates a new DataSet using the stored creation date. - Replays all relevant setters to restore metadata, structure type, paths, colours, and annotations. If a JSON object does not match the expected shape, it is returned unchanged, allowing non- DataSet data to be decoded normally. Source code in dataset_manager\\dataset_json_decoder.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @decorate_class_with_logging ( log_level = DEBUG ) class DataSetJSONDecoder ( JSONDecoder ): \"\"\" Custom JSON decoder that reconstructs `DataSet` instances from JSON. This decoder installs an `object_hook` that: - Detects dictionaries carrying the expected `DataSet` fields (e.g. ``creation_date``, ``name``, ``device``, ``experiment_date_time``, ``notes``, ``console``, ``structure_type``, ``filepaths``, ``colours``). - Instantiates a new `DataSet` using the stored creation date. - Replays all relevant setters to restore metadata, structure type, paths, colours, and annotations. If a JSON object does not match the expected shape, it is returned unchanged, allowing non-`DataSet` data to be decoded normally. \"\"\" def __init__ ( self , ** kwargs ): kwargs . setdefault ( \"object_hook\" , self . object_hook ) super () . __init__ ( ** kwargs ) @staticmethod def object_hook ( dct ): try : dataset = DataSet ( dct [ 'creation_date' ]) dataset . set_name ( dct [ 'name' ]) dataset . set_device ( dct [ 'device' ]) dataset . set_experiment_date ( dct [ 'experiment_date_time' ]) dataset . set_notes ( dct [ 'notes' ]) dataset . set_console ( dct [ 'console' ]) dataset . set_structure_type ( dct [ 'structure_type' ]) dataset . set_filepaths ( dct [ 'filepaths' ]) dataset . set_colours ( dct [ 'colours' ]) return dataset except KeyError : return dct Small helper class for persisting DataSet instances to and from JSON files.","title":"construct_structured_filepaths"},{"location":"api/dataset_manager/#dataset_manager.dataset_manager.DataSetManager--responsibilities","text":"save_dataset(dataset, file_name) : Serialises a DataSet instance to disk using DataSetJSONDecoder . The method checks that the passed object is a DataSet and writes the encoded JSON to the given file path. open_dataset(file_name) : Opens a JSON file and deserialises it into a DataSet instance using DataSetJSONEncoder . The manager does not interpret the dataset content; it only handles the IO and wiring between JSON encoder/decoder and the underlying DataSet objects. Source code in dataset_manager\\dataset_manager.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @decorate_class_with_logging ( log_level = DEBUG ) class DataSetManager : \"\"\" Small helper class for persisting `DataSet` instances to and from JSON files. Responsibilities ---------------- - `save_dataset(dataset, file_name)`: Serialises a `DataSet` instance to disk using `DataSetJSONDecoder`. The method checks that the passed object is a `DataSet` and writes the encoded JSON to the given file path. - `open_dataset(file_name)`: Opens a JSON file and deserialises it into a `DataSet` instance using `DataSetJSONEncoder`. The manager does not interpret the dataset content; it only handles the IO and wiring between JSON encoder/decoder and the underlying `DataSet` objects. \"\"\" def __init__ ( self ): pass @staticmethod def save_dataset ( dataset , file_name ): \"\"\" Saves the dataset_manager data into a JSON file \"\"\" if not isinstance ( dataset , DataSet ): raise ValueError ( \"dataset must be an instance of DataSet\" ) # Who should check whether the filename is valid? with open ( file_name , \"w\" ) as json_file : json . dump ( dataset , json_file , cls = DataSetJSONDecoder ) json_file . close () @staticmethod def open_dataset ( file_name ): with open ( file_name ) as json_file : return json . load ( json_file , cls = DataSetJSONEncoder )","title":"Responsibilities"},{"location":"api/dataset_manager/#dataset_manager.dataset_manager.DataSetManager.save_dataset","text":"Saves the dataset_manager data into a JSON file Source code in dataset_manager\\dataset_manager.py 29 30 31 32 33 34 35 36 37 38 @staticmethod def save_dataset ( dataset , file_name ): \"\"\" Saves the dataset_manager data into a JSON file \"\"\" if not isinstance ( dataset , DataSet ): raise ValueError ( \"dataset must be an instance of DataSet\" ) # Who should check whether the filename is valid? with open ( file_name , \"w\" ) as json_file : json . dump ( dataset , json_file , cls = DataSetJSONDecoder ) json_file . close ()","title":"save_dataset"},{"location":"api/contracts/devices/","text":"Devices Bases: type ( ABC ) , type ( QObject ) Metaclass enabling multiple inheritance of ABC and QObject. Overview Resolves metaclass conflicts so DeviceWorker can be both an ABC and a Qt QObject. Combines behavior of ABC and QtCore.QObject metatypes. Usage Notes Use this metaclass only for worker classes that inherit from QObject. Source code in contracts\\device_worker.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class WorkerMeta ( type ( ABC ), type ( QtCore . QObject )): \"\"\" Metaclass enabling multiple inheritance of ABC and QObject. Overview: Resolves metaclass conflicts so `DeviceWorker` can be both an ABC and a Qt QObject. - Combines behavior of `ABC` and `QtCore.QObject` metatypes. Usage Notes: Use this metaclass only for worker classes that inherit from QObject. \"\"\" pass Bases: ABC , QObject Abstract base for device worker objects that run in a Qt context. Overview Defines the required API for workers that accept a DataSet, run a task, and accept data/processor types. Required methods: set_data, run, set_data_type, set_processor_type. Provides a short identifier used for run labelling. Usage Notes Concrete workers should implement thread-safe run logic and emit signals. Source code in contracts\\device_worker.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class DeviceWorker ( ABC , QtCore . QObject , metaclass = WorkerMeta ): \"\"\" Abstract base for device worker objects that run in a Qt context. Overview: Defines the required API for workers that accept a DataSet, run a task, and accept data/processor types. - Required methods: set_data, run, set_data_type, set_processor_type. - Provides a short `identifier` used for run labelling. Usage Notes: Concrete workers should implement thread-safe run logic and emit signals. \"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . identifier = str ( uuid . uuid4 ())[: 4 ] @abstractmethod def set_data ( self , dataset : DataSet ): pass @abstractmethod def run ( self ): pass @abstractmethod def set_data_type ( self , data_type ): pass @abstractmethod def set_processor_type ( self , processor_type ): pass Bases: DeviceWorker Concrete worker base implementing common setup and progress handling. Overview Implements option handling, dataset instantiation and a simple run flow that prepares data processors, emits progress, and calls a plot. Manages device , dataset , plot_type , options , and data_processors . Populates processors per-file and emits progress / finished signals. set_data_type / set_processor_type are simple setters. Usage Notes Subclasses provide plotting methods referenced by plot_type and may extend run behaviour if needed. Source code in contracts\\device_worker.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 @decorate_class_with_logging ( log_level = DEBUG_WORKER ) class DeviceWorkerCore ( DeviceWorker ): \"\"\" Concrete worker base implementing common setup and progress handling. Overview: Implements option handling, dataset instantiation and a simple run flow that prepares data processors, emits progress, and calls a plot. - Manages `device`, `dataset`, `plot_type`, `options`, and `data_processors`. - Populates processors per-file and emits `progress`/`finished` signals. - `set_data_type` / `set_processor_type` are simple setters. Usage Notes: Subclasses provide plotting methods referenced by `plot_type` and may extend run behaviour if needed. \"\"\" finished = QtCore . pyqtSignal () progress = QtCore . pyqtSignal ( int ) def __init__ ( self , device , dataset , plot_type , options : PlotterOptions ): super () . __init__ () self . device = device self . dataset = dataset self . plot_type = plot_type self . options = options self . options . add_option ( label = \"experiment_datetime\" , value = dataset . get_experiment_date ()) self . data_processors = None self . processor_type = None self . data_type = None def set_data_type ( self , data_type ): if not issubclass ( data_type , Data ): raise TypeError ( \"data_type must be a subclass of Data\" ) self . data_type = data_type def set_processor_type ( self , processor_type ): if not issubclass ( processor_type , DataProcessor ): raise TypeError ( \"processor_type must be a subclass of DataProcessor\" ) self . processor_type = processor_type def set_data ( self , dataset : DataSet ): if not isinstance ( dataset , DataSet ): raise TypeError ( \"dataset must be an instance of DataSet\" ) # CHECK: Check that dataset and processor types have been set # Initialise an empty dict and get the required filepaths self . data_processors = {} filepaths = dataset . get_filepaths () colours = dataset . get_all_colours () if colours is not None : self . options . add_option ( label = \"colours\" , value = colours ) # Progress housekeeping nr_of_files = len ( filepaths ) counter = 0 # Read the dataset and instantiate a processor for each file for key in filepaths : data = self . data_type ( key ) data . read_file ( filepaths [ key ]) self . data_processors [ key ] = self . processor_type ( data ) # Emit progress signal counter += 1 self . progress . emit ( int ( 100 * counter / nr_of_files )) def run ( self ): # Set the data self . set_data ( self . dataset ) # Grab the correct plot and execute it, including uuid in the title title = f \" { self . dataset . get_name () } (run { self . identifier } )\" plot_type = getattr ( self , self . plot_type ) plot_type ( title = title ) self . finished . emit ()","title":"Contracts - Devices"},{"location":"api/contracts/devices/#devices","text":"Bases: type ( ABC ) , type ( QObject ) Metaclass enabling multiple inheritance of ABC and QObject. Overview Resolves metaclass conflicts so DeviceWorker can be both an ABC and a Qt QObject. Combines behavior of ABC and QtCore.QObject metatypes. Usage Notes Use this metaclass only for worker classes that inherit from QObject. Source code in contracts\\device_worker.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class WorkerMeta ( type ( ABC ), type ( QtCore . QObject )): \"\"\" Metaclass enabling multiple inheritance of ABC and QObject. Overview: Resolves metaclass conflicts so `DeviceWorker` can be both an ABC and a Qt QObject. - Combines behavior of `ABC` and `QtCore.QObject` metatypes. Usage Notes: Use this metaclass only for worker classes that inherit from QObject. \"\"\" pass Bases: ABC , QObject Abstract base for device worker objects that run in a Qt context. Overview Defines the required API for workers that accept a DataSet, run a task, and accept data/processor types. Required methods: set_data, run, set_data_type, set_processor_type. Provides a short identifier used for run labelling. Usage Notes Concrete workers should implement thread-safe run logic and emit signals. Source code in contracts\\device_worker.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class DeviceWorker ( ABC , QtCore . QObject , metaclass = WorkerMeta ): \"\"\" Abstract base for device worker objects that run in a Qt context. Overview: Defines the required API for workers that accept a DataSet, run a task, and accept data/processor types. - Required methods: set_data, run, set_data_type, set_processor_type. - Provides a short `identifier` used for run labelling. Usage Notes: Concrete workers should implement thread-safe run logic and emit signals. \"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . identifier = str ( uuid . uuid4 ())[: 4 ] @abstractmethod def set_data ( self , dataset : DataSet ): pass @abstractmethod def run ( self ): pass @abstractmethod def set_data_type ( self , data_type ): pass @abstractmethod def set_processor_type ( self , processor_type ): pass Bases: DeviceWorker Concrete worker base implementing common setup and progress handling. Overview Implements option handling, dataset instantiation and a simple run flow that prepares data processors, emits progress, and calls a plot. Manages device , dataset , plot_type , options , and data_processors . Populates processors per-file and emits progress / finished signals. set_data_type / set_processor_type are simple setters. Usage Notes Subclasses provide plotting methods referenced by plot_type and may extend run behaviour if needed. Source code in contracts\\device_worker.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 @decorate_class_with_logging ( log_level = DEBUG_WORKER ) class DeviceWorkerCore ( DeviceWorker ): \"\"\" Concrete worker base implementing common setup and progress handling. Overview: Implements option handling, dataset instantiation and a simple run flow that prepares data processors, emits progress, and calls a plot. - Manages `device`, `dataset`, `plot_type`, `options`, and `data_processors`. - Populates processors per-file and emits `progress`/`finished` signals. - `set_data_type` / `set_processor_type` are simple setters. Usage Notes: Subclasses provide plotting methods referenced by `plot_type` and may extend run behaviour if needed. \"\"\" finished = QtCore . pyqtSignal () progress = QtCore . pyqtSignal ( int ) def __init__ ( self , device , dataset , plot_type , options : PlotterOptions ): super () . __init__ () self . device = device self . dataset = dataset self . plot_type = plot_type self . options = options self . options . add_option ( label = \"experiment_datetime\" , value = dataset . get_experiment_date ()) self . data_processors = None self . processor_type = None self . data_type = None def set_data_type ( self , data_type ): if not issubclass ( data_type , Data ): raise TypeError ( \"data_type must be a subclass of Data\" ) self . data_type = data_type def set_processor_type ( self , processor_type ): if not issubclass ( processor_type , DataProcessor ): raise TypeError ( \"processor_type must be a subclass of DataProcessor\" ) self . processor_type = processor_type def set_data ( self , dataset : DataSet ): if not isinstance ( dataset , DataSet ): raise TypeError ( \"dataset must be an instance of DataSet\" ) # CHECK: Check that dataset and processor types have been set # Initialise an empty dict and get the required filepaths self . data_processors = {} filepaths = dataset . get_filepaths () colours = dataset . get_all_colours () if colours is not None : self . options . add_option ( label = \"colours\" , value = colours ) # Progress housekeeping nr_of_files = len ( filepaths ) counter = 0 # Read the dataset and instantiate a processor for each file for key in filepaths : data = self . data_type ( key ) data . read_file ( filepaths [ key ]) self . data_processors [ key ] = self . processor_type ( data ) # Emit progress signal counter += 1 self . progress . emit ( int ( 100 * counter / nr_of_files )) def run ( self ): # Set the data self . set_data ( self . dataset ) # Grab the correct plot and execute it, including uuid in the title title = f \" { self . dataset . get_name () } (run { self . identifier } )\" plot_type = getattr ( self , self . plot_type ) plot_type ( title = title ) self . finished . emit ()","title":"Devices"},{"location":"api/contracts/file_readers/","text":"File Readers File reader contracts for use by DataCore and DataProcessingCore. Defines the canonical function signature and return type used by all file readers in the X-LAB plotting ecosystem. A file reader is any callable matching FileReaderFn : (path: str) -> ReaderOutput Responsibilities Open and parse a file at the given path. Return structured raw data as a mapping of semantic keys (e.g. \"x_axis\", \"y_axis\", \"current\", \"meta\") to Python objects. Perform no higher-level processing or conversion to observables.","title":"Contracts - File Readers"},{"location":"api/contracts/file_readers/#file-readers","text":"File reader contracts for use by DataCore and DataProcessingCore. Defines the canonical function signature and return type used by all file readers in the X-LAB plotting ecosystem. A file reader is any callable matching FileReaderFn : (path: str) -> ReaderOutput Responsibilities Open and parse a file at the given path. Return structured raw data as a mapping of semantic keys (e.g. \"x_axis\", \"y_axis\", \"current\", \"meta\") to Python objects. Perform no higher-level processing or conversion to observables.","title":"File Readers"},{"location":"api/contracts/observable/","text":"Observable Observable contract used by DataCore and DataProcessorCore. Defines the canonical structure for observable entries stored in raw_data and processed_data mappings throughout the X-LAB plotting ecosystem. An Observable bundles a payload together with its display units: units : Human-readable unit string, or None for unitless data. data : The underlying payload (e.g. list, array, scalar, etc.).","title":"Contracts - Observable"},{"location":"api/contracts/observable/#observable","text":"Observable contract used by DataCore and DataProcessorCore. Defines the canonical structure for observable entries stored in raw_data and processed_data mappings throughout the X-LAB plotting ecosystem. An Observable bundles a payload together with its display units: units : Human-readable unit string, or None for unitless data. data : The underlying payload (e.g. list, array, scalar, etc.).","title":"Observable"},{"location":"api/contracts/data/data_processors/","text":"Data Processors Bases: ABC Abstract interface for data processors that derive observables from raw Data. Overview Defines the minimal contract for processing layers that expose computed observables and their units. Abstract methods: get_data, get_units, validate_observables. Focused on returning data and unit strings for named observables. Usage Notes Implementations should delegate raw observables to a Data instance and compute derived observables on demand. Source code in contracts\\data_processors.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class DataProcessor ( ABC ): \"\"\" Abstract interface for data processors that derive observables from raw Data. Overview: Defines the minimal contract for processing layers that expose computed observables and their units. - Abstract methods: get_data, get_units, validate_observables. - Focused on returning data and unit strings for named observables. Usage Notes: Implementations should delegate raw observables to a Data instance and compute derived observables on demand. \"\"\" @abstractmethod def get_data ( self , observable : str , * args , ** kwargs ) -> Any : pass @abstractmethod def get_units ( self , observable : str , * args , ** kwargs ) -> str : pass @abstractmethod def validate_observables ( self , * args , ** kwargs ) -> None : pass Bases: DataProcessor Default on\u2011demand processing core for derived observables. Overview Provides a processing-functions registry and a cache for computed results. Delegates raw observables to the wrapped Data object and computes others using registered functions. Maintains _processing_functions and processed_data cache. get_data/get_units compute lazily and raise ValueError if unknown. validate_observables remains abstract for concrete checks. Usage Notes Register per-observable processing functions in _processing_functions and ensure they return {\"units\": str, \"data\": ...} . Source code in contracts\\data_processors.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @decorate_class_with_logging ( log_level = DEBUG_DATA_PROCESSOR ) class DataProcessorCore ( DataProcessor ): \"\"\" Default on\u2011demand processing core for derived observables. Overview: Provides a processing-functions registry and a cache for computed results. Delegates raw observables to the wrapped Data object and computes others using registered functions. - Maintains `_processing_functions` and `processed_data` cache. - get_data/get_units compute lazily and raise ValueError if unknown. - validate_observables remains abstract for concrete checks. Usage Notes: Register per-observable processing functions in `_processing_functions` and ensure they return `{\"units\": str, \"data\": ...}`. \"\"\" processed_data : dict [ str , Observable ] processing_functions : dict [ str , Callable ] def __init__ ( self , data : Data ): self . data = data self . _processing_functions = { \"elapsed_time\" : self . elapsed_time } self . processed_data : dict [ str , Observable ] = {} for key in self . _processing_functions : self . processed_data [ key ] = None self . _processed_observables = self . processed_data . keys () def get_data ( self , observable : str , * args , ** kwargs ): # If observable is available from raw data delegate to Data if observable in self . data . get_allowed_observables (): return self . data . get_data ( observable ) # Compute processed data if needed elif observable in self . _processed_observables : if self . processed_data [ observable ] is None : # Adds the data to the processed_data dict after computing it self . processed_data [ observable ] = self . _processing_functions [ observable ]( * args , ** kwargs ) # Simply return if already set return self . processed_data [ observable ][ 'data' ] else : # FIXME: Apparently object has no attribute '__name__'. Did you mean: '__ne__'? gets triggered when ValueError is raised raise ValueError ( f \" { self . __class__ . __name__ } does not contain { observable } data\" ) def get_units ( self , observable : str , * args , ** kwargs ) -> str : self . get_data ( observable ) # Return raw data if observable in self . data . get_allowed_observables (): return self . data . get_units ( observable ) elif observable in self . _processed_observables : return self . processed_data [ observable ][ \"units\" ] else : raise ValueError ( f \" { self . __class__ . __name__ } does not contain { observable } data\" ) @abstractmethod def validate_observables ( self , * args , ** kwargs ) -> None : \"\"\" This function will check whether all requested observables are available. This should be implemented by the individual subclasses \"\"\" pass def elapsed_time ( self , * args , ** kwargs ) -> Observable : # Get a reference timestamp from *args reference_datetime = kwargs [ \"experiment_datetime\" ] data_datetime = self . get_data ( \"datetime\" ) return { \"units\" : \"$Elapsed ~time ~(hrs)$\" , \"data\" : data_datetime - reference_datetime } validate_observables ( * args , ** kwargs ) abstractmethod This function will check whether all requested observables are available. This should be implemented by the individual subclasses Source code in contracts\\data_processors.py 96 97 98 99 100 101 102 @abstractmethod def validate_observables ( self , * args , ** kwargs ) -> None : \"\"\" This function will check whether all requested observables are available. This should be implemented by the individual subclasses \"\"\" pass","title":"Data Processors"},{"location":"api/contracts/data/data_processors/#data-processors","text":"Bases: ABC Abstract interface for data processors that derive observables from raw Data. Overview Defines the minimal contract for processing layers that expose computed observables and their units. Abstract methods: get_data, get_units, validate_observables. Focused on returning data and unit strings for named observables. Usage Notes Implementations should delegate raw observables to a Data instance and compute derived observables on demand. Source code in contracts\\data_processors.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class DataProcessor ( ABC ): \"\"\" Abstract interface for data processors that derive observables from raw Data. Overview: Defines the minimal contract for processing layers that expose computed observables and their units. - Abstract methods: get_data, get_units, validate_observables. - Focused on returning data and unit strings for named observables. Usage Notes: Implementations should delegate raw observables to a Data instance and compute derived observables on demand. \"\"\" @abstractmethod def get_data ( self , observable : str , * args , ** kwargs ) -> Any : pass @abstractmethod def get_units ( self , observable : str , * args , ** kwargs ) -> str : pass @abstractmethod def validate_observables ( self , * args , ** kwargs ) -> None : pass Bases: DataProcessor Default on\u2011demand processing core for derived observables. Overview Provides a processing-functions registry and a cache for computed results. Delegates raw observables to the wrapped Data object and computes others using registered functions. Maintains _processing_functions and processed_data cache. get_data/get_units compute lazily and raise ValueError if unknown. validate_observables remains abstract for concrete checks. Usage Notes Register per-observable processing functions in _processing_functions and ensure they return {\"units\": str, \"data\": ...} . Source code in contracts\\data_processors.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @decorate_class_with_logging ( log_level = DEBUG_DATA_PROCESSOR ) class DataProcessorCore ( DataProcessor ): \"\"\" Default on\u2011demand processing core for derived observables. Overview: Provides a processing-functions registry and a cache for computed results. Delegates raw observables to the wrapped Data object and computes others using registered functions. - Maintains `_processing_functions` and `processed_data` cache. - get_data/get_units compute lazily and raise ValueError if unknown. - validate_observables remains abstract for concrete checks. Usage Notes: Register per-observable processing functions in `_processing_functions` and ensure they return `{\"units\": str, \"data\": ...}`. \"\"\" processed_data : dict [ str , Observable ] processing_functions : dict [ str , Callable ] def __init__ ( self , data : Data ): self . data = data self . _processing_functions = { \"elapsed_time\" : self . elapsed_time } self . processed_data : dict [ str , Observable ] = {} for key in self . _processing_functions : self . processed_data [ key ] = None self . _processed_observables = self . processed_data . keys () def get_data ( self , observable : str , * args , ** kwargs ): # If observable is available from raw data delegate to Data if observable in self . data . get_allowed_observables (): return self . data . get_data ( observable ) # Compute processed data if needed elif observable in self . _processed_observables : if self . processed_data [ observable ] is None : # Adds the data to the processed_data dict after computing it self . processed_data [ observable ] = self . _processing_functions [ observable ]( * args , ** kwargs ) # Simply return if already set return self . processed_data [ observable ][ 'data' ] else : # FIXME: Apparently object has no attribute '__name__'. Did you mean: '__ne__'? gets triggered when ValueError is raised raise ValueError ( f \" { self . __class__ . __name__ } does not contain { observable } data\" ) def get_units ( self , observable : str , * args , ** kwargs ) -> str : self . get_data ( observable ) # Return raw data if observable in self . data . get_allowed_observables (): return self . data . get_units ( observable ) elif observable in self . _processed_observables : return self . processed_data [ observable ][ \"units\" ] else : raise ValueError ( f \" { self . __class__ . __name__ } does not contain { observable } data\" ) @abstractmethod def validate_observables ( self , * args , ** kwargs ) -> None : \"\"\" This function will check whether all requested observables are available. This should be implemented by the individual subclasses \"\"\" pass def elapsed_time ( self , * args , ** kwargs ) -> Observable : # Get a reference timestamp from *args reference_datetime = kwargs [ \"experiment_datetime\" ] data_datetime = self . get_data ( \"datetime\" ) return { \"units\" : \"$Elapsed ~time ~(hrs)$\" , \"data\" : data_datetime - reference_datetime }","title":"Data Processors"},{"location":"api/contracts/data/data_processors/#contracts.data_processors.DataProcessorCore.validate_observables","text":"This function will check whether all requested observables are available. This should be implemented by the individual subclasses Source code in contracts\\data_processors.py 96 97 98 99 100 101 102 @abstractmethod def validate_observables ( self , * args , ** kwargs ) -> None : \"\"\" This function will check whether all requested observables are available. This should be implemented by the individual subclasses \"\"\" pass","title":"validate_observables"},{"location":"api/contracts/data/data_types/","text":"Data Types Bases: ABC Abstract interface for data containers. Overview Declares the contract for concrete data types used across the project. Abstract methods: read_file, get_data, get_units, get_allowed_observables. Intended as a minimal API that all data loaders/adapters must implement. Usage Notes Implementations should populate an internal representation and match the return expectations used by callers elsewhere in the codebase. Source code in contracts\\data_types.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Data ( ABC ): \"\"\" Abstract interface for data containers. Overview: Declares the contract for concrete data types used across the project. - Abstract methods: read_file, get_data, get_units, get_allowed_observables. - Intended as a minimal API that all data loaders/adapters must implement. Usage Notes: Implementations should populate an internal representation and match the return expectations used by callers elsewhere in the codebase. \"\"\" @abstractmethod def read_file ( self , filepath : str ) -> None : pass @abstractmethod def get_data ( self , observable : str ) -> list : pass @abstractmethod def get_units ( self , observable : str ) -> str : pass @abstractmethod def get_allowed_observables ( self ): pass Bases: Data Base implementation providing common behaviors for data types. Overview Supplies shared storage and partial method implementations useful to subclasses. Manages raw_data and _allowed_observables . Requires a file_reader conforming to FileReaderFn for loading raw data. Implements datetime extraction from filenames, get_data , get_units , and get_allowed_observables . Leaves read_file abstract so subclasses can: call self.file_reader(filepath) interpret its output into domain-specific observables. Usage Notes Subclasses must implement read_file and populate raw_data / _allowed_observables . get_data raises ValueError for unsupported observables. Source code in contracts\\data_types.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @decorate_class_with_logging ( log_level = DEBUG_DATA_TYPE ) class DataCore ( Data ): \"\"\" Base implementation providing common behaviors for data types. Overview: Supplies shared storage and partial method implementations useful to subclasses. - Manages `raw_data` and `_allowed_observables`. - Requires a `file_reader` conforming to `FileReaderFn` for loading raw data. - Implements datetime extraction from filenames, `get_data`, `get_units`, and `get_allowed_observables`. - Leaves `read_file` abstract so subclasses can: - call `self.file_reader(filepath)` - interpret its output into domain-specific observables. Usage Notes: Subclasses must implement `read_file` and populate `raw_data` / `_allowed_observables`. `get_data` raises ValueError for unsupported observables. \"\"\" raw_data : dict [ str , Observable ] def __init__ ( self , file_reader : FileReaderFn ): self . raw_data : dict [ str , Observable ] = {} self . _allowed_observables = {} self . file_reader = file_reader @abstractmethod def read_file ( self , filepath : str ) -> None : pass def _get_datetime_from_filename ( self , filepath : str ) -> None : datetime = CustomDatetime () filename = os . path . basename ( filepath ) self . raw_data [ 'datetime' ] = { \"units\" : None , \"data\" : datetime . create_datetime_from_string ( filename )} def get_data ( self , observable : str ) -> Any : if observable in self . _allowed_observables : return self . raw_data [ observable ][ 'data' ] else : raise ValueError ( f \" { self . __class__ . __name__ } does not contain { observable } data\" ) def get_units ( self , observable : str ) -> str : self . get_data ( observable ) return self . raw_data [ observable ][ \"units\" ] def get_allowed_observables ( self ): return self . _allowed_observables","title":"Data Types"},{"location":"api/contracts/data/data_types/#data-types","text":"Bases: ABC Abstract interface for data containers. Overview Declares the contract for concrete data types used across the project. Abstract methods: read_file, get_data, get_units, get_allowed_observables. Intended as a minimal API that all data loaders/adapters must implement. Usage Notes Implementations should populate an internal representation and match the return expectations used by callers elsewhere in the codebase. Source code in contracts\\data_types.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Data ( ABC ): \"\"\" Abstract interface for data containers. Overview: Declares the contract for concrete data types used across the project. - Abstract methods: read_file, get_data, get_units, get_allowed_observables. - Intended as a minimal API that all data loaders/adapters must implement. Usage Notes: Implementations should populate an internal representation and match the return expectations used by callers elsewhere in the codebase. \"\"\" @abstractmethod def read_file ( self , filepath : str ) -> None : pass @abstractmethod def get_data ( self , observable : str ) -> list : pass @abstractmethod def get_units ( self , observable : str ) -> str : pass @abstractmethod def get_allowed_observables ( self ): pass Bases: Data Base implementation providing common behaviors for data types. Overview Supplies shared storage and partial method implementations useful to subclasses. Manages raw_data and _allowed_observables . Requires a file_reader conforming to FileReaderFn for loading raw data. Implements datetime extraction from filenames, get_data , get_units , and get_allowed_observables . Leaves read_file abstract so subclasses can: call self.file_reader(filepath) interpret its output into domain-specific observables. Usage Notes Subclasses must implement read_file and populate raw_data / _allowed_observables . get_data raises ValueError for unsupported observables. Source code in contracts\\data_types.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @decorate_class_with_logging ( log_level = DEBUG_DATA_TYPE ) class DataCore ( Data ): \"\"\" Base implementation providing common behaviors for data types. Overview: Supplies shared storage and partial method implementations useful to subclasses. - Manages `raw_data` and `_allowed_observables`. - Requires a `file_reader` conforming to `FileReaderFn` for loading raw data. - Implements datetime extraction from filenames, `get_data`, `get_units`, and `get_allowed_observables`. - Leaves `read_file` abstract so subclasses can: - call `self.file_reader(filepath)` - interpret its output into domain-specific observables. Usage Notes: Subclasses must implement `read_file` and populate `raw_data` / `_allowed_observables`. `get_data` raises ValueError for unsupported observables. \"\"\" raw_data : dict [ str , Observable ] def __init__ ( self , file_reader : FileReaderFn ): self . raw_data : dict [ str , Observable ] = {} self . _allowed_observables = {} self . file_reader = file_reader @abstractmethod def read_file ( self , filepath : str ) -> None : pass def _get_datetime_from_filename ( self , filepath : str ) -> None : datetime = CustomDatetime () filename = os . path . basename ( filepath ) self . raw_data [ 'datetime' ] = { \"units\" : None , \"data\" : datetime . create_datetime_from_string ( filename )} def get_data ( self , observable : str ) -> Any : if observable in self . _allowed_observables : return self . raw_data [ observable ][ 'data' ] else : raise ValueError ( f \" { self . __class__ . __name__ } does not contain { observable } data\" ) def get_units ( self , observable : str ) -> str : self . get_data ( observable ) return self . raw_data [ observable ][ \"units\" ] def get_allowed_observables ( self ): return self . _allowed_observables","title":"Data Types"},{"location":"api/contracts/plotters/plotter/","text":"Plotter Bases: ABC Abstract plotting interface for rendering data from processors. Overview Specifies the minimal lifecycle for a plot: prepare with processors and options, then draw. Abstract methods: ready_plot(processors, options) and draw_plot(). Intended to separate data preparation from rendering. Usage Notes Implementations should be lightweight and accept a DataProcessor instance. Source code in contracts\\plotter.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Plotter ( ABC ): \"\"\" Abstract plotting interface for rendering data from processors. Overview: Specifies the minimal lifecycle for a plot: prepare with processors and options, then draw. - Abstract methods: ready_plot(processors, options) and draw_plot(). - Intended to separate data preparation from rendering. Usage Notes: Implementations should be lightweight and accept a DataProcessor instance. \"\"\" @abstractmethod def ready_plot ( self , processors : DataProcessor , options : dict ): pass @abstractmethod def draw_plot ( self ): pass","title":"Plotter"},{"location":"api/contracts/plotters/plotter/#plotter","text":"Bases: ABC Abstract plotting interface for rendering data from processors. Overview Specifies the minimal lifecycle for a plot: prepare with processors and options, then draw. Abstract methods: ready_plot(processors, options) and draw_plot(). Intended to separate data preparation from rendering. Usage Notes Implementations should be lightweight and accept a DataProcessor instance. Source code in contracts\\plotter.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Plotter ( ABC ): \"\"\" Abstract plotting interface for rendering data from processors. Overview: Specifies the minimal lifecycle for a plot: prepare with processors and options, then draw. - Abstract methods: ready_plot(processors, options) and draw_plot(). - Intended to separate data preparation from rendering. Usage Notes: Implementations should be lightweight and accept a DataProcessor instance. \"\"\" @abstractmethod def ready_plot ( self , processors : DataProcessor , options : dict ): pass @abstractmethod def draw_plot ( self ): pass","title":"Plotter"},{"location":"api/contracts/plotters/plotter_options/","text":"Plotter Options Small, dictionary-backed container for named plotter options. Overview Stores arbitrary named options, offers safe retrieval and as_kwargs filtering for passing options as **kwargs. Supports add_option, get_option, has_options, as_kwargs. Raises clear exceptions for missing keys or bad argument types. Usage Notes Use as a simple options bag shared between workers and plotters. Source code in contracts\\plotter_options.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @decorate_class_with_logging ( log_level = DEBUG_PLOTTER ) class PlotterOptions : \"\"\" Small, dictionary-backed container for named plotter options. Overview: Stores arbitrary named options, offers safe retrieval and `as_kwargs` filtering for passing options as **kwargs. - Supports add_option, get_option, has_options, as_kwargs. - Raises clear exceptions for missing keys or bad argument types. Usage Notes: Use as a simple options bag shared between workers and plotters. \"\"\" def __init__ ( self ): self . options = {} def add_option ( self , label : str , value ) -> bool : \"\"\" Add option if it does not already exist, if it does and the values conflict raise KeyError \"\"\" if not self . has_options ( label ): self . options [ label ] = value elif self . get_option ( label ) != value : raise KeyError ( f \"Option with label { label } already exists in PlotterOptions\" ) return True def update_option ( self , label : str , value ) -> bool : \"\"\" Update option if it exists, if not set option by calling add_option \"\"\" if self . has_options ( label ): self . options [ label ] = value else : self . add_option ( label , value ) return True # Return option def get_option ( self , label : str ): # Check option existance before returning if self . has_options ( label ): return self . options [ label ] else : return None # Check whether the option exists def has_options ( self , options_to_check ): # Single option will typically be a string, put in list to be handled below if isinstance ( options_to_check , str ): options_to_check = [ options_to_check ] # Check if a list was passed if isinstance ( options_to_check , list ): # Verify that all listed options are present in the keys, return false for first missing option for option in options_to_check : if option not in self . options . keys (): return False return True # Fail if options_to_check is neither list not string else : raise ValueError ( f \"Passed incorrect type to PlotterOptions class, { type ( options_to_check ) } of { options_to_check } is not list or string\" ) def __str__ ( self ): return_string = '' for key in self . options . keys (): return_string += f \" { key } : { self . options [ key ] } \" return return_string def as_kwargs ( self , keys = None ) -> dict : \"\"\" Return a dict of options that can be passed as **kwargs. \"\"\" # No filtering: return everything if keys is None : return dict ( self . options ) # Normalise single string to list if isinstance ( keys , str ): keys = [ keys ] # Sanity check try : iter ( keys ) except TypeError : raise TypeError ( \"keys must be None, a string, or an iterable of strings\" ) # Check all keys missing = [ k for k in keys if k not in self . options ] if missing : raise KeyError ( f \"Requested options not present: { missing } \" ) # Return kwarg dict return { k : self . options [ k ] for k in keys } add_option ( label , value ) Add option if it does not already exist, if it does and the values conflict raise KeyError Source code in contracts\\plotter_options.py 21 22 23 24 25 26 27 def add_option ( self , label : str , value ) -> bool : \"\"\" Add option if it does not already exist, if it does and the values conflict raise KeyError \"\"\" if not self . has_options ( label ): self . options [ label ] = value elif self . get_option ( label ) != value : raise KeyError ( f \"Option with label { label } already exists in PlotterOptions\" ) return True as_kwargs ( keys = None ) Return a dict of options that can be passed as **kwargs. Source code in contracts\\plotter_options.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def as_kwargs ( self , keys = None ) -> dict : \"\"\" Return a dict of options that can be passed as **kwargs. \"\"\" # No filtering: return everything if keys is None : return dict ( self . options ) # Normalise single string to list if isinstance ( keys , str ): keys = [ keys ] # Sanity check try : iter ( keys ) except TypeError : raise TypeError ( \"keys must be None, a string, or an iterable of strings\" ) # Check all keys missing = [ k for k in keys if k not in self . options ] if missing : raise KeyError ( f \"Requested options not present: { missing } \" ) # Return kwarg dict return { k : self . options [ k ] for k in keys } update_option ( label , value ) Update option if it exists, if not set option by calling add_option Source code in contracts\\plotter_options.py 29 30 31 32 33 34 35 def update_option ( self , label : str , value ) -> bool : \"\"\" Update option if it exists, if not set option by calling add_option \"\"\" if self . has_options ( label ): self . options [ label ] = value else : self . add_option ( label , value ) return True","title":"PlotterOptions"},{"location":"api/contracts/plotters/plotter_options/#plotter-options","text":"Small, dictionary-backed container for named plotter options. Overview Stores arbitrary named options, offers safe retrieval and as_kwargs filtering for passing options as **kwargs. Supports add_option, get_option, has_options, as_kwargs. Raises clear exceptions for missing keys or bad argument types. Usage Notes Use as a simple options bag shared between workers and plotters. Source code in contracts\\plotter_options.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @decorate_class_with_logging ( log_level = DEBUG_PLOTTER ) class PlotterOptions : \"\"\" Small, dictionary-backed container for named plotter options. Overview: Stores arbitrary named options, offers safe retrieval and `as_kwargs` filtering for passing options as **kwargs. - Supports add_option, get_option, has_options, as_kwargs. - Raises clear exceptions for missing keys or bad argument types. Usage Notes: Use as a simple options bag shared between workers and plotters. \"\"\" def __init__ ( self ): self . options = {} def add_option ( self , label : str , value ) -> bool : \"\"\" Add option if it does not already exist, if it does and the values conflict raise KeyError \"\"\" if not self . has_options ( label ): self . options [ label ] = value elif self . get_option ( label ) != value : raise KeyError ( f \"Option with label { label } already exists in PlotterOptions\" ) return True def update_option ( self , label : str , value ) -> bool : \"\"\" Update option if it exists, if not set option by calling add_option \"\"\" if self . has_options ( label ): self . options [ label ] = value else : self . add_option ( label , value ) return True # Return option def get_option ( self , label : str ): # Check option existance before returning if self . has_options ( label ): return self . options [ label ] else : return None # Check whether the option exists def has_options ( self , options_to_check ): # Single option will typically be a string, put in list to be handled below if isinstance ( options_to_check , str ): options_to_check = [ options_to_check ] # Check if a list was passed if isinstance ( options_to_check , list ): # Verify that all listed options are present in the keys, return false for first missing option for option in options_to_check : if option not in self . options . keys (): return False return True # Fail if options_to_check is neither list not string else : raise ValueError ( f \"Passed incorrect type to PlotterOptions class, { type ( options_to_check ) } of { options_to_check } is not list or string\" ) def __str__ ( self ): return_string = '' for key in self . options . keys (): return_string += f \" { key } : { self . options [ key ] } \" return return_string def as_kwargs ( self , keys = None ) -> dict : \"\"\" Return a dict of options that can be passed as **kwargs. \"\"\" # No filtering: return everything if keys is None : return dict ( self . options ) # Normalise single string to list if isinstance ( keys , str ): keys = [ keys ] # Sanity check try : iter ( keys ) except TypeError : raise TypeError ( \"keys must be None, a string, or an iterable of strings\" ) # Check all keys missing = [ k for k in keys if k not in self . options ] if missing : raise KeyError ( f \"Requested options not present: { missing } \" ) # Return kwarg dict return { k : self . options [ k ] for k in keys }","title":"Plotter Options"},{"location":"api/contracts/plotters/plotter_options/#contracts.plotter_options.PlotterOptions.add_option","text":"Add option if it does not already exist, if it does and the values conflict raise KeyError Source code in contracts\\plotter_options.py 21 22 23 24 25 26 27 def add_option ( self , label : str , value ) -> bool : \"\"\" Add option if it does not already exist, if it does and the values conflict raise KeyError \"\"\" if not self . has_options ( label ): self . options [ label ] = value elif self . get_option ( label ) != value : raise KeyError ( f \"Option with label { label } already exists in PlotterOptions\" ) return True","title":"add_option"},{"location":"api/contracts/plotters/plotter_options/#contracts.plotter_options.PlotterOptions.as_kwargs","text":"Return a dict of options that can be passed as **kwargs. Source code in contracts\\plotter_options.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def as_kwargs ( self , keys = None ) -> dict : \"\"\" Return a dict of options that can be passed as **kwargs. \"\"\" # No filtering: return everything if keys is None : return dict ( self . options ) # Normalise single string to list if isinstance ( keys , str ): keys = [ keys ] # Sanity check try : iter ( keys ) except TypeError : raise TypeError ( \"keys must be None, a string, or an iterable of strings\" ) # Check all keys missing = [ k for k in keys if k not in self . options ] if missing : raise KeyError ( f \"Requested options not present: { missing } \" ) # Return kwarg dict return { k : self . options [ k ] for k in keys }","title":"as_kwargs"},{"location":"api/contracts/plotters/plotter_options/#contracts.plotter_options.PlotterOptions.update_option","text":"Update option if it exists, if not set option by calling add_option Source code in contracts\\plotter_options.py 29 30 31 32 33 34 35 def update_option ( self , label : str , value ) -> bool : \"\"\" Update option if it exists, if not set option by calling add_option \"\"\" if self . has_options ( label ): self . options [ label ] = value else : self . add_option ( label , value ) return True","title":"update_option"},{"location":"api/gui/plot_manager/","text":"Graphical User Interface The following functions are classes are provided in the gui module. They are central in producing and managing the user interface as well as starting the worker threads responsible for producing plots from data. Plot Manager Orchestrate a plotting run in a background thread to keep the GUI responsive. Workflow Collect the selected file labels from the main window. Build a reduced DataSet containing only the selected files, colours, device, structure type, and name. Collect plotting options from the active device widget (via alias properties) and from global GUI controls, storing them in PlotterOptions . Resolve and instantiate the appropriate device worker class from the implementations.devices.workers namespace. Configure the worker with the reduced dataset, selected plot function, and options. Move the worker to a QThread , wire up progress/finished signals, and start the thread. The function logs a concise summary of the run (including a short run identifier) to the GUI console once the worker is started. Parameters window : QMainWindow Main application window providing access to the dataset, widgets (file selection, stacked options, checkboxes, etc.), and console API. Source code in gui\\plot_manager.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @with_logging def plot_manager ( window , * args , ** kwargs ): \"\"\" Orchestrate a plotting run in a background thread to keep the GUI responsive. Workflow -------- 1. Collect the selected file labels from the main window. 2. Build a reduced `DataSet` containing only the selected files, colours, device, structure type, and name. 3. Collect plotting options from the active device widget (via `alias` properties) and from global GUI controls, storing them in `PlotterOptions`. 4. Resolve and instantiate the appropriate device worker class from the `implementations.devices.workers` namespace. 5. Configure the worker with the reduced dataset, selected plot function, and options. 6. Move the worker to a `QThread`, wire up progress/finished signals, and start the thread. The function logs a concise summary of the run (including a short run identifier) to the GUI console once the worker is started. Parameters ---------- window : QMainWindow Main application window providing access to the dataset, widgets (file selection, stacked options, checkboxes, etc.), and console API. \"\"\" # Grab the selected files for plotting and build a reduced dataset dataset_time = datetime . datetime . now () . strftime ( constants . DATETIME_FORMAT ) experiment_time = window . dataset . get_experiment_date () . strftime ( constants . DATETIME_FORMAT ) dataset_selection = dataset_manager . DataSet ( dataset_time ) dataset_selection . set_experiment_date ( experiment_time ) for item in window . selectedFilesList . selectedItems (): lbl = item . text () structure = window . dataset . get_structure_type () dataset_selection . set_structure_type ( structure ) path = window . dataset . get_filepath ( lbl ) dataset_selection . add_filepath ( path , lbl ) colour = window . dataset . get_single_colour ( lbl ) dataset_selection . add_colour ( colour , lbl ) dataset_selection . set_device ( window . dataset . get_device ()) dataset_selection . set_structure_type ( window . dataset . get_structure_type ()) dataset_selection . set_name ( window . dataset . get_name ()) # Recursively search for QWidget children with an alias to collect options and get their values options = PlotterOptions () for option in window . stackedWidget . currentWidget () . findChildren ( QtWidgets . QWidget ): alias = option . property ( \"alias\" ) if alias is not None : option_value = get_qwidget_value ( option ) if option_value is not None : options . add_option ( label = alias , value = option_value ) options . add_option ( label = \"presentation\" , value = get_qwidget_value ( window . presentationCheckBox )) options . add_option ( label = \"legend_title\" , value = get_qwidget_value ( window . legendTitleLineEdit )) # Instantiate proper device class and set the data current_device_class = window . dataset . get_device () device_module = getattr ( implementations . devices . workers , current_device_class . lower ()) device = getattr ( device_module , current_device_class ) # # Grab the correct plotting function and pass all options to it plot_function = window . get_current_plot_function () # Create a new thread for the device class to run in window . thread = QtCore . QThread () window . device_worker = device ( current_device_class , dataset_selection , plot_function , options = options ) window . device_worker . moveToThread ( window . thread ) # Connect signals and slots for the worker thread window . thread . started . connect ( window . device_worker . run ) # When the worker says \"I'm done\", stop the thread and schedule the worker for deletion window . device_worker . finished . connect ( window . thread . quit ) window . device_worker . finished . connect ( window . device_worker . deleteLater ) # When the thread is actually finished, clean up and reset GUI window . thread . finished . connect ( window . thread . deleteLater ) window . thread . finished . connect ( window . on_plot_thread_finished ) # Progress updates window . device_worker . progress . connect ( window . report_progress ) # Start the thread window . thread . start () window . console_print ( f \"(run { window . device_worker . identifier } ) producing { current_device_class } - { plot_function } plot for { window . get_dataset_name () } with options { options } \" ) window . plotBtn . setEnabled ( False ) Utils Clear Fully reset the GUI state and remove all in-memory data. This helper: - Clears the active DataSet and GUI fields via clear_data . - Empties the console widget. - Writes a confirmation message to the GUI console. Parameters window : QMainWindow Main application window whose state should be cleared. Source code in gui\\utils\\clear\\clear_all.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def clear_all ( window : QtWidgets . QMainWindow ): \"\"\" Fully reset the GUI state and remove all in-memory data. This helper: - Clears the active `DataSet` and GUI fields via `clear_data`. - Empties the console widget. - Writes a confirmation message to the GUI console. Parameters ---------- window : QMainWindow Main application window whose state should be cleared. \"\"\" clear_data ( window ) window . consoleTextEdit . clear () window . console_print ( \"Cleared memory\" ) Clear the currently loaded dataset and reset all GUI widgets tied to it. Resets: - Stored DataSet object and its disk location. - Set name, device name, notes, and list widgets. - Plot type combobox and stacked widget view. A console message is printed to confirm completion. Parameters window : QMainWindow Main GUI instance that holds dataset-related widgets. Source code in gui\\utils\\clear\\clear_data.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def clear_data ( window : QtWidgets . QMainWindow ): \"\"\" Clear the currently loaded dataset and reset all GUI widgets tied to it. Resets: - Stored `DataSet` object and its disk location. - Set name, device name, notes, and list widgets. - Plot type combobox and stacked widget view. A console message is printed to confirm completion. Parameters ---------- window : QMainWindow Main GUI instance that holds dataset-related widgets. \"\"\" window . dataset = None window . dataset_location = None window . currSetNameLineEdit . clear () window . currDeviceLineEdit . clear () window . notesPlainText . clear () window . console_print ( \"Cleared dataset from memory\" ) window . stackedWidget . setCurrentWidget ( window . stackedWidget . widget ( 0 )) window . selectedFilesList . clear () window . plotTypeCombo . clear () DataSet Tools Launch the DataSet creation dialog and construct a new dataset from user input. Workflow: - Opens the DataSet creator window populated with available devices. - On confirmation: * Clears existing state. * Stores the newly created dataset. * Loads it into the GUI and updates the header. * Immediately saves it to disk. - If cancelled, informs the user that no dataset was created. Parameters window : QMainWindow Main application window controlling dataset creation. Source code in gui\\utils\\dataset_tools\\create_dataset.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @with_logging def create_dataset ( window : QtWidgets . QMainWindow , * args , ** kwargs ): \"\"\" Launch the DataSet creation dialog and construct a new dataset from user input. Workflow: - Opens the DataSet creator window populated with available devices. - On confirmation: * Clears existing state. * Stores the newly created dataset. * Loads it into the GUI and updates the header. * Immediately saves it to disk. - If cancelled, informs the user that no dataset was created. Parameters ---------- window : QMainWindow Main application window controlling dataset creation. \"\"\" window . set_dataset_window ( gui . windows . DataSetCreatorWindow . UiDataCreatorWindow ( devices = [ k for k in window . devices ])) window . get_dataset_window () . show () if window . dataWindow . exec () == 1 : # If the window was properly closed (Done button) then creation was successful # Copy dataset_tools and print to console clear_data ( window ) window . set_dataset ( window . get_dataset_window () . get_dataset ()) window . console_print ( f \"DataSet file created\" ) load_dataset ( window ) window . update_header () save_dataset ( window ) else : # Warn user that window was improperly closed and that no dataset_tools was created window . console_print ( \"No DataSet file was created\" ) Populate the GUI with data from the currently loaded dataset. Actions: - Adds all dataset labels to the file selection list. - Selects all items by default. - Populates the plot-type combobox with device-appropriate plotting functions. Raises IncompatibleDeviceTypeFound If the dataset\u2019s device type does not match available plot handlers. Parameters window : QMainWindow GUI instance holding a loaded dataset. Source code in gui\\utils\\dataset_tools\\load_dataset.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 @with_logging def load_dataset ( window : QtWidgets . QMainWindow ): \"\"\" Populate the GUI with data from the currently loaded dataset. Actions: - Adds all dataset labels to the file selection list. - Selects all items by default. - Populates the plot-type combobox with device-appropriate plotting functions. Raises ------ IncompatibleDeviceTypeFound If the dataset\u2019s device type does not match available plot handlers. Parameters ---------- window : QMainWindow GUI instance holding a loaded dataset. \"\"\" # Add all top level keys to the selection list of the gui for label in window . dataset . get_labels (): window . selectedFilesList . addItem ( label ) # FEATURE REQUEST: Make this a setting # Select all items by default window . selectedFilesList . selectAll () # Edit combobox to show all available plot types try : for function in window . get_plot_functions ( window . get_current_device ()): window . plotTypeCombo . addItem ( function ) except KeyError : window . console_print ( f \"Incompatible device type [ { window . get_current_device () } ] found in { window . get_dataset_name () } , select another dataset or implement the device type. DataSet path: N/A\" ) raise IncompatibleDeviceTypeFound window . console_print ( \"DataSet loaded\" ) Save the currently loaded dataset to disk using a file dialog. Behaviour: - Ensures a dataset is loaded before saving. - Opens a save-file dialog and writes the dataset via DataSetJSONDecoder . - Auto-appends a valid extension if necessary. - Updates the stored dataset location and logs status messages. Parameters window : QMainWindow GUI window containing the active dataset. Source code in gui\\utils\\dataset_tools\\save_dataset.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @with_logging def save_dataset ( window : QtWidgets . QMainWindow , * args , ** kwargs ): \"\"\" Save the currently loaded dataset to disk using a file dialog. Behaviour: - Ensures a dataset is loaded before saving. - Opens a save-file dialog and writes the dataset via `DataSetJSONDecoder`. - Auto-appends a valid extension if necessary. - Updates the stored dataset location and logs status messages. Parameters ---------- window : QMainWindow GUI window containing the active dataset. \"\"\" # Make sure there is a dataset to save if window . get_dataset_name () is None : return window . console_print ( \"Err: Must first load dataset\" , level = \"warning\" ) # Run the file dialog # TODO: There's a bug in ubuntu 24 that has the filter reinitialised when navigating the path file_name = QtWidgets . QFileDialog . getSaveFileName ( parent = window , caption = \"Save file to disk\" , filter = \"DataSets (*.json *.dataset *.ds);;All (*)\" , initialFilter = \"DataSets (*.json *.dataset *.ds)\" )[ 0 ] if file_name != \"\" : # Ensure the file name has a valid extension if file_name : if not any ( file_name . endswith ( ext ) for ext in ( '.json' , '.dataset' , '.ds' )): # Default to .dataset if no valid extension file_name += '.ds' with open ( file_name , \"w\" ) as json_file : current_dataset = window . get_dataset () json . dump ( current_dataset , json_file , cls = fs . DataSetJSONEncoder ) current_dataset . set_location ( file_name ) json_file . close () return window . console_print ( f \"Saved dataset file to { file_name } \" ) else : # File dialog was exited without choosing a file return window . console_print ( f \"No file selected\" ) Other Extract the current value from common Qt widget types. Supported widgets: - QDoubleSpinBox / QSpinBox \u2192 numeric value - QCheckBox \u2192 boolean isChecked - QLineEdit / QComboBox \u2192 text, with \"None\"/\"none\" mapped to None Raises NotImplementedError if the widget type is unsupported. Parameters widget : QWidget The widget whose value should be extracted. Returns Any The widget's value in a Python-friendly type. Source code in gui\\utils\\get_qwidget_value.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def get_qwidget_value ( widget ): \"\"\" Extract the current value from common Qt widget types. Supported widgets: - QDoubleSpinBox / QSpinBox \u2192 numeric value - QCheckBox \u2192 boolean `isChecked` - QLineEdit / QComboBox \u2192 text, with \"None\"/\"none\" mapped to `None` Raises `NotImplementedError` if the widget type is unsupported. Parameters ---------- widget : QWidget The widget whose value should be extracted. Returns ------- Any The widget's value in a Python-friendly type. \"\"\" if not isinstance ( widget , QtWidgets . QWidget ): raise ValueError ( \"Input must be a QWidget instance\" ) if isinstance ( widget , QtWidgets . QDoubleSpinBox ) or isinstance ( widget , QtWidgets . QSpinBox ): return widget . value () elif isinstance ( widget , QtWidgets . QCheckBox ): return widget . isChecked () elif isinstance ( widget , QtWidgets . QLineEdit ): return _cast_none_string_to_none_type ( widget . text ()) elif isinstance ( widget , QtWidgets . QComboBox ): return _cast_none_string_to_none_type ( widget . currentText ()) else : raise NotImplementedError ( f \"Widget type { type ( widget ) } not supported\" ) Find and return the checked QRadioButton within a dialog. Scans all child radio buttons and returns the first active one. Parameters dialog : QDialog Container widget containing radio buttons. Returns QRadioButton or None The checked radio button, or None if no selection exists. Source code in gui\\utils\\search_for_first_active_radio_button.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def search_for_first_active_radio_button ( dialog : QtWidgets . QDialog ) -> QtWidgets . QRadioButton : \"\"\" Find and return the checked QRadioButton within a dialog. Scans all child radio buttons and returns the first active one. Parameters ---------- dialog : QDialog Container widget containing radio buttons. Returns ------- QRadioButton or None The checked radio button, or `None` if no selection exists. \"\"\" for radio_button in dialog . findChildren ( QtWidgets . QRadioButton ): if radio_button . isChecked (): return radio_button return None Split a CamelCase string into its component words. Examples \"MyPlotType\" \u2192 [\"My\", \"Plot\", \"Type\"] Parameters camel_case : str Input CamelCase string. Returns list[str] List of lowercase/uppercase-correct word segments. Source code in gui\\utils\\split_camelCase.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def split_camel_case ( camel_case ) -> list [ str ]: \"\"\" Split a CamelCase string into its component words. Examples -------- \"MyPlotType\" \u2192 [\"My\", \"Plot\", \"Type\"] Parameters ---------- camel_case : str Input CamelCase string. Returns ------- list[str] List of lowercase/uppercase-correct word segments. \"\"\" return re . findall ( r '[A-Z]?[a-z]+|[A-Z]+(?=[A-Z]|$)' , camel_case ) Windows and Dialogs Bases: QMainWindow Main GUI window for interactive, automated plotting of experimental data. Responsibilities Load the main QtDesigner-generated UI file and dynamically attach device- specific option panels to the central QStackedWidget . Manage the currently loaded DataSet : Creating, loading, saving, and autosaving datasets. Displaying raw JSON content and console history in helper dialogs. Updating header fields (set name, device type) when datasets change. Integrate logging with a QTextEdit-based console for time-stamped messages. Provide a thin controller layer for: Launching the plotting pipeline via plot_manager . Handling progress updates and console appends. Adding notes and console history back into the dataset. On construction, the window: - Discovers available devices from implementations.devices . - Loads and registers per-device widgets and their plot functions. - Wires menu actions and buttons to dataset, plotting, and utility actions. - Optionally auto-opens a demo dataset if a file name is supplied. The class is intended to be the central hub of the GUI application, with device-specific logic pushed into worker classes and implementations. Source code in gui\\windows\\MainWindow.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 class UiMainWindow ( QtWidgets . QMainWindow ): \"\"\" Main GUI window for interactive, automated plotting of experimental data. Responsibilities ---------------- - Load the main QtDesigner-generated UI file and dynamically attach device- specific option panels to the central `QStackedWidget`. - Manage the currently loaded `DataSet`: * Creating, loading, saving, and autosaving datasets. * Displaying raw JSON content and console history in helper dialogs. * Updating header fields (set name, device type) when datasets change. - Integrate logging with a QTextEdit-based console for time-stamped messages. - Provide a thin controller layer for: * Launching the plotting pipeline via `plot_manager`. * Handling progress updates and console appends. * Adding notes and console history back into the dataset. On construction, the window: - Discovers available devices from `implementations.devices`. - Loads and registers per-device widgets and their plot functions. - Wires menu actions and buttons to dataset, plotting, and utility actions. - Optionally auto-opens a demo dataset if a file name is supplied. The class is intended to be the central hub of the GUI application, with device-specific logic pushed into worker classes and implementations. \"\"\" def __init__ ( self , demo_file_name : str = None ): super ( UiMainWindow , self ) . __init__ () self . thread = None self . device_worker = None self . dataset = None self . dataset_location = None # Load the UI, Note that loadUI adds objects to 'self' using objectName self . dataWindow = None uic . loadUi ( constant_paths . WINDOW_PATH , self ) # Read the config file self . config = read_config ( constant_paths . CONFIG_PATH ) # Create/Get a logger with the desired settings self . logger = logging . getLogger ( constants . LOG_NAME ) self . consoleTextEdit . setFormatter ( logging . Formatter ( \" %(asctime)s [ %(levelname)8.8s ] %(message)s \" , datefmt = f ' { constants . DATETIME_FORMAT } : ' ) ) self . logger . addHandler ( self . consoleTextEdit ) self . logger . setLevel ( self . config [ 'log_level' ]) self . plot_functions = {} self . devices = {} # Get list of devices as defined manually in the.devices __init__.py file for entry in devices . __all__ : # Find and load the widget for any given device and add it to the stackedWidget entry_ui_file = entry . lower () + \".ui\" entry_widget = uic . loadUi ( constant_paths . WIDGET_PATH + entry_ui_file ) entry_index = self . stackedWidget . addWidget ( entry_widget ) self . devices [ entry ] = entry_index # Import the corresponding module and get the class methods to set the plot_functions combobox when needed module = importlib . import_module ( f \" { devices . workers . __name__ } . { entry . lower () } \" ) entry_cls = getattr ( module , entry ) self . plot_functions [ entry ] = get_class_methods ( entry_cls , ignore = [ \"run\" ]) # Reset stacked widget to empty page self . stackedWidget . setCurrentWidget ( self . stackedWidget . widget ( 0 )) # Define menubar actions self . actionCreate_Set . triggered . connect ( partial ( create_dataset , self )) self . actionSave_Set . triggered . connect ( partial ( save_dataset , self )) self . actionLoad_Set . triggered . connect ( partial ( open_dataset_file , self )) self . actionPreferences . triggered . connect ( self . not_implemented ) self . actionQuit . triggered . connect ( self . quit ) self . actionSave_format . triggered . connect ( self . not_implemented ) self . actionColour_scheme . triggered . connect ( self . not_implemented ) self . actionLine_width . triggered . connect ( self . not_implemented ) self . actionDocumentation . triggered . connect ( self . navigate_to_docs ) self . actionAbout . triggered . connect ( self . show_about ) # Define gui button actions self . showDataBtn . clicked . connect ( self . display_data ) self . showHistoryBtn . clicked . connect ( self . display_history ) self . addNotesBtn . clicked . connect ( self . add_notes ) self . appendBtn . clicked . connect ( self . append_console_to_set ) self . clearBtn . clicked . connect ( partial ( clear_data , window = self )) self . clearAllBtn . clicked . connect ( partial ( clear_all , window = self )) self . quitBtn . clicked . connect ( self . quit ) # Define stackedWidget widget actions self . plotBtn . clicked . connect ( partial ( plot_manager , self )) # Make sure the progress bar is cleared self . progressBar . setValue ( 0 ) # Show the app self . show () self . console_print ( \"Program Started\" ) # Getters def get_plot_functions ( self , device = 'Generic' ) -> list : return self . plot_functions [ device ] def get_current_plot_function ( self ) -> str : return self . plotTypeCombo . currentText () def get_current_device ( self ) -> str : return self . dataset . get_device () def get_dataset ( self ): return self . dataset def get_dataset_name ( self ) -> str : if self . dataset is None : return None return self . dataset . get_name () def get_dataset_window ( self ) -> QtWidgets . QDialog : return self . dataWindow # Setters def set_dataset_window ( self , dataset_window : QtWidgets . QDialog ): self . dataWindow = dataset_window def set_dataset ( self , dataset : dataset_manager . dataset . DataSet ): self . dataset = dataset # FUNCTIONALITY def autosave ( self ): file_name = self . dataset . get_location () if file_name is None : return self . console_print ( \"Cannot autosave, no file location known. Open or create dataset first\" ) with open ( file_name , \"w\" ) as json_file : json . dump ( self . dataset , json_file , cls = dataset_manager . DataSetJSONDecoder ) json_file . close () return self . console_print ( f \"Saved dataset to { file_name } \" ) def display_data ( self ): # Abort if no dataset was loaded if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Pretty print the dataset in a simple dialog pretty_json = json . dumps ( self . dataset , indent = 4 , separators = ( ',' , ': ' ), cls = dataset_manager . DataSetJSONDecoder ) dialog_print ( window = self , title = f \"DataSet RAW: { self . dataset . get_name () } \" , contents = pretty_json ) return None def display_history ( self ): if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Prints only the console history to a simple dialog pretty_history = \"\" for k , v in sorted ( self . dataset . get_console () . items ()): line = f \" { v } \\n \" pretty_history += line dialog_print ( window = self , title = f \"DataSet History: { self . dataset . get_name () } \" , contents = pretty_history ) return None def add_notes ( self ): if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Add any notes to the dataset_manager with a trailing new line self . dataset . add_notes ( self . notesPlainText . toPlainText () + \" \\n \" ) self . console_print ( \"Notes added to dataset_manager\" ) self . autosave () return None def update_header ( self ): # Header should reflect opened dataset self . currSetNameLineEdit . setText ( self . dataset . get_name ()) self . currDeviceLineEdit . setText ( self . dataset . get_device ()) # Stacked widget should show the correct widget for the opened dataset new_page = self . stackedWidget . widget ( self . devices [ self . dataset . get_device ()]) self . stackedWidget . setCurrentWidget ( new_page ) def report_progress ( self , progress : int ): if not ( isinstance ( progress , int ) and 0 <= progress <= 100 ): raise ValueError ( \"Progress must be an integer between 0 and 100\" ) self . progressBar . setValue ( progress ) def on_plot_thread_finished ( self ): # Reset UI elements self . progressBar . setValue ( 0 ) # Free button and log to console self . plotBtn . setEnabled ( True ) self . console_print ( f \"(run { self . device_worker . identifier } ) finished\" ) # Drop strong references so GC can do its thing self . device_worker = None self . thread = None def save_to_file ( self , plaintext : str ): file_dialog = QtWidgets . QFileDialog . getSaveFileName ( self , \"Save File\" , \"\" , \"Text Files (*.txt);;All Files (*)\" ) if file_dialog [ 0 ]: # Check if a file was selected file_path = file_dialog [ 0 ] with open ( file_path , 'w' ) as file : file . write ( plaintext ) def console_print ( self , fstring , level = \"normal\" ): # Print a message to the gui console now = datetime . datetime . now () fstring_to_print = now . strftime ( f \" { constants . DATETIME_FORMAT } : \" ) + fstring c = ConsoleColours () self . consoleTextEdit . setTextColor ( c . get_colour ( level )) self . consoleTextEdit . append ( fstring_to_print ) self . consoleTextEdit . setTextColor ( c . get_colour ( \"normal\" )) def append_console_to_set ( self ): if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Append console contents to the dataset_manager console_text = self . consoleTextEdit . toPlainText () now = datetime . datetime . now () self . dataset . add_console ( now . strftime ( constants . DATETIME_FORMAT ), console_text ) self . console_print ( \"Added console contents to set\" ) self . autosave () return None def show_about ( self ): \"\"\" Shows a simple window with licence, authorship and build information \"\"\" # Grab the \"about\" info from about.txt with open ( constant_paths . ABOUT_PATH ) as about_file : about_contents = about_file . read () about_dialog = generate_about_dialog ( about_contents , self . centralWidget (), constant_paths . LOGO_PATH ) # Show the about dialog about_dialog . exec_ () def navigate_to_docs ( self ): \"\"\" Opens the default web browser and navigates to the documentation URL. \"\"\" import webbrowser webbrowser . open ( constant_paths . DOCS_URL ) def not_implemented ( self ): \"\"\" Shows the user a message that the current feature is planned but not yet implemented. \"\"\" self . console_print ( \"Feature not implemented\" , level = 'warning' ) # ESC now triggers a program exit def keyPressEvent ( self , event ) -> None : if event . key () == QtCore . Qt . Key . Key_Escape : self . quit () else : super ( UiMainWindow , self ) . keyPressEvent ( event ) # CHECK: Program exit is not safe @staticmethod def quit (): # Terminate the application sys . exit () navigate_to_docs () Opens the default web browser and navigates to the documentation URL. Source code in gui\\windows\\MainWindow.py 315 316 317 318 319 320 def navigate_to_docs ( self ): \"\"\" Opens the default web browser and navigates to the documentation URL. \"\"\" import webbrowser webbrowser . open ( constant_paths . DOCS_URL ) not_implemented () Shows the user a message that the current feature is planned but not yet implemented. Source code in gui\\windows\\MainWindow.py 322 323 324 325 326 def not_implemented ( self ): \"\"\" Shows the user a message that the current feature is planned but not yet implemented. \"\"\" self . console_print ( \"Feature not implemented\" , level = 'warning' ) show_about () Shows a simple window with licence, authorship and build information Source code in gui\\windows\\MainWindow.py 302 303 304 305 306 307 308 309 310 311 312 313 def show_about ( self ): \"\"\" Shows a simple window with licence, authorship and build information \"\"\" # Grab the \"about\" info from about.txt with open ( constant_paths . ABOUT_PATH ) as about_file : about_contents = about_file . read () about_dialog = generate_about_dialog ( about_contents , self . centralWidget (), constant_paths . LOGO_PATH ) # Show the about dialog about_dialog . exec_ () Bases: QDialog Dialog for interactively creating new DataSet instances. Overview This window guides the user through constructing a dataset by: - Selecting a device type from a combobox. - Adding individual files with custom labels, or - Auto-generating filepaths from a directory according to a chosen structure. - Setting the experiment name and experiment date/time. Behaviour Maintains an internal DataSet object that is updated as the user adds files or generates sets from directories. Displays the current file mapping as formatted JSON in a plain-text widget. Validates that both a name and at least one file are present before enabling the \u201cDone\u201d button. On completion ( finish ), writes name, device type, and experiment datetime into the dataset and closes with an accepted result. Parameters devices : list[str], optional List of available device names to present in the device selection combo box. Defaults to a single \"N/A\" entry when not specified. Source code in gui\\windows\\DataSetCreatorWindow.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class UiDataCreatorWindow ( QtWidgets . QDialog ): \"\"\" Dialog for interactively creating new `DataSet` instances. Overview -------- This window guides the user through constructing a dataset by: - Selecting a device type from a combobox. - Adding individual files with custom labels, or - Auto-generating filepaths from a directory according to a chosen structure. - Setting the experiment name and experiment date/time. Behaviour --------- - Maintains an internal `DataSet` object that is updated as the user adds files or generates sets from directories. - Displays the current file mapping as formatted JSON in a plain-text widget. - Validates that both a name and at least one file are present before enabling the \u201cDone\u201d button. - On completion (`finish`), writes name, device type, and experiment datetime into the dataset and closes with an accepted result. Parameters ---------- devices : list[str], optional List of available device names to present in the device selection combo box. Defaults to a single `\"N/A\"` entry when not specified. \"\"\" def __init__ ( self , devices : list [ str ] = [ \"N/A\" ]): super ( UiDataCreatorWindow , self ) . __init__ () # Load the UI, # Note that loadUI adds objects to 'self' using objectName uic . loadUi ( \"gui/windows/DataSetCreatorWindow.ui\" , self ) self . dataset = dataset_manager . DataSet ( datetime . datetime . now () . strftime ( \"%Y.%m. %d _%H.%M.%S\" )) # Add the correct devices to the experiment combo box self . dataTypeCombo . addItems ( devices ) # Set date to today by default self . dateTimeEdit . setDateTime ( datetime . datetime . now ()) # Set starting tab to manual dataset creation self . tabWidget . setCurrentIndex ( 0 ) # Define widget action self . browseFilesBtn . clicked . connect ( self . browse_files ) self . browseDirBtn . clicked . connect ( self . browse_dir ) self . addLabelBtn . clicked . connect ( self . add_file_to_set ) self . generateBtn . clicked . connect ( self . generate_set ) self . resetBtn . clicked . connect ( self . reset ) self . doneBtn . clicked . connect ( self . finish ) # Enable button when all is filled self . showSetPlainText . textChanged . connect ( self . button_state ) self . nameEdit . textChanged . connect ( self . button_state ) # Show the app self . show () def get_dataset ( self ) -> dataset_manager . dataset . DataSet : return self . dataset def browse_files ( self ): \"\"\" # Open file selection dialog to get a file path and update gui when confirmed \"\"\" file_name = QtWidgets . QFileDialog . getOpenFileName ( self , \"Open File\" ) self . browseFilesText . setPlainText ( file_name [ 0 ]) def browse_dir ( self ): \"\"\" # Open directory selection dialog to get a path and update gui when confirmed \"\"\" dir_name = QtWidgets . QFileDialog . getExistingDirectory ( self , 'Select Directory' ) self . browseDirText . setPlainText ( dir_name ) def add_file_to_set ( self ): \"\"\" # Gets the path and label and adds it to the current DataSet instance while updating GUI \"\"\" # Read name and legend label from gui file_name = self . browseFilesText . toPlainText () file_label = self . labelEdit . text () # Check for duplicate label if file_label in self . dataset . get_labels (): self . show_message ( title = \"Duplicate Label\" , message = \"\"\"This label has already been used. Choose another label and try again.\"\"\" ) else : # Add the file to the dataset and update the gui self . dataset . set_structure_type ( \"flat\" ) self . dataset . add_filepath ( file_name , file_label ) self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . browseFilesText . clear () # Empty label widget self . labelEdit . clear () def generate_set ( self ): \"\"\" Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired \"\"\" path = self . browseDirText . toPlainText () # If path is not selected, show message and return None if not path : self . show_message ( title = \"No directory selected\" , message = \"\"\"No directory was selected, please select directory and try again\"\"\" ) return None # Construct the filepaths for this dataset active_button = split_camel_case ( search_for_first_active_radio_button ( self ) . objectName ())[ 0 ] errors = self . dataset . construct_filepaths ( root_dir = path , type = active_button ) # Show the directories/files that were ignored to the user if errors != \"\" : self . show_message ( title = \"Files were ignored\" , message = errors ) # Show the files in the gui self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . dataset . set_structure_type ( active_button ) def button_state ( self ): \"\"\" Only enable closing when some data was included \"\"\" # TODO: hmmmmmmmmmmmm, should I be able to close the window if I mistakenly opened it? nameTxt = self . nameEdit . text () files = self . showSetPlainText . toPlainText () if ( files != \"\" ) and ( nameTxt != \"\" ): self . doneBtn . setEnabled ( True ) else : self . doneBtn . setEnabled ( False ) @staticmethod def show_message ( title , message ): msg = QtWidgets . QMessageBox () msg . setWindowTitle ( title ) msg . setText ( message ) x = msg . exec_ () def reset ( self ): \"\"\" Completely reset this UI by clearing all elements \"\"\" self . nameEdit . clear () self . labelEdit . clear () self . browseDirText . clear () self . browseFilesText . clear () self . showSetPlainText . clear () self . button_state () def finish ( self ): \"\"\" Add name, device type, and date and time dataset before exiting \"\"\" self . dataset . set_name ( self . nameEdit . text ()) self . dataset . set_device ( self . dataTypeCombo . currentText ()) experiment_date_time = self . dateTimeEdit . dateTime () . toPyDateTime () . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) self . dataset . set_experiment_date ( experiment_date_time ) self . done ( 1 ) add_file_to_set () Gets the path and label and adds it to the current DataSet instance while updating GUI Source code in gui\\windows\\DataSetCreatorWindow.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def add_file_to_set ( self ): \"\"\" # Gets the path and label and adds it to the current DataSet instance while updating GUI \"\"\" # Read name and legend label from gui file_name = self . browseFilesText . toPlainText () file_label = self . labelEdit . text () # Check for duplicate label if file_label in self . dataset . get_labels (): self . show_message ( title = \"Duplicate Label\" , message = \"\"\"This label has already been used. Choose another label and try again.\"\"\" ) else : # Add the file to the dataset and update the gui self . dataset . set_structure_type ( \"flat\" ) self . dataset . add_filepath ( file_name , file_label ) self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . browseFilesText . clear () # Empty label widget self . labelEdit . clear () browse_dir () Open directory selection dialog to get a path and update gui when confirmed Source code in gui\\windows\\DataSetCreatorWindow.py 82 83 84 85 86 87 def browse_dir ( self ): \"\"\" # Open directory selection dialog to get a path and update gui when confirmed \"\"\" dir_name = QtWidgets . QFileDialog . getExistingDirectory ( self , 'Select Directory' ) self . browseDirText . setPlainText ( dir_name ) browse_files () Open file selection dialog to get a file path and update gui when confirmed Source code in gui\\windows\\DataSetCreatorWindow.py 75 76 77 78 79 80 def browse_files ( self ): \"\"\" # Open file selection dialog to get a file path and update gui when confirmed \"\"\" file_name = QtWidgets . QFileDialog . getOpenFileName ( self , \"Open File\" ) self . browseFilesText . setPlainText ( file_name [ 0 ]) button_state () Only enable closing when some data was included Source code in gui\\windows\\DataSetCreatorWindow.py 148 149 150 151 152 153 154 155 156 def button_state ( self ): \"\"\" Only enable closing when some data was included \"\"\" # TODO: hmmmmmmmmmmmm, should I be able to close the window if I mistakenly opened it? nameTxt = self . nameEdit . text () files = self . showSetPlainText . toPlainText () if ( files != \"\" ) and ( nameTxt != \"\" ): self . doneBtn . setEnabled ( True ) else : self . doneBtn . setEnabled ( False ) finish () Add name, device type, and date and time dataset before exiting Source code in gui\\windows\\DataSetCreatorWindow.py 174 175 176 177 178 179 180 181 def finish ( self ): \"\"\" Add name, device type, and date and time dataset before exiting \"\"\" self . dataset . set_name ( self . nameEdit . text ()) self . dataset . set_device ( self . dataTypeCombo . currentText ()) experiment_date_time = self . dateTimeEdit . dateTime () . toPyDateTime () . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) self . dataset . set_experiment_date ( experiment_date_time ) self . done ( 1 ) generate_set () Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired Source code in gui\\windows\\DataSetCreatorWindow.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def generate_set ( self ): \"\"\" Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired \"\"\" path = self . browseDirText . toPlainText () # If path is not selected, show message and return None if not path : self . show_message ( title = \"No directory selected\" , message = \"\"\"No directory was selected, please select directory and try again\"\"\" ) return None # Construct the filepaths for this dataset active_button = split_camel_case ( search_for_first_active_radio_button ( self ) . objectName ())[ 0 ] errors = self . dataset . construct_filepaths ( root_dir = path , type = active_button ) # Show the directories/files that were ignored to the user if errors != \"\" : self . show_message ( title = \"Files were ignored\" , message = errors ) # Show the files in the gui self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . dataset . set_structure_type ( active_button ) reset () Completely reset this UI by clearing all elements Source code in gui\\windows\\DataSetCreatorWindow.py 165 166 167 168 169 170 171 172 def reset ( self ): \"\"\" Completely reset this UI by clearing all elements \"\"\" self . nameEdit . clear () self . labelEdit . clear () self . browseDirText . clear () self . browseFilesText . clear () self . showSetPlainText . clear () self . button_state () Bases: Handler , QTextEdit QTextEdit-based logging console widget for the GUI. This class bridges the logging module with a Qt text widget by: - Subclassing both logging.Handler and QTextEdit . - Emitting formatted log messages through a dedicated Qt signal ( appendTextEdit ), which is connected to the widget's append slot. - Keeping the text area read-only so it behaves like a console. Typical usage Create an instance and add it as a handler to a logging.Logger . Configure a formatter for the handler. Logged messages will appear in the GUI with the configured format. Parameters parent : QWidget Parent widget that will own this console. Source code in gui\\windows\\qtexteditconsole.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class QTextEditConsole ( logging . Handler , QtWidgets . QTextEdit ): \"\"\" QTextEdit-based logging console widget for the GUI. This class bridges the `logging` module with a Qt text widget by: - Subclassing both `logging.Handler` and `QTextEdit`. - Emitting formatted log messages through a dedicated Qt signal (`appendTextEdit`), which is connected to the widget's `append` slot. - Keeping the text area read-only so it behaves like a console. Typical usage ------------- - Create an instance and add it as a handler to a `logging.Logger`. - Configure a formatter for the handler. - Logged messages will appear in the GUI with the configured format. Parameters ---------- parent : QWidget Parent widget that will own this console. \"\"\" appendTextEdit = QtCore . pyqtSignal ( str ) def __init__ ( self , parent ): logging . Handler . __init__ ( self ) super ( QtWidgets . QTextEdit , self ) . __init__ ( parent ) self . setReadOnly ( True ) self . appendTextEdit . connect ( self . append ) def emit ( self , record ): msg = self . format ( record ) self . appendTextEdit . emit ( msg ) Display text content inside a modal dialog with optional saving. The dialog contains: - A read-only text editor showing contents . - \u201cOK\u201d to close the dialog. - \u201cSAVE\u201d to delegate saving via window.save_to_file . Parameters window : QMainWindow Parent window providing the save callback. title : str Dialog title bar text. contents : str Text content to display. Source code in gui\\windows\\dialogs\\dialog_print.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def dialog_print ( window : QtWidgets . QMainWindow , title , contents ): \"\"\" Display text content inside a modal dialog with optional saving. The dialog contains: - A read-only text editor showing `contents`. - \u201cOK\u201d to close the dialog. - \u201cSAVE\u201d to delegate saving via `window.save_to_file`. Parameters ---------- window : QMainWindow Parent window providing the save callback. title : str Dialog title bar text. contents : str Text content to display. \"\"\" # Prepare a text edit widget to host the contents history_text_edit = QtWidgets . QTextEdit ( window ) history_text_edit . setPlainText ( contents ) # Initialise the window dialog = QtWidgets . QDialog ( window ) dialog . setWindowTitle ( title ) # Set a default width and minimum height for the dialog dialog . resize ( 600 , 400 ) # Create a QVBoxLayout for the dialog layout = QtWidgets . QVBoxLayout ( dialog ) # Add the QTextEdit widget to the layout layout . addWidget ( history_text_edit ) # Create a QHBoxLayout and host buttons button_layout = QtWidgets . QHBoxLayout () ok_button = QtWidgets . QPushButton ( \"OK\" ) save_button = QtWidgets . QPushButton ( \"SAVE\" ) button_layout . addWidget ( ok_button ) button_layout . addWidget ( save_button ) # Add the button layout to the main layout layout . addLayout ( button_layout ) # Connect the \"OK\" button to close the dialog ok_button . clicked . connect ( dialog . accept ) save_button . clicked . connect ( lambda : window . save_to_file ( history_text_edit . toPlainText ()) ) # Show the dialog dialog . exec_ () Build and return an 'About' information dialog containing a logo and text. Features: - Displays an application logo loaded via QPixmap. - Shows about text with HTML formatting support. - Uses a fixed-size vertical layout. Parameters about_contents : str HTML/markdown-like text describing the application. centralwidget : QWidget Parent widget for modal behavior. logo_path : str Directory path to the logo image file. Returns QDialog Configured dialog ready to be shown. Source code in gui\\windows\\dialogs\\generate_about_dialog.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def generate_about_dialog ( about_contents , centralwidget , logo_path ): \"\"\" Build and return an 'About' information dialog containing a logo and text. Features: - Displays an application logo loaded via QPixmap. - Shows about text with HTML formatting support. - Uses a fixed-size vertical layout. Parameters ---------- about_contents : str HTML/markdown-like text describing the application. centralwidget : QWidget Parent widget for modal behavior. logo_path : str Directory path to the logo image file. Returns ------- QDialog Configured dialog ready to be shown. \"\"\" # Create a custom QDialog for the about information about_dialog = QtWidgets . QDialog ( centralwidget ) about_dialog . setWindowTitle ( \"About\" ) # Set the fixed size of the dialog about_dialog . setFixedSize ( 650 , 700 ) # Adjust the dimensions as needed # Load and set the image using QPixmap (make sure the path is correct) pixmap = QtGui . QPixmap ( logo_path + \"X_logo_x-lab_baseline_KL.png\" ) pixmap = pixmap . scaled ( 600 , 200 , QtCore . Qt . KeepAspectRatio ) image_label = QtWidgets . QLabel ( about_dialog ) image_label . setPixmap ( pixmap ) # Create a QLabel for the text (using HTML formatting) text_label = QtWidgets . QLabel ( about_dialog ) text_label . setWordWrap ( True ) text_label . setText ( about_contents ) # Create a QVBoxLayout for the dialog and add the image and text labels layout = QtWidgets . QVBoxLayout ( about_dialog ) layout . addWidget ( image_label ) layout . addWidget ( text_label ) about_dialog . setLayout ( layout ) return about_dialog","title":"GUI - Plot Manager"},{"location":"api/gui/plot_manager/#graphical-user-interface","text":"The following functions are classes are provided in the gui module. They are central in producing and managing the user interface as well as starting the worker threads responsible for producing plots from data.","title":"Graphical User Interface"},{"location":"api/gui/plot_manager/#plot-manager","text":"Orchestrate a plotting run in a background thread to keep the GUI responsive.","title":"Plot Manager"},{"location":"api/gui/plot_manager/#gui.plot_manager.plot_manager--workflow","text":"Collect the selected file labels from the main window. Build a reduced DataSet containing only the selected files, colours, device, structure type, and name. Collect plotting options from the active device widget (via alias properties) and from global GUI controls, storing them in PlotterOptions . Resolve and instantiate the appropriate device worker class from the implementations.devices.workers namespace. Configure the worker with the reduced dataset, selected plot function, and options. Move the worker to a QThread , wire up progress/finished signals, and start the thread. The function logs a concise summary of the run (including a short run identifier) to the GUI console once the worker is started.","title":"Workflow"},{"location":"api/gui/plot_manager/#gui.plot_manager.plot_manager--parameters","text":"window : QMainWindow Main application window providing access to the dataset, widgets (file selection, stacked options, checkboxes, etc.), and console API. Source code in gui\\plot_manager.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @with_logging def plot_manager ( window , * args , ** kwargs ): \"\"\" Orchestrate a plotting run in a background thread to keep the GUI responsive. Workflow -------- 1. Collect the selected file labels from the main window. 2. Build a reduced `DataSet` containing only the selected files, colours, device, structure type, and name. 3. Collect plotting options from the active device widget (via `alias` properties) and from global GUI controls, storing them in `PlotterOptions`. 4. Resolve and instantiate the appropriate device worker class from the `implementations.devices.workers` namespace. 5. Configure the worker with the reduced dataset, selected plot function, and options. 6. Move the worker to a `QThread`, wire up progress/finished signals, and start the thread. The function logs a concise summary of the run (including a short run identifier) to the GUI console once the worker is started. Parameters ---------- window : QMainWindow Main application window providing access to the dataset, widgets (file selection, stacked options, checkboxes, etc.), and console API. \"\"\" # Grab the selected files for plotting and build a reduced dataset dataset_time = datetime . datetime . now () . strftime ( constants . DATETIME_FORMAT ) experiment_time = window . dataset . get_experiment_date () . strftime ( constants . DATETIME_FORMAT ) dataset_selection = dataset_manager . DataSet ( dataset_time ) dataset_selection . set_experiment_date ( experiment_time ) for item in window . selectedFilesList . selectedItems (): lbl = item . text () structure = window . dataset . get_structure_type () dataset_selection . set_structure_type ( structure ) path = window . dataset . get_filepath ( lbl ) dataset_selection . add_filepath ( path , lbl ) colour = window . dataset . get_single_colour ( lbl ) dataset_selection . add_colour ( colour , lbl ) dataset_selection . set_device ( window . dataset . get_device ()) dataset_selection . set_structure_type ( window . dataset . get_structure_type ()) dataset_selection . set_name ( window . dataset . get_name ()) # Recursively search for QWidget children with an alias to collect options and get their values options = PlotterOptions () for option in window . stackedWidget . currentWidget () . findChildren ( QtWidgets . QWidget ): alias = option . property ( \"alias\" ) if alias is not None : option_value = get_qwidget_value ( option ) if option_value is not None : options . add_option ( label = alias , value = option_value ) options . add_option ( label = \"presentation\" , value = get_qwidget_value ( window . presentationCheckBox )) options . add_option ( label = \"legend_title\" , value = get_qwidget_value ( window . legendTitleLineEdit )) # Instantiate proper device class and set the data current_device_class = window . dataset . get_device () device_module = getattr ( implementations . devices . workers , current_device_class . lower ()) device = getattr ( device_module , current_device_class ) # # Grab the correct plotting function and pass all options to it plot_function = window . get_current_plot_function () # Create a new thread for the device class to run in window . thread = QtCore . QThread () window . device_worker = device ( current_device_class , dataset_selection , plot_function , options = options ) window . device_worker . moveToThread ( window . thread ) # Connect signals and slots for the worker thread window . thread . started . connect ( window . device_worker . run ) # When the worker says \"I'm done\", stop the thread and schedule the worker for deletion window . device_worker . finished . connect ( window . thread . quit ) window . device_worker . finished . connect ( window . device_worker . deleteLater ) # When the thread is actually finished, clean up and reset GUI window . thread . finished . connect ( window . thread . deleteLater ) window . thread . finished . connect ( window . on_plot_thread_finished ) # Progress updates window . device_worker . progress . connect ( window . report_progress ) # Start the thread window . thread . start () window . console_print ( f \"(run { window . device_worker . identifier } ) producing { current_device_class } - { plot_function } plot for { window . get_dataset_name () } with options { options } \" ) window . plotBtn . setEnabled ( False )","title":"Parameters"},{"location":"api/gui/plot_manager/#utils","text":"","title":"Utils"},{"location":"api/gui/plot_manager/#clear","text":"Fully reset the GUI state and remove all in-memory data. This helper: - Clears the active DataSet and GUI fields via clear_data . - Empties the console widget. - Writes a confirmation message to the GUI console.","title":"Clear"},{"location":"api/gui/plot_manager/#gui.utils.clear.clear_all.clear_all--parameters","text":"window : QMainWindow Main application window whose state should be cleared. Source code in gui\\utils\\clear\\clear_all.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def clear_all ( window : QtWidgets . QMainWindow ): \"\"\" Fully reset the GUI state and remove all in-memory data. This helper: - Clears the active `DataSet` and GUI fields via `clear_data`. - Empties the console widget. - Writes a confirmation message to the GUI console. Parameters ---------- window : QMainWindow Main application window whose state should be cleared. \"\"\" clear_data ( window ) window . consoleTextEdit . clear () window . console_print ( \"Cleared memory\" ) Clear the currently loaded dataset and reset all GUI widgets tied to it. Resets: - Stored DataSet object and its disk location. - Set name, device name, notes, and list widgets. - Plot type combobox and stacked widget view. A console message is printed to confirm completion.","title":"Parameters"},{"location":"api/gui/plot_manager/#gui.utils.clear.clear_data.clear_data--parameters","text":"window : QMainWindow Main GUI instance that holds dataset-related widgets. Source code in gui\\utils\\clear\\clear_data.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def clear_data ( window : QtWidgets . QMainWindow ): \"\"\" Clear the currently loaded dataset and reset all GUI widgets tied to it. Resets: - Stored `DataSet` object and its disk location. - Set name, device name, notes, and list widgets. - Plot type combobox and stacked widget view. A console message is printed to confirm completion. Parameters ---------- window : QMainWindow Main GUI instance that holds dataset-related widgets. \"\"\" window . dataset = None window . dataset_location = None window . currSetNameLineEdit . clear () window . currDeviceLineEdit . clear () window . notesPlainText . clear () window . console_print ( \"Cleared dataset from memory\" ) window . stackedWidget . setCurrentWidget ( window . stackedWidget . widget ( 0 )) window . selectedFilesList . clear () window . plotTypeCombo . clear ()","title":"Parameters"},{"location":"api/gui/plot_manager/#dataset-tools","text":"Launch the DataSet creation dialog and construct a new dataset from user input. Workflow: - Opens the DataSet creator window populated with available devices. - On confirmation: * Clears existing state. * Stores the newly created dataset. * Loads it into the GUI and updates the header. * Immediately saves it to disk. - If cancelled, informs the user that no dataset was created.","title":"DataSet Tools"},{"location":"api/gui/plot_manager/#gui.utils.dataset_tools.create_dataset.create_dataset--parameters","text":"window : QMainWindow Main application window controlling dataset creation. Source code in gui\\utils\\dataset_tools\\create_dataset.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @with_logging def create_dataset ( window : QtWidgets . QMainWindow , * args , ** kwargs ): \"\"\" Launch the DataSet creation dialog and construct a new dataset from user input. Workflow: - Opens the DataSet creator window populated with available devices. - On confirmation: * Clears existing state. * Stores the newly created dataset. * Loads it into the GUI and updates the header. * Immediately saves it to disk. - If cancelled, informs the user that no dataset was created. Parameters ---------- window : QMainWindow Main application window controlling dataset creation. \"\"\" window . set_dataset_window ( gui . windows . DataSetCreatorWindow . UiDataCreatorWindow ( devices = [ k for k in window . devices ])) window . get_dataset_window () . show () if window . dataWindow . exec () == 1 : # If the window was properly closed (Done button) then creation was successful # Copy dataset_tools and print to console clear_data ( window ) window . set_dataset ( window . get_dataset_window () . get_dataset ()) window . console_print ( f \"DataSet file created\" ) load_dataset ( window ) window . update_header () save_dataset ( window ) else : # Warn user that window was improperly closed and that no dataset_tools was created window . console_print ( \"No DataSet file was created\" ) Populate the GUI with data from the currently loaded dataset. Actions: - Adds all dataset labels to the file selection list. - Selects all items by default. - Populates the plot-type combobox with device-appropriate plotting functions.","title":"Parameters"},{"location":"api/gui/plot_manager/#gui.utils.dataset_tools.load_dataset.load_dataset--raises","text":"IncompatibleDeviceTypeFound If the dataset\u2019s device type does not match available plot handlers.","title":"Raises"},{"location":"api/gui/plot_manager/#gui.utils.dataset_tools.load_dataset.load_dataset--parameters","text":"window : QMainWindow GUI instance holding a loaded dataset. Source code in gui\\utils\\dataset_tools\\load_dataset.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 @with_logging def load_dataset ( window : QtWidgets . QMainWindow ): \"\"\" Populate the GUI with data from the currently loaded dataset. Actions: - Adds all dataset labels to the file selection list. - Selects all items by default. - Populates the plot-type combobox with device-appropriate plotting functions. Raises ------ IncompatibleDeviceTypeFound If the dataset\u2019s device type does not match available plot handlers. Parameters ---------- window : QMainWindow GUI instance holding a loaded dataset. \"\"\" # Add all top level keys to the selection list of the gui for label in window . dataset . get_labels (): window . selectedFilesList . addItem ( label ) # FEATURE REQUEST: Make this a setting # Select all items by default window . selectedFilesList . selectAll () # Edit combobox to show all available plot types try : for function in window . get_plot_functions ( window . get_current_device ()): window . plotTypeCombo . addItem ( function ) except KeyError : window . console_print ( f \"Incompatible device type [ { window . get_current_device () } ] found in { window . get_dataset_name () } , select another dataset or implement the device type. DataSet path: N/A\" ) raise IncompatibleDeviceTypeFound window . console_print ( \"DataSet loaded\" ) Save the currently loaded dataset to disk using a file dialog. Behaviour: - Ensures a dataset is loaded before saving. - Opens a save-file dialog and writes the dataset via DataSetJSONDecoder . - Auto-appends a valid extension if necessary. - Updates the stored dataset location and logs status messages.","title":"Parameters"},{"location":"api/gui/plot_manager/#gui.utils.dataset_tools.save_dataset.save_dataset--parameters","text":"window : QMainWindow GUI window containing the active dataset. Source code in gui\\utils\\dataset_tools\\save_dataset.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @with_logging def save_dataset ( window : QtWidgets . QMainWindow , * args , ** kwargs ): \"\"\" Save the currently loaded dataset to disk using a file dialog. Behaviour: - Ensures a dataset is loaded before saving. - Opens a save-file dialog and writes the dataset via `DataSetJSONDecoder`. - Auto-appends a valid extension if necessary. - Updates the stored dataset location and logs status messages. Parameters ---------- window : QMainWindow GUI window containing the active dataset. \"\"\" # Make sure there is a dataset to save if window . get_dataset_name () is None : return window . console_print ( \"Err: Must first load dataset\" , level = \"warning\" ) # Run the file dialog # TODO: There's a bug in ubuntu 24 that has the filter reinitialised when navigating the path file_name = QtWidgets . QFileDialog . getSaveFileName ( parent = window , caption = \"Save file to disk\" , filter = \"DataSets (*.json *.dataset *.ds);;All (*)\" , initialFilter = \"DataSets (*.json *.dataset *.ds)\" )[ 0 ] if file_name != \"\" : # Ensure the file name has a valid extension if file_name : if not any ( file_name . endswith ( ext ) for ext in ( '.json' , '.dataset' , '.ds' )): # Default to .dataset if no valid extension file_name += '.ds' with open ( file_name , \"w\" ) as json_file : current_dataset = window . get_dataset () json . dump ( current_dataset , json_file , cls = fs . DataSetJSONEncoder ) current_dataset . set_location ( file_name ) json_file . close () return window . console_print ( f \"Saved dataset file to { file_name } \" ) else : # File dialog was exited without choosing a file return window . console_print ( f \"No file selected\" )","title":"Parameters"},{"location":"api/gui/plot_manager/#other","text":"Extract the current value from common Qt widget types. Supported widgets: - QDoubleSpinBox / QSpinBox \u2192 numeric value - QCheckBox \u2192 boolean isChecked - QLineEdit / QComboBox \u2192 text, with \"None\"/\"none\" mapped to None Raises NotImplementedError if the widget type is unsupported.","title":"Other"},{"location":"api/gui/plot_manager/#gui.utils.get_qwidget_value.get_qwidget_value--parameters","text":"widget : QWidget The widget whose value should be extracted.","title":"Parameters"},{"location":"api/gui/plot_manager/#gui.utils.get_qwidget_value.get_qwidget_value--returns","text":"Any The widget's value in a Python-friendly type. Source code in gui\\utils\\get_qwidget_value.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def get_qwidget_value ( widget ): \"\"\" Extract the current value from common Qt widget types. Supported widgets: - QDoubleSpinBox / QSpinBox \u2192 numeric value - QCheckBox \u2192 boolean `isChecked` - QLineEdit / QComboBox \u2192 text, with \"None\"/\"none\" mapped to `None` Raises `NotImplementedError` if the widget type is unsupported. Parameters ---------- widget : QWidget The widget whose value should be extracted. Returns ------- Any The widget's value in a Python-friendly type. \"\"\" if not isinstance ( widget , QtWidgets . QWidget ): raise ValueError ( \"Input must be a QWidget instance\" ) if isinstance ( widget , QtWidgets . QDoubleSpinBox ) or isinstance ( widget , QtWidgets . QSpinBox ): return widget . value () elif isinstance ( widget , QtWidgets . QCheckBox ): return widget . isChecked () elif isinstance ( widget , QtWidgets . QLineEdit ): return _cast_none_string_to_none_type ( widget . text ()) elif isinstance ( widget , QtWidgets . QComboBox ): return _cast_none_string_to_none_type ( widget . currentText ()) else : raise NotImplementedError ( f \"Widget type { type ( widget ) } not supported\" ) Find and return the checked QRadioButton within a dialog. Scans all child radio buttons and returns the first active one.","title":"Returns"},{"location":"api/gui/plot_manager/#gui.utils.search_for_first_active_radio_button.search_for_first_active_radio_button--parameters","text":"dialog : QDialog Container widget containing radio buttons.","title":"Parameters"},{"location":"api/gui/plot_manager/#gui.utils.search_for_first_active_radio_button.search_for_first_active_radio_button--returns","text":"QRadioButton or None The checked radio button, or None if no selection exists. Source code in gui\\utils\\search_for_first_active_radio_button.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def search_for_first_active_radio_button ( dialog : QtWidgets . QDialog ) -> QtWidgets . QRadioButton : \"\"\" Find and return the checked QRadioButton within a dialog. Scans all child radio buttons and returns the first active one. Parameters ---------- dialog : QDialog Container widget containing radio buttons. Returns ------- QRadioButton or None The checked radio button, or `None` if no selection exists. \"\"\" for radio_button in dialog . findChildren ( QtWidgets . QRadioButton ): if radio_button . isChecked (): return radio_button return None Split a CamelCase string into its component words.","title":"Returns"},{"location":"api/gui/plot_manager/#gui.utils.split_camelCase.split_camel_case--examples","text":"\"MyPlotType\" \u2192 [\"My\", \"Plot\", \"Type\"]","title":"Examples"},{"location":"api/gui/plot_manager/#gui.utils.split_camelCase.split_camel_case--parameters","text":"camel_case : str Input CamelCase string.","title":"Parameters"},{"location":"api/gui/plot_manager/#gui.utils.split_camelCase.split_camel_case--returns","text":"list[str] List of lowercase/uppercase-correct word segments. Source code in gui\\utils\\split_camelCase.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def split_camel_case ( camel_case ) -> list [ str ]: \"\"\" Split a CamelCase string into its component words. Examples -------- \"MyPlotType\" \u2192 [\"My\", \"Plot\", \"Type\"] Parameters ---------- camel_case : str Input CamelCase string. Returns ------- list[str] List of lowercase/uppercase-correct word segments. \"\"\" return re . findall ( r '[A-Z]?[a-z]+|[A-Z]+(?=[A-Z]|$)' , camel_case )","title":"Returns"},{"location":"api/gui/plot_manager/#windows-and-dialogs","text":"Bases: QMainWindow Main GUI window for interactive, automated plotting of experimental data.","title":"Windows and Dialogs"},{"location":"api/gui/plot_manager/#gui.windows.MainWindow.UiMainWindow--responsibilities","text":"Load the main QtDesigner-generated UI file and dynamically attach device- specific option panels to the central QStackedWidget . Manage the currently loaded DataSet : Creating, loading, saving, and autosaving datasets. Displaying raw JSON content and console history in helper dialogs. Updating header fields (set name, device type) when datasets change. Integrate logging with a QTextEdit-based console for time-stamped messages. Provide a thin controller layer for: Launching the plotting pipeline via plot_manager . Handling progress updates and console appends. Adding notes and console history back into the dataset. On construction, the window: - Discovers available devices from implementations.devices . - Loads and registers per-device widgets and their plot functions. - Wires menu actions and buttons to dataset, plotting, and utility actions. - Optionally auto-opens a demo dataset if a file name is supplied. The class is intended to be the central hub of the GUI application, with device-specific logic pushed into worker classes and implementations. Source code in gui\\windows\\MainWindow.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 class UiMainWindow ( QtWidgets . QMainWindow ): \"\"\" Main GUI window for interactive, automated plotting of experimental data. Responsibilities ---------------- - Load the main QtDesigner-generated UI file and dynamically attach device- specific option panels to the central `QStackedWidget`. - Manage the currently loaded `DataSet`: * Creating, loading, saving, and autosaving datasets. * Displaying raw JSON content and console history in helper dialogs. * Updating header fields (set name, device type) when datasets change. - Integrate logging with a QTextEdit-based console for time-stamped messages. - Provide a thin controller layer for: * Launching the plotting pipeline via `plot_manager`. * Handling progress updates and console appends. * Adding notes and console history back into the dataset. On construction, the window: - Discovers available devices from `implementations.devices`. - Loads and registers per-device widgets and their plot functions. - Wires menu actions and buttons to dataset, plotting, and utility actions. - Optionally auto-opens a demo dataset if a file name is supplied. The class is intended to be the central hub of the GUI application, with device-specific logic pushed into worker classes and implementations. \"\"\" def __init__ ( self , demo_file_name : str = None ): super ( UiMainWindow , self ) . __init__ () self . thread = None self . device_worker = None self . dataset = None self . dataset_location = None # Load the UI, Note that loadUI adds objects to 'self' using objectName self . dataWindow = None uic . loadUi ( constant_paths . WINDOW_PATH , self ) # Read the config file self . config = read_config ( constant_paths . CONFIG_PATH ) # Create/Get a logger with the desired settings self . logger = logging . getLogger ( constants . LOG_NAME ) self . consoleTextEdit . setFormatter ( logging . Formatter ( \" %(asctime)s [ %(levelname)8.8s ] %(message)s \" , datefmt = f ' { constants . DATETIME_FORMAT } : ' ) ) self . logger . addHandler ( self . consoleTextEdit ) self . logger . setLevel ( self . config [ 'log_level' ]) self . plot_functions = {} self . devices = {} # Get list of devices as defined manually in the.devices __init__.py file for entry in devices . __all__ : # Find and load the widget for any given device and add it to the stackedWidget entry_ui_file = entry . lower () + \".ui\" entry_widget = uic . loadUi ( constant_paths . WIDGET_PATH + entry_ui_file ) entry_index = self . stackedWidget . addWidget ( entry_widget ) self . devices [ entry ] = entry_index # Import the corresponding module and get the class methods to set the plot_functions combobox when needed module = importlib . import_module ( f \" { devices . workers . __name__ } . { entry . lower () } \" ) entry_cls = getattr ( module , entry ) self . plot_functions [ entry ] = get_class_methods ( entry_cls , ignore = [ \"run\" ]) # Reset stacked widget to empty page self . stackedWidget . setCurrentWidget ( self . stackedWidget . widget ( 0 )) # Define menubar actions self . actionCreate_Set . triggered . connect ( partial ( create_dataset , self )) self . actionSave_Set . triggered . connect ( partial ( save_dataset , self )) self . actionLoad_Set . triggered . connect ( partial ( open_dataset_file , self )) self . actionPreferences . triggered . connect ( self . not_implemented ) self . actionQuit . triggered . connect ( self . quit ) self . actionSave_format . triggered . connect ( self . not_implemented ) self . actionColour_scheme . triggered . connect ( self . not_implemented ) self . actionLine_width . triggered . connect ( self . not_implemented ) self . actionDocumentation . triggered . connect ( self . navigate_to_docs ) self . actionAbout . triggered . connect ( self . show_about ) # Define gui button actions self . showDataBtn . clicked . connect ( self . display_data ) self . showHistoryBtn . clicked . connect ( self . display_history ) self . addNotesBtn . clicked . connect ( self . add_notes ) self . appendBtn . clicked . connect ( self . append_console_to_set ) self . clearBtn . clicked . connect ( partial ( clear_data , window = self )) self . clearAllBtn . clicked . connect ( partial ( clear_all , window = self )) self . quitBtn . clicked . connect ( self . quit ) # Define stackedWidget widget actions self . plotBtn . clicked . connect ( partial ( plot_manager , self )) # Make sure the progress bar is cleared self . progressBar . setValue ( 0 ) # Show the app self . show () self . console_print ( \"Program Started\" ) # Getters def get_plot_functions ( self , device = 'Generic' ) -> list : return self . plot_functions [ device ] def get_current_plot_function ( self ) -> str : return self . plotTypeCombo . currentText () def get_current_device ( self ) -> str : return self . dataset . get_device () def get_dataset ( self ): return self . dataset def get_dataset_name ( self ) -> str : if self . dataset is None : return None return self . dataset . get_name () def get_dataset_window ( self ) -> QtWidgets . QDialog : return self . dataWindow # Setters def set_dataset_window ( self , dataset_window : QtWidgets . QDialog ): self . dataWindow = dataset_window def set_dataset ( self , dataset : dataset_manager . dataset . DataSet ): self . dataset = dataset # FUNCTIONALITY def autosave ( self ): file_name = self . dataset . get_location () if file_name is None : return self . console_print ( \"Cannot autosave, no file location known. Open or create dataset first\" ) with open ( file_name , \"w\" ) as json_file : json . dump ( self . dataset , json_file , cls = dataset_manager . DataSetJSONDecoder ) json_file . close () return self . console_print ( f \"Saved dataset to { file_name } \" ) def display_data ( self ): # Abort if no dataset was loaded if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Pretty print the dataset in a simple dialog pretty_json = json . dumps ( self . dataset , indent = 4 , separators = ( ',' , ': ' ), cls = dataset_manager . DataSetJSONDecoder ) dialog_print ( window = self , title = f \"DataSet RAW: { self . dataset . get_name () } \" , contents = pretty_json ) return None def display_history ( self ): if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Prints only the console history to a simple dialog pretty_history = \"\" for k , v in sorted ( self . dataset . get_console () . items ()): line = f \" { v } \\n \" pretty_history += line dialog_print ( window = self , title = f \"DataSet History: { self . dataset . get_name () } \" , contents = pretty_history ) return None def add_notes ( self ): if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Add any notes to the dataset_manager with a trailing new line self . dataset . add_notes ( self . notesPlainText . toPlainText () + \" \\n \" ) self . console_print ( \"Notes added to dataset_manager\" ) self . autosave () return None def update_header ( self ): # Header should reflect opened dataset self . currSetNameLineEdit . setText ( self . dataset . get_name ()) self . currDeviceLineEdit . setText ( self . dataset . get_device ()) # Stacked widget should show the correct widget for the opened dataset new_page = self . stackedWidget . widget ( self . devices [ self . dataset . get_device ()]) self . stackedWidget . setCurrentWidget ( new_page ) def report_progress ( self , progress : int ): if not ( isinstance ( progress , int ) and 0 <= progress <= 100 ): raise ValueError ( \"Progress must be an integer between 0 and 100\" ) self . progressBar . setValue ( progress ) def on_plot_thread_finished ( self ): # Reset UI elements self . progressBar . setValue ( 0 ) # Free button and log to console self . plotBtn . setEnabled ( True ) self . console_print ( f \"(run { self . device_worker . identifier } ) finished\" ) # Drop strong references so GC can do its thing self . device_worker = None self . thread = None def save_to_file ( self , plaintext : str ): file_dialog = QtWidgets . QFileDialog . getSaveFileName ( self , \"Save File\" , \"\" , \"Text Files (*.txt);;All Files (*)\" ) if file_dialog [ 0 ]: # Check if a file was selected file_path = file_dialog [ 0 ] with open ( file_path , 'w' ) as file : file . write ( plaintext ) def console_print ( self , fstring , level = \"normal\" ): # Print a message to the gui console now = datetime . datetime . now () fstring_to_print = now . strftime ( f \" { constants . DATETIME_FORMAT } : \" ) + fstring c = ConsoleColours () self . consoleTextEdit . setTextColor ( c . get_colour ( level )) self . consoleTextEdit . append ( fstring_to_print ) self . consoleTextEdit . setTextColor ( c . get_colour ( \"normal\" )) def append_console_to_set ( self ): if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Append console contents to the dataset_manager console_text = self . consoleTextEdit . toPlainText () now = datetime . datetime . now () self . dataset . add_console ( now . strftime ( constants . DATETIME_FORMAT ), console_text ) self . console_print ( \"Added console contents to set\" ) self . autosave () return None def show_about ( self ): \"\"\" Shows a simple window with licence, authorship and build information \"\"\" # Grab the \"about\" info from about.txt with open ( constant_paths . ABOUT_PATH ) as about_file : about_contents = about_file . read () about_dialog = generate_about_dialog ( about_contents , self . centralWidget (), constant_paths . LOGO_PATH ) # Show the about dialog about_dialog . exec_ () def navigate_to_docs ( self ): \"\"\" Opens the default web browser and navigates to the documentation URL. \"\"\" import webbrowser webbrowser . open ( constant_paths . DOCS_URL ) def not_implemented ( self ): \"\"\" Shows the user a message that the current feature is planned but not yet implemented. \"\"\" self . console_print ( \"Feature not implemented\" , level = 'warning' ) # ESC now triggers a program exit def keyPressEvent ( self , event ) -> None : if event . key () == QtCore . Qt . Key . Key_Escape : self . quit () else : super ( UiMainWindow , self ) . keyPressEvent ( event ) # CHECK: Program exit is not safe @staticmethod def quit (): # Terminate the application sys . exit ()","title":"Responsibilities"},{"location":"api/gui/plot_manager/#gui.windows.MainWindow.UiMainWindow.navigate_to_docs","text":"Opens the default web browser and navigates to the documentation URL. Source code in gui\\windows\\MainWindow.py 315 316 317 318 319 320 def navigate_to_docs ( self ): \"\"\" Opens the default web browser and navigates to the documentation URL. \"\"\" import webbrowser webbrowser . open ( constant_paths . DOCS_URL )","title":"navigate_to_docs"},{"location":"api/gui/plot_manager/#gui.windows.MainWindow.UiMainWindow.not_implemented","text":"Shows the user a message that the current feature is planned but not yet implemented. Source code in gui\\windows\\MainWindow.py 322 323 324 325 326 def not_implemented ( self ): \"\"\" Shows the user a message that the current feature is planned but not yet implemented. \"\"\" self . console_print ( \"Feature not implemented\" , level = 'warning' )","title":"not_implemented"},{"location":"api/gui/plot_manager/#gui.windows.MainWindow.UiMainWindow.show_about","text":"Shows a simple window with licence, authorship and build information Source code in gui\\windows\\MainWindow.py 302 303 304 305 306 307 308 309 310 311 312 313 def show_about ( self ): \"\"\" Shows a simple window with licence, authorship and build information \"\"\" # Grab the \"about\" info from about.txt with open ( constant_paths . ABOUT_PATH ) as about_file : about_contents = about_file . read () about_dialog = generate_about_dialog ( about_contents , self . centralWidget (), constant_paths . LOGO_PATH ) # Show the about dialog about_dialog . exec_ () Bases: QDialog Dialog for interactively creating new DataSet instances.","title":"show_about"},{"location":"api/gui/plot_manager/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow--overview","text":"This window guides the user through constructing a dataset by: - Selecting a device type from a combobox. - Adding individual files with custom labels, or - Auto-generating filepaths from a directory according to a chosen structure. - Setting the experiment name and experiment date/time.","title":"Overview"},{"location":"api/gui/plot_manager/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow--behaviour","text":"Maintains an internal DataSet object that is updated as the user adds files or generates sets from directories. Displays the current file mapping as formatted JSON in a plain-text widget. Validates that both a name and at least one file are present before enabling the \u201cDone\u201d button. On completion ( finish ), writes name, device type, and experiment datetime into the dataset and closes with an accepted result.","title":"Behaviour"},{"location":"api/gui/plot_manager/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow--parameters","text":"devices : list[str], optional List of available device names to present in the device selection combo box. Defaults to a single \"N/A\" entry when not specified. Source code in gui\\windows\\DataSetCreatorWindow.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class UiDataCreatorWindow ( QtWidgets . QDialog ): \"\"\" Dialog for interactively creating new `DataSet` instances. Overview -------- This window guides the user through constructing a dataset by: - Selecting a device type from a combobox. - Adding individual files with custom labels, or - Auto-generating filepaths from a directory according to a chosen structure. - Setting the experiment name and experiment date/time. Behaviour --------- - Maintains an internal `DataSet` object that is updated as the user adds files or generates sets from directories. - Displays the current file mapping as formatted JSON in a plain-text widget. - Validates that both a name and at least one file are present before enabling the \u201cDone\u201d button. - On completion (`finish`), writes name, device type, and experiment datetime into the dataset and closes with an accepted result. Parameters ---------- devices : list[str], optional List of available device names to present in the device selection combo box. Defaults to a single `\"N/A\"` entry when not specified. \"\"\" def __init__ ( self , devices : list [ str ] = [ \"N/A\" ]): super ( UiDataCreatorWindow , self ) . __init__ () # Load the UI, # Note that loadUI adds objects to 'self' using objectName uic . loadUi ( \"gui/windows/DataSetCreatorWindow.ui\" , self ) self . dataset = dataset_manager . DataSet ( datetime . datetime . now () . strftime ( \"%Y.%m. %d _%H.%M.%S\" )) # Add the correct devices to the experiment combo box self . dataTypeCombo . addItems ( devices ) # Set date to today by default self . dateTimeEdit . setDateTime ( datetime . datetime . now ()) # Set starting tab to manual dataset creation self . tabWidget . setCurrentIndex ( 0 ) # Define widget action self . browseFilesBtn . clicked . connect ( self . browse_files ) self . browseDirBtn . clicked . connect ( self . browse_dir ) self . addLabelBtn . clicked . connect ( self . add_file_to_set ) self . generateBtn . clicked . connect ( self . generate_set ) self . resetBtn . clicked . connect ( self . reset ) self . doneBtn . clicked . connect ( self . finish ) # Enable button when all is filled self . showSetPlainText . textChanged . connect ( self . button_state ) self . nameEdit . textChanged . connect ( self . button_state ) # Show the app self . show () def get_dataset ( self ) -> dataset_manager . dataset . DataSet : return self . dataset def browse_files ( self ): \"\"\" # Open file selection dialog to get a file path and update gui when confirmed \"\"\" file_name = QtWidgets . QFileDialog . getOpenFileName ( self , \"Open File\" ) self . browseFilesText . setPlainText ( file_name [ 0 ]) def browse_dir ( self ): \"\"\" # Open directory selection dialog to get a path and update gui when confirmed \"\"\" dir_name = QtWidgets . QFileDialog . getExistingDirectory ( self , 'Select Directory' ) self . browseDirText . setPlainText ( dir_name ) def add_file_to_set ( self ): \"\"\" # Gets the path and label and adds it to the current DataSet instance while updating GUI \"\"\" # Read name and legend label from gui file_name = self . browseFilesText . toPlainText () file_label = self . labelEdit . text () # Check for duplicate label if file_label in self . dataset . get_labels (): self . show_message ( title = \"Duplicate Label\" , message = \"\"\"This label has already been used. Choose another label and try again.\"\"\" ) else : # Add the file to the dataset and update the gui self . dataset . set_structure_type ( \"flat\" ) self . dataset . add_filepath ( file_name , file_label ) self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . browseFilesText . clear () # Empty label widget self . labelEdit . clear () def generate_set ( self ): \"\"\" Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired \"\"\" path = self . browseDirText . toPlainText () # If path is not selected, show message and return None if not path : self . show_message ( title = \"No directory selected\" , message = \"\"\"No directory was selected, please select directory and try again\"\"\" ) return None # Construct the filepaths for this dataset active_button = split_camel_case ( search_for_first_active_radio_button ( self ) . objectName ())[ 0 ] errors = self . dataset . construct_filepaths ( root_dir = path , type = active_button ) # Show the directories/files that were ignored to the user if errors != \"\" : self . show_message ( title = \"Files were ignored\" , message = errors ) # Show the files in the gui self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . dataset . set_structure_type ( active_button ) def button_state ( self ): \"\"\" Only enable closing when some data was included \"\"\" # TODO: hmmmmmmmmmmmm, should I be able to close the window if I mistakenly opened it? nameTxt = self . nameEdit . text () files = self . showSetPlainText . toPlainText () if ( files != \"\" ) and ( nameTxt != \"\" ): self . doneBtn . setEnabled ( True ) else : self . doneBtn . setEnabled ( False ) @staticmethod def show_message ( title , message ): msg = QtWidgets . QMessageBox () msg . setWindowTitle ( title ) msg . setText ( message ) x = msg . exec_ () def reset ( self ): \"\"\" Completely reset this UI by clearing all elements \"\"\" self . nameEdit . clear () self . labelEdit . clear () self . browseDirText . clear () self . browseFilesText . clear () self . showSetPlainText . clear () self . button_state () def finish ( self ): \"\"\" Add name, device type, and date and time dataset before exiting \"\"\" self . dataset . set_name ( self . nameEdit . text ()) self . dataset . set_device ( self . dataTypeCombo . currentText ()) experiment_date_time = self . dateTimeEdit . dateTime () . toPyDateTime () . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) self . dataset . set_experiment_date ( experiment_date_time ) self . done ( 1 )","title":"Parameters"},{"location":"api/gui/plot_manager/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.add_file_to_set","text":"","title":"add_file_to_set"},{"location":"api/gui/plot_manager/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.add_file_to_set--gets-the-path-and-label-and-adds-it-to-the-current-dataset-instance-while-updating-gui","text":"Source code in gui\\windows\\DataSetCreatorWindow.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def add_file_to_set ( self ): \"\"\" # Gets the path and label and adds it to the current DataSet instance while updating GUI \"\"\" # Read name and legend label from gui file_name = self . browseFilesText . toPlainText () file_label = self . labelEdit . text () # Check for duplicate label if file_label in self . dataset . get_labels (): self . show_message ( title = \"Duplicate Label\" , message = \"\"\"This label has already been used. Choose another label and try again.\"\"\" ) else : # Add the file to the dataset and update the gui self . dataset . set_structure_type ( \"flat\" ) self . dataset . add_filepath ( file_name , file_label ) self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . browseFilesText . clear () # Empty label widget self . labelEdit . clear ()","title":"Gets the path and label and adds it to the current DataSet instance while updating GUI"},{"location":"api/gui/plot_manager/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.browse_dir","text":"","title":"browse_dir"},{"location":"api/gui/plot_manager/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.browse_dir--open-directory-selection-dialog-to-get-a-path-and-update-gui-when-confirmed","text":"Source code in gui\\windows\\DataSetCreatorWindow.py 82 83 84 85 86 87 def browse_dir ( self ): \"\"\" # Open directory selection dialog to get a path and update gui when confirmed \"\"\" dir_name = QtWidgets . QFileDialog . getExistingDirectory ( self , 'Select Directory' ) self . browseDirText . setPlainText ( dir_name )","title":"Open directory selection dialog to get a path and update gui when confirmed"},{"location":"api/gui/plot_manager/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.browse_files","text":"","title":"browse_files"},{"location":"api/gui/plot_manager/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.browse_files--open-file-selection-dialog-to-get-a-file-path-and-update-gui-when-confirmed","text":"Source code in gui\\windows\\DataSetCreatorWindow.py 75 76 77 78 79 80 def browse_files ( self ): \"\"\" # Open file selection dialog to get a file path and update gui when confirmed \"\"\" file_name = QtWidgets . QFileDialog . getOpenFileName ( self , \"Open File\" ) self . browseFilesText . setPlainText ( file_name [ 0 ])","title":"Open file selection dialog to get a file path and update gui when confirmed"},{"location":"api/gui/plot_manager/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.button_state","text":"Only enable closing when some data was included Source code in gui\\windows\\DataSetCreatorWindow.py 148 149 150 151 152 153 154 155 156 def button_state ( self ): \"\"\" Only enable closing when some data was included \"\"\" # TODO: hmmmmmmmmmmmm, should I be able to close the window if I mistakenly opened it? nameTxt = self . nameEdit . text () files = self . showSetPlainText . toPlainText () if ( files != \"\" ) and ( nameTxt != \"\" ): self . doneBtn . setEnabled ( True ) else : self . doneBtn . setEnabled ( False )","title":"button_state"},{"location":"api/gui/plot_manager/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.finish","text":"Add name, device type, and date and time dataset before exiting Source code in gui\\windows\\DataSetCreatorWindow.py 174 175 176 177 178 179 180 181 def finish ( self ): \"\"\" Add name, device type, and date and time dataset before exiting \"\"\" self . dataset . set_name ( self . nameEdit . text ()) self . dataset . set_device ( self . dataTypeCombo . currentText ()) experiment_date_time = self . dateTimeEdit . dateTime () . toPyDateTime () . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) self . dataset . set_experiment_date ( experiment_date_time ) self . done ( 1 )","title":"finish"},{"location":"api/gui/plot_manager/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.generate_set","text":"Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired Source code in gui\\windows\\DataSetCreatorWindow.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def generate_set ( self ): \"\"\" Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired \"\"\" path = self . browseDirText . toPlainText () # If path is not selected, show message and return None if not path : self . show_message ( title = \"No directory selected\" , message = \"\"\"No directory was selected, please select directory and try again\"\"\" ) return None # Construct the filepaths for this dataset active_button = split_camel_case ( search_for_first_active_radio_button ( self ) . objectName ())[ 0 ] errors = self . dataset . construct_filepaths ( root_dir = path , type = active_button ) # Show the directories/files that were ignored to the user if errors != \"\" : self . show_message ( title = \"Files were ignored\" , message = errors ) # Show the files in the gui self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . dataset . set_structure_type ( active_button )","title":"generate_set"},{"location":"api/gui/plot_manager/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.reset","text":"Completely reset this UI by clearing all elements Source code in gui\\windows\\DataSetCreatorWindow.py 165 166 167 168 169 170 171 172 def reset ( self ): \"\"\" Completely reset this UI by clearing all elements \"\"\" self . nameEdit . clear () self . labelEdit . clear () self . browseDirText . clear () self . browseFilesText . clear () self . showSetPlainText . clear () self . button_state () Bases: Handler , QTextEdit QTextEdit-based logging console widget for the GUI. This class bridges the logging module with a Qt text widget by: - Subclassing both logging.Handler and QTextEdit . - Emitting formatted log messages through a dedicated Qt signal ( appendTextEdit ), which is connected to the widget's append slot. - Keeping the text area read-only so it behaves like a console.","title":"reset"},{"location":"api/gui/plot_manager/#gui.windows.qtexteditconsole.QTextEditConsole--typical-usage","text":"Create an instance and add it as a handler to a logging.Logger . Configure a formatter for the handler. Logged messages will appear in the GUI with the configured format.","title":"Typical usage"},{"location":"api/gui/plot_manager/#gui.windows.qtexteditconsole.QTextEditConsole--parameters","text":"parent : QWidget Parent widget that will own this console. Source code in gui\\windows\\qtexteditconsole.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class QTextEditConsole ( logging . Handler , QtWidgets . QTextEdit ): \"\"\" QTextEdit-based logging console widget for the GUI. This class bridges the `logging` module with a Qt text widget by: - Subclassing both `logging.Handler` and `QTextEdit`. - Emitting formatted log messages through a dedicated Qt signal (`appendTextEdit`), which is connected to the widget's `append` slot. - Keeping the text area read-only so it behaves like a console. Typical usage ------------- - Create an instance and add it as a handler to a `logging.Logger`. - Configure a formatter for the handler. - Logged messages will appear in the GUI with the configured format. Parameters ---------- parent : QWidget Parent widget that will own this console. \"\"\" appendTextEdit = QtCore . pyqtSignal ( str ) def __init__ ( self , parent ): logging . Handler . __init__ ( self ) super ( QtWidgets . QTextEdit , self ) . __init__ ( parent ) self . setReadOnly ( True ) self . appendTextEdit . connect ( self . append ) def emit ( self , record ): msg = self . format ( record ) self . appendTextEdit . emit ( msg ) Display text content inside a modal dialog with optional saving. The dialog contains: - A read-only text editor showing contents . - \u201cOK\u201d to close the dialog. - \u201cSAVE\u201d to delegate saving via window.save_to_file .","title":"Parameters"},{"location":"api/gui/plot_manager/#gui.windows.dialogs.dialog_print.dialog_print--parameters","text":"window : QMainWindow Parent window providing the save callback. title : str Dialog title bar text. contents : str Text content to display. Source code in gui\\windows\\dialogs\\dialog_print.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def dialog_print ( window : QtWidgets . QMainWindow , title , contents ): \"\"\" Display text content inside a modal dialog with optional saving. The dialog contains: - A read-only text editor showing `contents`. - \u201cOK\u201d to close the dialog. - \u201cSAVE\u201d to delegate saving via `window.save_to_file`. Parameters ---------- window : QMainWindow Parent window providing the save callback. title : str Dialog title bar text. contents : str Text content to display. \"\"\" # Prepare a text edit widget to host the contents history_text_edit = QtWidgets . QTextEdit ( window ) history_text_edit . setPlainText ( contents ) # Initialise the window dialog = QtWidgets . QDialog ( window ) dialog . setWindowTitle ( title ) # Set a default width and minimum height for the dialog dialog . resize ( 600 , 400 ) # Create a QVBoxLayout for the dialog layout = QtWidgets . QVBoxLayout ( dialog ) # Add the QTextEdit widget to the layout layout . addWidget ( history_text_edit ) # Create a QHBoxLayout and host buttons button_layout = QtWidgets . QHBoxLayout () ok_button = QtWidgets . QPushButton ( \"OK\" ) save_button = QtWidgets . QPushButton ( \"SAVE\" ) button_layout . addWidget ( ok_button ) button_layout . addWidget ( save_button ) # Add the button layout to the main layout layout . addLayout ( button_layout ) # Connect the \"OK\" button to close the dialog ok_button . clicked . connect ( dialog . accept ) save_button . clicked . connect ( lambda : window . save_to_file ( history_text_edit . toPlainText ()) ) # Show the dialog dialog . exec_ () Build and return an 'About' information dialog containing a logo and text. Features: - Displays an application logo loaded via QPixmap. - Shows about text with HTML formatting support. - Uses a fixed-size vertical layout.","title":"Parameters"},{"location":"api/gui/plot_manager/#gui.windows.dialogs.generate_about_dialog.generate_about_dialog--parameters","text":"about_contents : str HTML/markdown-like text describing the application. centralwidget : QWidget Parent widget for modal behavior. logo_path : str Directory path to the logo image file.","title":"Parameters"},{"location":"api/gui/plot_manager/#gui.windows.dialogs.generate_about_dialog.generate_about_dialog--returns","text":"QDialog Configured dialog ready to be shown. Source code in gui\\windows\\dialogs\\generate_about_dialog.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def generate_about_dialog ( about_contents , centralwidget , logo_path ): \"\"\" Build and return an 'About' information dialog containing a logo and text. Features: - Displays an application logo loaded via QPixmap. - Shows about text with HTML formatting support. - Uses a fixed-size vertical layout. Parameters ---------- about_contents : str HTML/markdown-like text describing the application. centralwidget : QWidget Parent widget for modal behavior. logo_path : str Directory path to the logo image file. Returns ------- QDialog Configured dialog ready to be shown. \"\"\" # Create a custom QDialog for the about information about_dialog = QtWidgets . QDialog ( centralwidget ) about_dialog . setWindowTitle ( \"About\" ) # Set the fixed size of the dialog about_dialog . setFixedSize ( 650 , 700 ) # Adjust the dimensions as needed # Load and set the image using QPixmap (make sure the path is correct) pixmap = QtGui . QPixmap ( logo_path + \"X_logo_x-lab_baseline_KL.png\" ) pixmap = pixmap . scaled ( 600 , 200 , QtCore . Qt . KeepAspectRatio ) image_label = QtWidgets . QLabel ( about_dialog ) image_label . setPixmap ( pixmap ) # Create a QLabel for the text (using HTML formatting) text_label = QtWidgets . QLabel ( about_dialog ) text_label . setWordWrap ( True ) text_label . setText ( about_contents ) # Create a QVBoxLayout for the dialog and add the image and text labels layout = QtWidgets . QVBoxLayout ( about_dialog ) layout . addWidget ( image_label ) layout . addWidget ( text_label ) about_dialog . setLayout ( layout ) return about_dialog","title":"Returns"},{"location":"api/gui/utils/","text":"Utils Clear Fully reset the GUI state and remove all in-memory data. This helper: - Clears the active DataSet and GUI fields via clear_data . - Empties the console widget. - Writes a confirmation message to the GUI console. Parameters window : QMainWindow Main application window whose state should be cleared. Source code in gui\\utils\\clear\\clear_all.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def clear_all ( window : QtWidgets . QMainWindow ): \"\"\" Fully reset the GUI state and remove all in-memory data. This helper: - Clears the active `DataSet` and GUI fields via `clear_data`. - Empties the console widget. - Writes a confirmation message to the GUI console. Parameters ---------- window : QMainWindow Main application window whose state should be cleared. \"\"\" clear_data ( window ) window . consoleTextEdit . clear () window . console_print ( \"Cleared memory\" ) Clear the currently loaded dataset and reset all GUI widgets tied to it. Resets: - Stored DataSet object and its disk location. - Set name, device name, notes, and list widgets. - Plot type combobox and stacked widget view. A console message is printed to confirm completion. Parameters window : QMainWindow Main GUI instance that holds dataset-related widgets. Source code in gui\\utils\\clear\\clear_data.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def clear_data ( window : QtWidgets . QMainWindow ): \"\"\" Clear the currently loaded dataset and reset all GUI widgets tied to it. Resets: - Stored `DataSet` object and its disk location. - Set name, device name, notes, and list widgets. - Plot type combobox and stacked widget view. A console message is printed to confirm completion. Parameters ---------- window : QMainWindow Main GUI instance that holds dataset-related widgets. \"\"\" window . dataset = None window . dataset_location = None window . currSetNameLineEdit . clear () window . currDeviceLineEdit . clear () window . notesPlainText . clear () window . console_print ( \"Cleared dataset from memory\" ) window . stackedWidget . setCurrentWidget ( window . stackedWidget . widget ( 0 )) window . selectedFilesList . clear () window . plotTypeCombo . clear () DataSet Tools Launch the DataSet creation dialog and construct a new dataset from user input. Workflow: - Opens the DataSet creator window populated with available devices. - On confirmation: * Clears existing state. * Stores the newly created dataset. * Loads it into the GUI and updates the header. * Immediately saves it to disk. - If cancelled, informs the user that no dataset was created. Parameters window : QMainWindow Main application window controlling dataset creation. Source code in gui\\utils\\dataset_tools\\create_dataset.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @with_logging def create_dataset ( window : QtWidgets . QMainWindow , * args , ** kwargs ): \"\"\" Launch the DataSet creation dialog and construct a new dataset from user input. Workflow: - Opens the DataSet creator window populated with available devices. - On confirmation: * Clears existing state. * Stores the newly created dataset. * Loads it into the GUI and updates the header. * Immediately saves it to disk. - If cancelled, informs the user that no dataset was created. Parameters ---------- window : QMainWindow Main application window controlling dataset creation. \"\"\" window . set_dataset_window ( gui . windows . DataSetCreatorWindow . UiDataCreatorWindow ( devices = [ k for k in window . devices ])) window . get_dataset_window () . show () if window . dataWindow . exec () == 1 : # If the window was properly closed (Done button) then creation was successful # Copy dataset_tools and print to console clear_data ( window ) window . set_dataset ( window . get_dataset_window () . get_dataset ()) window . console_print ( f \"DataSet file created\" ) load_dataset ( window ) window . update_header () save_dataset ( window ) else : # Warn user that window was improperly closed and that no dataset_tools was created window . console_print ( \"No DataSet file was created\" ) Populate the GUI with data from the currently loaded dataset. Actions: - Adds all dataset labels to the file selection list. - Selects all items by default. - Populates the plot-type combobox with device-appropriate plotting functions. Raises IncompatibleDeviceTypeFound If the dataset\u2019s device type does not match available plot handlers. Parameters window : QMainWindow GUI instance holding a loaded dataset. Source code in gui\\utils\\dataset_tools\\load_dataset.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 @with_logging def load_dataset ( window : QtWidgets . QMainWindow ): \"\"\" Populate the GUI with data from the currently loaded dataset. Actions: - Adds all dataset labels to the file selection list. - Selects all items by default. - Populates the plot-type combobox with device-appropriate plotting functions. Raises ------ IncompatibleDeviceTypeFound If the dataset\u2019s device type does not match available plot handlers. Parameters ---------- window : QMainWindow GUI instance holding a loaded dataset. \"\"\" # Add all top level keys to the selection list of the gui for label in window . dataset . get_labels (): window . selectedFilesList . addItem ( label ) # FEATURE REQUEST: Make this a setting # Select all items by default window . selectedFilesList . selectAll () # Edit combobox to show all available plot types try : for function in window . get_plot_functions ( window . get_current_device ()): window . plotTypeCombo . addItem ( function ) except KeyError : window . console_print ( f \"Incompatible device type [ { window . get_current_device () } ] found in { window . get_dataset_name () } , select another dataset or implement the device type. DataSet path: N/A\" ) raise IncompatibleDeviceTypeFound window . console_print ( \"DataSet loaded\" ) Save the currently loaded dataset to disk using a file dialog. Behaviour: - Ensures a dataset is loaded before saving. - Opens a save-file dialog and writes the dataset via DataSetJSONDecoder . - Auto-appends a valid extension if necessary. - Updates the stored dataset location and logs status messages. Parameters window : QMainWindow GUI window containing the active dataset. Source code in gui\\utils\\dataset_tools\\save_dataset.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @with_logging def save_dataset ( window : QtWidgets . QMainWindow , * args , ** kwargs ): \"\"\" Save the currently loaded dataset to disk using a file dialog. Behaviour: - Ensures a dataset is loaded before saving. - Opens a save-file dialog and writes the dataset via `DataSetJSONDecoder`. - Auto-appends a valid extension if necessary. - Updates the stored dataset location and logs status messages. Parameters ---------- window : QMainWindow GUI window containing the active dataset. \"\"\" # Make sure there is a dataset to save if window . get_dataset_name () is None : return window . console_print ( \"Err: Must first load dataset\" , level = \"warning\" ) # Run the file dialog # TODO: There's a bug in ubuntu 24 that has the filter reinitialised when navigating the path file_name = QtWidgets . QFileDialog . getSaveFileName ( parent = window , caption = \"Save file to disk\" , filter = \"DataSets (*.json *.dataset *.ds);;All (*)\" , initialFilter = \"DataSets (*.json *.dataset *.ds)\" )[ 0 ] if file_name != \"\" : # Ensure the file name has a valid extension if file_name : if not any ( file_name . endswith ( ext ) for ext in ( '.json' , '.dataset' , '.ds' )): # Default to .dataset if no valid extension file_name += '.ds' with open ( file_name , \"w\" ) as json_file : current_dataset = window . get_dataset () json . dump ( current_dataset , json_file , cls = fs . DataSetJSONEncoder ) current_dataset . set_location ( file_name ) json_file . close () return window . console_print ( f \"Saved dataset file to { file_name } \" ) else : # File dialog was exited without choosing a file return window . console_print ( f \"No file selected\" ) Other Extract the current value from common Qt widget types. Supported widgets: - QDoubleSpinBox / QSpinBox \u2192 numeric value - QCheckBox \u2192 boolean isChecked - QLineEdit / QComboBox \u2192 text, with \"None\"/\"none\" mapped to None Raises NotImplementedError if the widget type is unsupported. Parameters widget : QWidget The widget whose value should be extracted. Returns Any The widget's value in a Python-friendly type. Source code in gui\\utils\\get_qwidget_value.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def get_qwidget_value ( widget ): \"\"\" Extract the current value from common Qt widget types. Supported widgets: - QDoubleSpinBox / QSpinBox \u2192 numeric value - QCheckBox \u2192 boolean `isChecked` - QLineEdit / QComboBox \u2192 text, with \"None\"/\"none\" mapped to `None` Raises `NotImplementedError` if the widget type is unsupported. Parameters ---------- widget : QWidget The widget whose value should be extracted. Returns ------- Any The widget's value in a Python-friendly type. \"\"\" if not isinstance ( widget , QtWidgets . QWidget ): raise ValueError ( \"Input must be a QWidget instance\" ) if isinstance ( widget , QtWidgets . QDoubleSpinBox ) or isinstance ( widget , QtWidgets . QSpinBox ): return widget . value () elif isinstance ( widget , QtWidgets . QCheckBox ): return widget . isChecked () elif isinstance ( widget , QtWidgets . QLineEdit ): return _cast_none_string_to_none_type ( widget . text ()) elif isinstance ( widget , QtWidgets . QComboBox ): return _cast_none_string_to_none_type ( widget . currentText ()) else : raise NotImplementedError ( f \"Widget type { type ( widget ) } not supported\" ) Find and return the checked QRadioButton within a dialog. Scans all child radio buttons and returns the first active one. Parameters dialog : QDialog Container widget containing radio buttons. Returns QRadioButton or None The checked radio button, or None if no selection exists. Source code in gui\\utils\\search_for_first_active_radio_button.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def search_for_first_active_radio_button ( dialog : QtWidgets . QDialog ) -> QtWidgets . QRadioButton : \"\"\" Find and return the checked QRadioButton within a dialog. Scans all child radio buttons and returns the first active one. Parameters ---------- dialog : QDialog Container widget containing radio buttons. Returns ------- QRadioButton or None The checked radio button, or `None` if no selection exists. \"\"\" for radio_button in dialog . findChildren ( QtWidgets . QRadioButton ): if radio_button . isChecked (): return radio_button return None Split a CamelCase string into its component words. Examples \"MyPlotType\" \u2192 [\"My\", \"Plot\", \"Type\"] Parameters camel_case : str Input CamelCase string. Returns list[str] List of lowercase/uppercase-correct word segments. Source code in gui\\utils\\split_camelCase.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def split_camel_case ( camel_case ) -> list [ str ]: \"\"\" Split a CamelCase string into its component words. Examples -------- \"MyPlotType\" \u2192 [\"My\", \"Plot\", \"Type\"] Parameters ---------- camel_case : str Input CamelCase string. Returns ------- list[str] List of lowercase/uppercase-correct word segments. \"\"\" return re . findall ( r '[A-Z]?[a-z]+|[A-Z]+(?=[A-Z]|$)' , camel_case )","title":"GUI - Utils"},{"location":"api/gui/utils/#utils","text":"","title":"Utils"},{"location":"api/gui/utils/#clear","text":"Fully reset the GUI state and remove all in-memory data. This helper: - Clears the active DataSet and GUI fields via clear_data . - Empties the console widget. - Writes a confirmation message to the GUI console.","title":"Clear"},{"location":"api/gui/utils/#gui.utils.clear.clear_all.clear_all--parameters","text":"window : QMainWindow Main application window whose state should be cleared. Source code in gui\\utils\\clear\\clear_all.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def clear_all ( window : QtWidgets . QMainWindow ): \"\"\" Fully reset the GUI state and remove all in-memory data. This helper: - Clears the active `DataSet` and GUI fields via `clear_data`. - Empties the console widget. - Writes a confirmation message to the GUI console. Parameters ---------- window : QMainWindow Main application window whose state should be cleared. \"\"\" clear_data ( window ) window . consoleTextEdit . clear () window . console_print ( \"Cleared memory\" ) Clear the currently loaded dataset and reset all GUI widgets tied to it. Resets: - Stored DataSet object and its disk location. - Set name, device name, notes, and list widgets. - Plot type combobox and stacked widget view. A console message is printed to confirm completion.","title":"Parameters"},{"location":"api/gui/utils/#gui.utils.clear.clear_data.clear_data--parameters","text":"window : QMainWindow Main GUI instance that holds dataset-related widgets. Source code in gui\\utils\\clear\\clear_data.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def clear_data ( window : QtWidgets . QMainWindow ): \"\"\" Clear the currently loaded dataset and reset all GUI widgets tied to it. Resets: - Stored `DataSet` object and its disk location. - Set name, device name, notes, and list widgets. - Plot type combobox and stacked widget view. A console message is printed to confirm completion. Parameters ---------- window : QMainWindow Main GUI instance that holds dataset-related widgets. \"\"\" window . dataset = None window . dataset_location = None window . currSetNameLineEdit . clear () window . currDeviceLineEdit . clear () window . notesPlainText . clear () window . console_print ( \"Cleared dataset from memory\" ) window . stackedWidget . setCurrentWidget ( window . stackedWidget . widget ( 0 )) window . selectedFilesList . clear () window . plotTypeCombo . clear ()","title":"Parameters"},{"location":"api/gui/utils/#dataset-tools","text":"Launch the DataSet creation dialog and construct a new dataset from user input. Workflow: - Opens the DataSet creator window populated with available devices. - On confirmation: * Clears existing state. * Stores the newly created dataset. * Loads it into the GUI and updates the header. * Immediately saves it to disk. - If cancelled, informs the user that no dataset was created.","title":"DataSet Tools"},{"location":"api/gui/utils/#gui.utils.dataset_tools.create_dataset.create_dataset--parameters","text":"window : QMainWindow Main application window controlling dataset creation. Source code in gui\\utils\\dataset_tools\\create_dataset.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @with_logging def create_dataset ( window : QtWidgets . QMainWindow , * args , ** kwargs ): \"\"\" Launch the DataSet creation dialog and construct a new dataset from user input. Workflow: - Opens the DataSet creator window populated with available devices. - On confirmation: * Clears existing state. * Stores the newly created dataset. * Loads it into the GUI and updates the header. * Immediately saves it to disk. - If cancelled, informs the user that no dataset was created. Parameters ---------- window : QMainWindow Main application window controlling dataset creation. \"\"\" window . set_dataset_window ( gui . windows . DataSetCreatorWindow . UiDataCreatorWindow ( devices = [ k for k in window . devices ])) window . get_dataset_window () . show () if window . dataWindow . exec () == 1 : # If the window was properly closed (Done button) then creation was successful # Copy dataset_tools and print to console clear_data ( window ) window . set_dataset ( window . get_dataset_window () . get_dataset ()) window . console_print ( f \"DataSet file created\" ) load_dataset ( window ) window . update_header () save_dataset ( window ) else : # Warn user that window was improperly closed and that no dataset_tools was created window . console_print ( \"No DataSet file was created\" ) Populate the GUI with data from the currently loaded dataset. Actions: - Adds all dataset labels to the file selection list. - Selects all items by default. - Populates the plot-type combobox with device-appropriate plotting functions.","title":"Parameters"},{"location":"api/gui/utils/#gui.utils.dataset_tools.load_dataset.load_dataset--raises","text":"IncompatibleDeviceTypeFound If the dataset\u2019s device type does not match available plot handlers.","title":"Raises"},{"location":"api/gui/utils/#gui.utils.dataset_tools.load_dataset.load_dataset--parameters","text":"window : QMainWindow GUI instance holding a loaded dataset. Source code in gui\\utils\\dataset_tools\\load_dataset.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 @with_logging def load_dataset ( window : QtWidgets . QMainWindow ): \"\"\" Populate the GUI with data from the currently loaded dataset. Actions: - Adds all dataset labels to the file selection list. - Selects all items by default. - Populates the plot-type combobox with device-appropriate plotting functions. Raises ------ IncompatibleDeviceTypeFound If the dataset\u2019s device type does not match available plot handlers. Parameters ---------- window : QMainWindow GUI instance holding a loaded dataset. \"\"\" # Add all top level keys to the selection list of the gui for label in window . dataset . get_labels (): window . selectedFilesList . addItem ( label ) # FEATURE REQUEST: Make this a setting # Select all items by default window . selectedFilesList . selectAll () # Edit combobox to show all available plot types try : for function in window . get_plot_functions ( window . get_current_device ()): window . plotTypeCombo . addItem ( function ) except KeyError : window . console_print ( f \"Incompatible device type [ { window . get_current_device () } ] found in { window . get_dataset_name () } , select another dataset or implement the device type. DataSet path: N/A\" ) raise IncompatibleDeviceTypeFound window . console_print ( \"DataSet loaded\" ) Save the currently loaded dataset to disk using a file dialog. Behaviour: - Ensures a dataset is loaded before saving. - Opens a save-file dialog and writes the dataset via DataSetJSONDecoder . - Auto-appends a valid extension if necessary. - Updates the stored dataset location and logs status messages.","title":"Parameters"},{"location":"api/gui/utils/#gui.utils.dataset_tools.save_dataset.save_dataset--parameters","text":"window : QMainWindow GUI window containing the active dataset. Source code in gui\\utils\\dataset_tools\\save_dataset.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @with_logging def save_dataset ( window : QtWidgets . QMainWindow , * args , ** kwargs ): \"\"\" Save the currently loaded dataset to disk using a file dialog. Behaviour: - Ensures a dataset is loaded before saving. - Opens a save-file dialog and writes the dataset via `DataSetJSONDecoder`. - Auto-appends a valid extension if necessary. - Updates the stored dataset location and logs status messages. Parameters ---------- window : QMainWindow GUI window containing the active dataset. \"\"\" # Make sure there is a dataset to save if window . get_dataset_name () is None : return window . console_print ( \"Err: Must first load dataset\" , level = \"warning\" ) # Run the file dialog # TODO: There's a bug in ubuntu 24 that has the filter reinitialised when navigating the path file_name = QtWidgets . QFileDialog . getSaveFileName ( parent = window , caption = \"Save file to disk\" , filter = \"DataSets (*.json *.dataset *.ds);;All (*)\" , initialFilter = \"DataSets (*.json *.dataset *.ds)\" )[ 0 ] if file_name != \"\" : # Ensure the file name has a valid extension if file_name : if not any ( file_name . endswith ( ext ) for ext in ( '.json' , '.dataset' , '.ds' )): # Default to .dataset if no valid extension file_name += '.ds' with open ( file_name , \"w\" ) as json_file : current_dataset = window . get_dataset () json . dump ( current_dataset , json_file , cls = fs . DataSetJSONEncoder ) current_dataset . set_location ( file_name ) json_file . close () return window . console_print ( f \"Saved dataset file to { file_name } \" ) else : # File dialog was exited without choosing a file return window . console_print ( f \"No file selected\" )","title":"Parameters"},{"location":"api/gui/utils/#other","text":"Extract the current value from common Qt widget types. Supported widgets: - QDoubleSpinBox / QSpinBox \u2192 numeric value - QCheckBox \u2192 boolean isChecked - QLineEdit / QComboBox \u2192 text, with \"None\"/\"none\" mapped to None Raises NotImplementedError if the widget type is unsupported.","title":"Other"},{"location":"api/gui/utils/#gui.utils.get_qwidget_value.get_qwidget_value--parameters","text":"widget : QWidget The widget whose value should be extracted.","title":"Parameters"},{"location":"api/gui/utils/#gui.utils.get_qwidget_value.get_qwidget_value--returns","text":"Any The widget's value in a Python-friendly type. Source code in gui\\utils\\get_qwidget_value.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def get_qwidget_value ( widget ): \"\"\" Extract the current value from common Qt widget types. Supported widgets: - QDoubleSpinBox / QSpinBox \u2192 numeric value - QCheckBox \u2192 boolean `isChecked` - QLineEdit / QComboBox \u2192 text, with \"None\"/\"none\" mapped to `None` Raises `NotImplementedError` if the widget type is unsupported. Parameters ---------- widget : QWidget The widget whose value should be extracted. Returns ------- Any The widget's value in a Python-friendly type. \"\"\" if not isinstance ( widget , QtWidgets . QWidget ): raise ValueError ( \"Input must be a QWidget instance\" ) if isinstance ( widget , QtWidgets . QDoubleSpinBox ) or isinstance ( widget , QtWidgets . QSpinBox ): return widget . value () elif isinstance ( widget , QtWidgets . QCheckBox ): return widget . isChecked () elif isinstance ( widget , QtWidgets . QLineEdit ): return _cast_none_string_to_none_type ( widget . text ()) elif isinstance ( widget , QtWidgets . QComboBox ): return _cast_none_string_to_none_type ( widget . currentText ()) else : raise NotImplementedError ( f \"Widget type { type ( widget ) } not supported\" ) Find and return the checked QRadioButton within a dialog. Scans all child radio buttons and returns the first active one.","title":"Returns"},{"location":"api/gui/utils/#gui.utils.search_for_first_active_radio_button.search_for_first_active_radio_button--parameters","text":"dialog : QDialog Container widget containing radio buttons.","title":"Parameters"},{"location":"api/gui/utils/#gui.utils.search_for_first_active_radio_button.search_for_first_active_radio_button--returns","text":"QRadioButton or None The checked radio button, or None if no selection exists. Source code in gui\\utils\\search_for_first_active_radio_button.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def search_for_first_active_radio_button ( dialog : QtWidgets . QDialog ) -> QtWidgets . QRadioButton : \"\"\" Find and return the checked QRadioButton within a dialog. Scans all child radio buttons and returns the first active one. Parameters ---------- dialog : QDialog Container widget containing radio buttons. Returns ------- QRadioButton or None The checked radio button, or `None` if no selection exists. \"\"\" for radio_button in dialog . findChildren ( QtWidgets . QRadioButton ): if radio_button . isChecked (): return radio_button return None Split a CamelCase string into its component words.","title":"Returns"},{"location":"api/gui/utils/#gui.utils.split_camelCase.split_camel_case--examples","text":"\"MyPlotType\" \u2192 [\"My\", \"Plot\", \"Type\"]","title":"Examples"},{"location":"api/gui/utils/#gui.utils.split_camelCase.split_camel_case--parameters","text":"camel_case : str Input CamelCase string.","title":"Parameters"},{"location":"api/gui/utils/#gui.utils.split_camelCase.split_camel_case--returns","text":"list[str] List of lowercase/uppercase-correct word segments. Source code in gui\\utils\\split_camelCase.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def split_camel_case ( camel_case ) -> list [ str ]: \"\"\" Split a CamelCase string into its component words. Examples -------- \"MyPlotType\" \u2192 [\"My\", \"Plot\", \"Type\"] Parameters ---------- camel_case : str Input CamelCase string. Returns ------- list[str] List of lowercase/uppercase-correct word segments. \"\"\" return re . findall ( r '[A-Z]?[a-z]+|[A-Z]+(?=[A-Z]|$)' , camel_case )","title":"Returns"},{"location":"api/gui/windows_and_dialogs/","text":"Windows and Dialogs Bases: QMainWindow Main GUI window for interactive, automated plotting of experimental data. Responsibilities Load the main QtDesigner-generated UI file and dynamically attach device- specific option panels to the central QStackedWidget . Manage the currently loaded DataSet : Creating, loading, saving, and autosaving datasets. Displaying raw JSON content and console history in helper dialogs. Updating header fields (set name, device type) when datasets change. Integrate logging with a QTextEdit-based console for time-stamped messages. Provide a thin controller layer for: Launching the plotting pipeline via plot_manager . Handling progress updates and console appends. Adding notes and console history back into the dataset. On construction, the window: - Discovers available devices from implementations.devices . - Loads and registers per-device widgets and their plot functions. - Wires menu actions and buttons to dataset, plotting, and utility actions. - Optionally auto-opens a demo dataset if a file name is supplied. The class is intended to be the central hub of the GUI application, with device-specific logic pushed into worker classes and implementations. Source code in gui\\windows\\MainWindow.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 class UiMainWindow ( QtWidgets . QMainWindow ): \"\"\" Main GUI window for interactive, automated plotting of experimental data. Responsibilities ---------------- - Load the main QtDesigner-generated UI file and dynamically attach device- specific option panels to the central `QStackedWidget`. - Manage the currently loaded `DataSet`: * Creating, loading, saving, and autosaving datasets. * Displaying raw JSON content and console history in helper dialogs. * Updating header fields (set name, device type) when datasets change. - Integrate logging with a QTextEdit-based console for time-stamped messages. - Provide a thin controller layer for: * Launching the plotting pipeline via `plot_manager`. * Handling progress updates and console appends. * Adding notes and console history back into the dataset. On construction, the window: - Discovers available devices from `implementations.devices`. - Loads and registers per-device widgets and their plot functions. - Wires menu actions and buttons to dataset, plotting, and utility actions. - Optionally auto-opens a demo dataset if a file name is supplied. The class is intended to be the central hub of the GUI application, with device-specific logic pushed into worker classes and implementations. \"\"\" def __init__ ( self , demo_file_name : str = None ): super ( UiMainWindow , self ) . __init__ () self . thread = None self . device_worker = None self . dataset = None self . dataset_location = None # Load the UI, Note that loadUI adds objects to 'self' using objectName self . dataWindow = None uic . loadUi ( constant_paths . WINDOW_PATH , self ) # Read the config file self . config = read_config ( constant_paths . CONFIG_PATH ) # Create/Get a logger with the desired settings self . logger = logging . getLogger ( constants . LOG_NAME ) self . consoleTextEdit . setFormatter ( logging . Formatter ( \" %(asctime)s [ %(levelname)8.8s ] %(message)s \" , datefmt = f ' { constants . DATETIME_FORMAT } : ' ) ) self . logger . addHandler ( self . consoleTextEdit ) self . logger . setLevel ( self . config [ 'log_level' ]) self . plot_functions = {} self . devices = {} # Get list of devices as defined manually in the.devices __init__.py file for entry in devices . __all__ : # Find and load the widget for any given device and add it to the stackedWidget entry_ui_file = entry . lower () + \".ui\" entry_widget = uic . loadUi ( constant_paths . WIDGET_PATH + entry_ui_file ) entry_index = self . stackedWidget . addWidget ( entry_widget ) self . devices [ entry ] = entry_index # Import the corresponding module and get the class methods to set the plot_functions combobox when needed module = importlib . import_module ( f \" { devices . workers . __name__ } . { entry . lower () } \" ) entry_cls = getattr ( module , entry ) self . plot_functions [ entry ] = get_class_methods ( entry_cls , ignore = [ \"run\" ]) # Reset stacked widget to empty page self . stackedWidget . setCurrentWidget ( self . stackedWidget . widget ( 0 )) # Define menubar actions self . actionCreate_Set . triggered . connect ( partial ( create_dataset , self )) self . actionSave_Set . triggered . connect ( partial ( save_dataset , self )) self . actionLoad_Set . triggered . connect ( partial ( open_dataset_file , self )) self . actionPreferences . triggered . connect ( self . not_implemented ) self . actionQuit . triggered . connect ( self . quit ) self . actionSave_format . triggered . connect ( self . not_implemented ) self . actionColour_scheme . triggered . connect ( self . not_implemented ) self . actionLine_width . triggered . connect ( self . not_implemented ) self . actionDocumentation . triggered . connect ( self . navigate_to_docs ) self . actionAbout . triggered . connect ( self . show_about ) # Define gui button actions self . showDataBtn . clicked . connect ( self . display_data ) self . showHistoryBtn . clicked . connect ( self . display_history ) self . addNotesBtn . clicked . connect ( self . add_notes ) self . appendBtn . clicked . connect ( self . append_console_to_set ) self . clearBtn . clicked . connect ( partial ( clear_data , window = self )) self . clearAllBtn . clicked . connect ( partial ( clear_all , window = self )) self . quitBtn . clicked . connect ( self . quit ) # Define stackedWidget widget actions self . plotBtn . clicked . connect ( partial ( plot_manager , self )) # Make sure the progress bar is cleared self . progressBar . setValue ( 0 ) # Show the app self . show () self . console_print ( \"Program Started\" ) # Getters def get_plot_functions ( self , device = 'Generic' ) -> list : return self . plot_functions [ device ] def get_current_plot_function ( self ) -> str : return self . plotTypeCombo . currentText () def get_current_device ( self ) -> str : return self . dataset . get_device () def get_dataset ( self ): return self . dataset def get_dataset_name ( self ) -> str : if self . dataset is None : return None return self . dataset . get_name () def get_dataset_window ( self ) -> QtWidgets . QDialog : return self . dataWindow # Setters def set_dataset_window ( self , dataset_window : QtWidgets . QDialog ): self . dataWindow = dataset_window def set_dataset ( self , dataset : dataset_manager . dataset . DataSet ): self . dataset = dataset # FUNCTIONALITY def autosave ( self ): file_name = self . dataset . get_location () if file_name is None : return self . console_print ( \"Cannot autosave, no file location known. Open or create dataset first\" ) with open ( file_name , \"w\" ) as json_file : json . dump ( self . dataset , json_file , cls = dataset_manager . DataSetJSONDecoder ) json_file . close () return self . console_print ( f \"Saved dataset to { file_name } \" ) def display_data ( self ): # Abort if no dataset was loaded if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Pretty print the dataset in a simple dialog pretty_json = json . dumps ( self . dataset , indent = 4 , separators = ( ',' , ': ' ), cls = dataset_manager . DataSetJSONDecoder ) dialog_print ( window = self , title = f \"DataSet RAW: { self . dataset . get_name () } \" , contents = pretty_json ) return None def display_history ( self ): if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Prints only the console history to a simple dialog pretty_history = \"\" for k , v in sorted ( self . dataset . get_console () . items ()): line = f \" { v } \\n \" pretty_history += line dialog_print ( window = self , title = f \"DataSet History: { self . dataset . get_name () } \" , contents = pretty_history ) return None def add_notes ( self ): if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Add any notes to the dataset_manager with a trailing new line self . dataset . add_notes ( self . notesPlainText . toPlainText () + \" \\n \" ) self . console_print ( \"Notes added to dataset_manager\" ) self . autosave () return None def update_header ( self ): # Header should reflect opened dataset self . currSetNameLineEdit . setText ( self . dataset . get_name ()) self . currDeviceLineEdit . setText ( self . dataset . get_device ()) # Stacked widget should show the correct widget for the opened dataset new_page = self . stackedWidget . widget ( self . devices [ self . dataset . get_device ()]) self . stackedWidget . setCurrentWidget ( new_page ) def report_progress ( self , progress : int ): if not ( isinstance ( progress , int ) and 0 <= progress <= 100 ): raise ValueError ( \"Progress must be an integer between 0 and 100\" ) self . progressBar . setValue ( progress ) def on_plot_thread_finished ( self ): # Reset UI elements self . progressBar . setValue ( 0 ) # Free button and log to console self . plotBtn . setEnabled ( True ) self . console_print ( f \"(run { self . device_worker . identifier } ) finished\" ) # Drop strong references so GC can do its thing self . device_worker = None self . thread = None def save_to_file ( self , plaintext : str ): file_dialog = QtWidgets . QFileDialog . getSaveFileName ( self , \"Save File\" , \"\" , \"Text Files (*.txt);;All Files (*)\" ) if file_dialog [ 0 ]: # Check if a file was selected file_path = file_dialog [ 0 ] with open ( file_path , 'w' ) as file : file . write ( plaintext ) def console_print ( self , fstring , level = \"normal\" ): # Print a message to the gui console now = datetime . datetime . now () fstring_to_print = now . strftime ( f \" { constants . DATETIME_FORMAT } : \" ) + fstring c = ConsoleColours () self . consoleTextEdit . setTextColor ( c . get_colour ( level )) self . consoleTextEdit . append ( fstring_to_print ) self . consoleTextEdit . setTextColor ( c . get_colour ( \"normal\" )) def append_console_to_set ( self ): if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Append console contents to the dataset_manager console_text = self . consoleTextEdit . toPlainText () now = datetime . datetime . now () self . dataset . add_console ( now . strftime ( constants . DATETIME_FORMAT ), console_text ) self . console_print ( \"Added console contents to set\" ) self . autosave () return None def show_about ( self ): \"\"\" Shows a simple window with licence, authorship and build information \"\"\" # Grab the \"about\" info from about.txt with open ( constant_paths . ABOUT_PATH ) as about_file : about_contents = about_file . read () about_dialog = generate_about_dialog ( about_contents , self . centralWidget (), constant_paths . LOGO_PATH ) # Show the about dialog about_dialog . exec_ () def navigate_to_docs ( self ): \"\"\" Opens the default web browser and navigates to the documentation URL. \"\"\" import webbrowser webbrowser . open ( constant_paths . DOCS_URL ) def not_implemented ( self ): \"\"\" Shows the user a message that the current feature is planned but not yet implemented. \"\"\" self . console_print ( \"Feature not implemented\" , level = 'warning' ) # ESC now triggers a program exit def keyPressEvent ( self , event ) -> None : if event . key () == QtCore . Qt . Key . Key_Escape : self . quit () else : super ( UiMainWindow , self ) . keyPressEvent ( event ) # CHECK: Program exit is not safe @staticmethod def quit (): # Terminate the application sys . exit () navigate_to_docs () Opens the default web browser and navigates to the documentation URL. Source code in gui\\windows\\MainWindow.py 315 316 317 318 319 320 def navigate_to_docs ( self ): \"\"\" Opens the default web browser and navigates to the documentation URL. \"\"\" import webbrowser webbrowser . open ( constant_paths . DOCS_URL ) not_implemented () Shows the user a message that the current feature is planned but not yet implemented. Source code in gui\\windows\\MainWindow.py 322 323 324 325 326 def not_implemented ( self ): \"\"\" Shows the user a message that the current feature is planned but not yet implemented. \"\"\" self . console_print ( \"Feature not implemented\" , level = 'warning' ) show_about () Shows a simple window with licence, authorship and build information Source code in gui\\windows\\MainWindow.py 302 303 304 305 306 307 308 309 310 311 312 313 def show_about ( self ): \"\"\" Shows a simple window with licence, authorship and build information \"\"\" # Grab the \"about\" info from about.txt with open ( constant_paths . ABOUT_PATH ) as about_file : about_contents = about_file . read () about_dialog = generate_about_dialog ( about_contents , self . centralWidget (), constant_paths . LOGO_PATH ) # Show the about dialog about_dialog . exec_ () Bases: QDialog Dialog for interactively creating new DataSet instances. Overview This window guides the user through constructing a dataset by: - Selecting a device type from a combobox. - Adding individual files with custom labels, or - Auto-generating filepaths from a directory according to a chosen structure. - Setting the experiment name and experiment date/time. Behaviour Maintains an internal DataSet object that is updated as the user adds files or generates sets from directories. Displays the current file mapping as formatted JSON in a plain-text widget. Validates that both a name and at least one file are present before enabling the \u201cDone\u201d button. On completion ( finish ), writes name, device type, and experiment datetime into the dataset and closes with an accepted result. Parameters devices : list[str], optional List of available device names to present in the device selection combo box. Defaults to a single \"N/A\" entry when not specified. Source code in gui\\windows\\DataSetCreatorWindow.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class UiDataCreatorWindow ( QtWidgets . QDialog ): \"\"\" Dialog for interactively creating new `DataSet` instances. Overview -------- This window guides the user through constructing a dataset by: - Selecting a device type from a combobox. - Adding individual files with custom labels, or - Auto-generating filepaths from a directory according to a chosen structure. - Setting the experiment name and experiment date/time. Behaviour --------- - Maintains an internal `DataSet` object that is updated as the user adds files or generates sets from directories. - Displays the current file mapping as formatted JSON in a plain-text widget. - Validates that both a name and at least one file are present before enabling the \u201cDone\u201d button. - On completion (`finish`), writes name, device type, and experiment datetime into the dataset and closes with an accepted result. Parameters ---------- devices : list[str], optional List of available device names to present in the device selection combo box. Defaults to a single `\"N/A\"` entry when not specified. \"\"\" def __init__ ( self , devices : list [ str ] = [ \"N/A\" ]): super ( UiDataCreatorWindow , self ) . __init__ () # Load the UI, # Note that loadUI adds objects to 'self' using objectName uic . loadUi ( \"gui/windows/DataSetCreatorWindow.ui\" , self ) self . dataset = dataset_manager . DataSet ( datetime . datetime . now () . strftime ( \"%Y.%m. %d _%H.%M.%S\" )) # Add the correct devices to the experiment combo box self . dataTypeCombo . addItems ( devices ) # Set date to today by default self . dateTimeEdit . setDateTime ( datetime . datetime . now ()) # Set starting tab to manual dataset creation self . tabWidget . setCurrentIndex ( 0 ) # Define widget action self . browseFilesBtn . clicked . connect ( self . browse_files ) self . browseDirBtn . clicked . connect ( self . browse_dir ) self . addLabelBtn . clicked . connect ( self . add_file_to_set ) self . generateBtn . clicked . connect ( self . generate_set ) self . resetBtn . clicked . connect ( self . reset ) self . doneBtn . clicked . connect ( self . finish ) # Enable button when all is filled self . showSetPlainText . textChanged . connect ( self . button_state ) self . nameEdit . textChanged . connect ( self . button_state ) # Show the app self . show () def get_dataset ( self ) -> dataset_manager . dataset . DataSet : return self . dataset def browse_files ( self ): \"\"\" # Open file selection dialog to get a file path and update gui when confirmed \"\"\" file_name = QtWidgets . QFileDialog . getOpenFileName ( self , \"Open File\" ) self . browseFilesText . setPlainText ( file_name [ 0 ]) def browse_dir ( self ): \"\"\" # Open directory selection dialog to get a path and update gui when confirmed \"\"\" dir_name = QtWidgets . QFileDialog . getExistingDirectory ( self , 'Select Directory' ) self . browseDirText . setPlainText ( dir_name ) def add_file_to_set ( self ): \"\"\" # Gets the path and label and adds it to the current DataSet instance while updating GUI \"\"\" # Read name and legend label from gui file_name = self . browseFilesText . toPlainText () file_label = self . labelEdit . text () # Check for duplicate label if file_label in self . dataset . get_labels (): self . show_message ( title = \"Duplicate Label\" , message = \"\"\"This label has already been used. Choose another label and try again.\"\"\" ) else : # Add the file to the dataset and update the gui self . dataset . set_structure_type ( \"flat\" ) self . dataset . add_filepath ( file_name , file_label ) self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . browseFilesText . clear () # Empty label widget self . labelEdit . clear () def generate_set ( self ): \"\"\" Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired \"\"\" path = self . browseDirText . toPlainText () # If path is not selected, show message and return None if not path : self . show_message ( title = \"No directory selected\" , message = \"\"\"No directory was selected, please select directory and try again\"\"\" ) return None # Construct the filepaths for this dataset active_button = split_camel_case ( search_for_first_active_radio_button ( self ) . objectName ())[ 0 ] errors = self . dataset . construct_filepaths ( root_dir = path , type = active_button ) # Show the directories/files that were ignored to the user if errors != \"\" : self . show_message ( title = \"Files were ignored\" , message = errors ) # Show the files in the gui self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . dataset . set_structure_type ( active_button ) def button_state ( self ): \"\"\" Only enable closing when some data was included \"\"\" # TODO: hmmmmmmmmmmmm, should I be able to close the window if I mistakenly opened it? nameTxt = self . nameEdit . text () files = self . showSetPlainText . toPlainText () if ( files != \"\" ) and ( nameTxt != \"\" ): self . doneBtn . setEnabled ( True ) else : self . doneBtn . setEnabled ( False ) @staticmethod def show_message ( title , message ): msg = QtWidgets . QMessageBox () msg . setWindowTitle ( title ) msg . setText ( message ) x = msg . exec_ () def reset ( self ): \"\"\" Completely reset this UI by clearing all elements \"\"\" self . nameEdit . clear () self . labelEdit . clear () self . browseDirText . clear () self . browseFilesText . clear () self . showSetPlainText . clear () self . button_state () def finish ( self ): \"\"\" Add name, device type, and date and time dataset before exiting \"\"\" self . dataset . set_name ( self . nameEdit . text ()) self . dataset . set_device ( self . dataTypeCombo . currentText ()) experiment_date_time = self . dateTimeEdit . dateTime () . toPyDateTime () . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) self . dataset . set_experiment_date ( experiment_date_time ) self . done ( 1 ) add_file_to_set () Gets the path and label and adds it to the current DataSet instance while updating GUI Source code in gui\\windows\\DataSetCreatorWindow.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def add_file_to_set ( self ): \"\"\" # Gets the path and label and adds it to the current DataSet instance while updating GUI \"\"\" # Read name and legend label from gui file_name = self . browseFilesText . toPlainText () file_label = self . labelEdit . text () # Check for duplicate label if file_label in self . dataset . get_labels (): self . show_message ( title = \"Duplicate Label\" , message = \"\"\"This label has already been used. Choose another label and try again.\"\"\" ) else : # Add the file to the dataset and update the gui self . dataset . set_structure_type ( \"flat\" ) self . dataset . add_filepath ( file_name , file_label ) self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . browseFilesText . clear () # Empty label widget self . labelEdit . clear () browse_dir () Open directory selection dialog to get a path and update gui when confirmed Source code in gui\\windows\\DataSetCreatorWindow.py 82 83 84 85 86 87 def browse_dir ( self ): \"\"\" # Open directory selection dialog to get a path and update gui when confirmed \"\"\" dir_name = QtWidgets . QFileDialog . getExistingDirectory ( self , 'Select Directory' ) self . browseDirText . setPlainText ( dir_name ) browse_files () Open file selection dialog to get a file path and update gui when confirmed Source code in gui\\windows\\DataSetCreatorWindow.py 75 76 77 78 79 80 def browse_files ( self ): \"\"\" # Open file selection dialog to get a file path and update gui when confirmed \"\"\" file_name = QtWidgets . QFileDialog . getOpenFileName ( self , \"Open File\" ) self . browseFilesText . setPlainText ( file_name [ 0 ]) button_state () Only enable closing when some data was included Source code in gui\\windows\\DataSetCreatorWindow.py 148 149 150 151 152 153 154 155 156 def button_state ( self ): \"\"\" Only enable closing when some data was included \"\"\" # TODO: hmmmmmmmmmmmm, should I be able to close the window if I mistakenly opened it? nameTxt = self . nameEdit . text () files = self . showSetPlainText . toPlainText () if ( files != \"\" ) and ( nameTxt != \"\" ): self . doneBtn . setEnabled ( True ) else : self . doneBtn . setEnabled ( False ) finish () Add name, device type, and date and time dataset before exiting Source code in gui\\windows\\DataSetCreatorWindow.py 174 175 176 177 178 179 180 181 def finish ( self ): \"\"\" Add name, device type, and date and time dataset before exiting \"\"\" self . dataset . set_name ( self . nameEdit . text ()) self . dataset . set_device ( self . dataTypeCombo . currentText ()) experiment_date_time = self . dateTimeEdit . dateTime () . toPyDateTime () . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) self . dataset . set_experiment_date ( experiment_date_time ) self . done ( 1 ) generate_set () Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired Source code in gui\\windows\\DataSetCreatorWindow.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def generate_set ( self ): \"\"\" Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired \"\"\" path = self . browseDirText . toPlainText () # If path is not selected, show message and return None if not path : self . show_message ( title = \"No directory selected\" , message = \"\"\"No directory was selected, please select directory and try again\"\"\" ) return None # Construct the filepaths for this dataset active_button = split_camel_case ( search_for_first_active_radio_button ( self ) . objectName ())[ 0 ] errors = self . dataset . construct_filepaths ( root_dir = path , type = active_button ) # Show the directories/files that were ignored to the user if errors != \"\" : self . show_message ( title = \"Files were ignored\" , message = errors ) # Show the files in the gui self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . dataset . set_structure_type ( active_button ) reset () Completely reset this UI by clearing all elements Source code in gui\\windows\\DataSetCreatorWindow.py 165 166 167 168 169 170 171 172 def reset ( self ): \"\"\" Completely reset this UI by clearing all elements \"\"\" self . nameEdit . clear () self . labelEdit . clear () self . browseDirText . clear () self . browseFilesText . clear () self . showSetPlainText . clear () self . button_state () Bases: Handler , QTextEdit QTextEdit-based logging console widget for the GUI. This class bridges the logging module with a Qt text widget by: - Subclassing both logging.Handler and QTextEdit . - Emitting formatted log messages through a dedicated Qt signal ( appendTextEdit ), which is connected to the widget's append slot. - Keeping the text area read-only so it behaves like a console. Typical usage Create an instance and add it as a handler to a logging.Logger . Configure a formatter for the handler. Logged messages will appear in the GUI with the configured format. Parameters parent : QWidget Parent widget that will own this console. Source code in gui\\windows\\qtexteditconsole.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class QTextEditConsole ( logging . Handler , QtWidgets . QTextEdit ): \"\"\" QTextEdit-based logging console widget for the GUI. This class bridges the `logging` module with a Qt text widget by: - Subclassing both `logging.Handler` and `QTextEdit`. - Emitting formatted log messages through a dedicated Qt signal (`appendTextEdit`), which is connected to the widget's `append` slot. - Keeping the text area read-only so it behaves like a console. Typical usage ------------- - Create an instance and add it as a handler to a `logging.Logger`. - Configure a formatter for the handler. - Logged messages will appear in the GUI with the configured format. Parameters ---------- parent : QWidget Parent widget that will own this console. \"\"\" appendTextEdit = QtCore . pyqtSignal ( str ) def __init__ ( self , parent ): logging . Handler . __init__ ( self ) super ( QtWidgets . QTextEdit , self ) . __init__ ( parent ) self . setReadOnly ( True ) self . appendTextEdit . connect ( self . append ) def emit ( self , record ): msg = self . format ( record ) self . appendTextEdit . emit ( msg ) Display text content inside a modal dialog with optional saving. The dialog contains: - A read-only text editor showing contents . - \u201cOK\u201d to close the dialog. - \u201cSAVE\u201d to delegate saving via window.save_to_file . Parameters window : QMainWindow Parent window providing the save callback. title : str Dialog title bar text. contents : str Text content to display. Source code in gui\\windows\\dialogs\\dialog_print.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def dialog_print ( window : QtWidgets . QMainWindow , title , contents ): \"\"\" Display text content inside a modal dialog with optional saving. The dialog contains: - A read-only text editor showing `contents`. - \u201cOK\u201d to close the dialog. - \u201cSAVE\u201d to delegate saving via `window.save_to_file`. Parameters ---------- window : QMainWindow Parent window providing the save callback. title : str Dialog title bar text. contents : str Text content to display. \"\"\" # Prepare a text edit widget to host the contents history_text_edit = QtWidgets . QTextEdit ( window ) history_text_edit . setPlainText ( contents ) # Initialise the window dialog = QtWidgets . QDialog ( window ) dialog . setWindowTitle ( title ) # Set a default width and minimum height for the dialog dialog . resize ( 600 , 400 ) # Create a QVBoxLayout for the dialog layout = QtWidgets . QVBoxLayout ( dialog ) # Add the QTextEdit widget to the layout layout . addWidget ( history_text_edit ) # Create a QHBoxLayout and host buttons button_layout = QtWidgets . QHBoxLayout () ok_button = QtWidgets . QPushButton ( \"OK\" ) save_button = QtWidgets . QPushButton ( \"SAVE\" ) button_layout . addWidget ( ok_button ) button_layout . addWidget ( save_button ) # Add the button layout to the main layout layout . addLayout ( button_layout ) # Connect the \"OK\" button to close the dialog ok_button . clicked . connect ( dialog . accept ) save_button . clicked . connect ( lambda : window . save_to_file ( history_text_edit . toPlainText ()) ) # Show the dialog dialog . exec_ () Build and return an 'About' information dialog containing a logo and text. Features: - Displays an application logo loaded via QPixmap. - Shows about text with HTML formatting support. - Uses a fixed-size vertical layout. Parameters about_contents : str HTML/markdown-like text describing the application. centralwidget : QWidget Parent widget for modal behavior. logo_path : str Directory path to the logo image file. Returns QDialog Configured dialog ready to be shown. Source code in gui\\windows\\dialogs\\generate_about_dialog.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def generate_about_dialog ( about_contents , centralwidget , logo_path ): \"\"\" Build and return an 'About' information dialog containing a logo and text. Features: - Displays an application logo loaded via QPixmap. - Shows about text with HTML formatting support. - Uses a fixed-size vertical layout. Parameters ---------- about_contents : str HTML/markdown-like text describing the application. centralwidget : QWidget Parent widget for modal behavior. logo_path : str Directory path to the logo image file. Returns ------- QDialog Configured dialog ready to be shown. \"\"\" # Create a custom QDialog for the about information about_dialog = QtWidgets . QDialog ( centralwidget ) about_dialog . setWindowTitle ( \"About\" ) # Set the fixed size of the dialog about_dialog . setFixedSize ( 650 , 700 ) # Adjust the dimensions as needed # Load and set the image using QPixmap (make sure the path is correct) pixmap = QtGui . QPixmap ( logo_path + \"X_logo_x-lab_baseline_KL.png\" ) pixmap = pixmap . scaled ( 600 , 200 , QtCore . Qt . KeepAspectRatio ) image_label = QtWidgets . QLabel ( about_dialog ) image_label . setPixmap ( pixmap ) # Create a QLabel for the text (using HTML formatting) text_label = QtWidgets . QLabel ( about_dialog ) text_label . setWordWrap ( True ) text_label . setText ( about_contents ) # Create a QVBoxLayout for the dialog and add the image and text labels layout = QtWidgets . QVBoxLayout ( about_dialog ) layout . addWidget ( image_label ) layout . addWidget ( text_label ) about_dialog . setLayout ( layout ) return about_dialog","title":"GUI - Windows"},{"location":"api/gui/windows_and_dialogs/#windows-and-dialogs","text":"Bases: QMainWindow Main GUI window for interactive, automated plotting of experimental data.","title":"Windows and Dialogs"},{"location":"api/gui/windows_and_dialogs/#gui.windows.MainWindow.UiMainWindow--responsibilities","text":"Load the main QtDesigner-generated UI file and dynamically attach device- specific option panels to the central QStackedWidget . Manage the currently loaded DataSet : Creating, loading, saving, and autosaving datasets. Displaying raw JSON content and console history in helper dialogs. Updating header fields (set name, device type) when datasets change. Integrate logging with a QTextEdit-based console for time-stamped messages. Provide a thin controller layer for: Launching the plotting pipeline via plot_manager . Handling progress updates and console appends. Adding notes and console history back into the dataset. On construction, the window: - Discovers available devices from implementations.devices . - Loads and registers per-device widgets and their plot functions. - Wires menu actions and buttons to dataset, plotting, and utility actions. - Optionally auto-opens a demo dataset if a file name is supplied. The class is intended to be the central hub of the GUI application, with device-specific logic pushed into worker classes and implementations. Source code in gui\\windows\\MainWindow.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 class UiMainWindow ( QtWidgets . QMainWindow ): \"\"\" Main GUI window for interactive, automated plotting of experimental data. Responsibilities ---------------- - Load the main QtDesigner-generated UI file and dynamically attach device- specific option panels to the central `QStackedWidget`. - Manage the currently loaded `DataSet`: * Creating, loading, saving, and autosaving datasets. * Displaying raw JSON content and console history in helper dialogs. * Updating header fields (set name, device type) when datasets change. - Integrate logging with a QTextEdit-based console for time-stamped messages. - Provide a thin controller layer for: * Launching the plotting pipeline via `plot_manager`. * Handling progress updates and console appends. * Adding notes and console history back into the dataset. On construction, the window: - Discovers available devices from `implementations.devices`. - Loads and registers per-device widgets and their plot functions. - Wires menu actions and buttons to dataset, plotting, and utility actions. - Optionally auto-opens a demo dataset if a file name is supplied. The class is intended to be the central hub of the GUI application, with device-specific logic pushed into worker classes and implementations. \"\"\" def __init__ ( self , demo_file_name : str = None ): super ( UiMainWindow , self ) . __init__ () self . thread = None self . device_worker = None self . dataset = None self . dataset_location = None # Load the UI, Note that loadUI adds objects to 'self' using objectName self . dataWindow = None uic . loadUi ( constant_paths . WINDOW_PATH , self ) # Read the config file self . config = read_config ( constant_paths . CONFIG_PATH ) # Create/Get a logger with the desired settings self . logger = logging . getLogger ( constants . LOG_NAME ) self . consoleTextEdit . setFormatter ( logging . Formatter ( \" %(asctime)s [ %(levelname)8.8s ] %(message)s \" , datefmt = f ' { constants . DATETIME_FORMAT } : ' ) ) self . logger . addHandler ( self . consoleTextEdit ) self . logger . setLevel ( self . config [ 'log_level' ]) self . plot_functions = {} self . devices = {} # Get list of devices as defined manually in the.devices __init__.py file for entry in devices . __all__ : # Find and load the widget for any given device and add it to the stackedWidget entry_ui_file = entry . lower () + \".ui\" entry_widget = uic . loadUi ( constant_paths . WIDGET_PATH + entry_ui_file ) entry_index = self . stackedWidget . addWidget ( entry_widget ) self . devices [ entry ] = entry_index # Import the corresponding module and get the class methods to set the plot_functions combobox when needed module = importlib . import_module ( f \" { devices . workers . __name__ } . { entry . lower () } \" ) entry_cls = getattr ( module , entry ) self . plot_functions [ entry ] = get_class_methods ( entry_cls , ignore = [ \"run\" ]) # Reset stacked widget to empty page self . stackedWidget . setCurrentWidget ( self . stackedWidget . widget ( 0 )) # Define menubar actions self . actionCreate_Set . triggered . connect ( partial ( create_dataset , self )) self . actionSave_Set . triggered . connect ( partial ( save_dataset , self )) self . actionLoad_Set . triggered . connect ( partial ( open_dataset_file , self )) self . actionPreferences . triggered . connect ( self . not_implemented ) self . actionQuit . triggered . connect ( self . quit ) self . actionSave_format . triggered . connect ( self . not_implemented ) self . actionColour_scheme . triggered . connect ( self . not_implemented ) self . actionLine_width . triggered . connect ( self . not_implemented ) self . actionDocumentation . triggered . connect ( self . navigate_to_docs ) self . actionAbout . triggered . connect ( self . show_about ) # Define gui button actions self . showDataBtn . clicked . connect ( self . display_data ) self . showHistoryBtn . clicked . connect ( self . display_history ) self . addNotesBtn . clicked . connect ( self . add_notes ) self . appendBtn . clicked . connect ( self . append_console_to_set ) self . clearBtn . clicked . connect ( partial ( clear_data , window = self )) self . clearAllBtn . clicked . connect ( partial ( clear_all , window = self )) self . quitBtn . clicked . connect ( self . quit ) # Define stackedWidget widget actions self . plotBtn . clicked . connect ( partial ( plot_manager , self )) # Make sure the progress bar is cleared self . progressBar . setValue ( 0 ) # Show the app self . show () self . console_print ( \"Program Started\" ) # Getters def get_plot_functions ( self , device = 'Generic' ) -> list : return self . plot_functions [ device ] def get_current_plot_function ( self ) -> str : return self . plotTypeCombo . currentText () def get_current_device ( self ) -> str : return self . dataset . get_device () def get_dataset ( self ): return self . dataset def get_dataset_name ( self ) -> str : if self . dataset is None : return None return self . dataset . get_name () def get_dataset_window ( self ) -> QtWidgets . QDialog : return self . dataWindow # Setters def set_dataset_window ( self , dataset_window : QtWidgets . QDialog ): self . dataWindow = dataset_window def set_dataset ( self , dataset : dataset_manager . dataset . DataSet ): self . dataset = dataset # FUNCTIONALITY def autosave ( self ): file_name = self . dataset . get_location () if file_name is None : return self . console_print ( \"Cannot autosave, no file location known. Open or create dataset first\" ) with open ( file_name , \"w\" ) as json_file : json . dump ( self . dataset , json_file , cls = dataset_manager . DataSetJSONDecoder ) json_file . close () return self . console_print ( f \"Saved dataset to { file_name } \" ) def display_data ( self ): # Abort if no dataset was loaded if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Pretty print the dataset in a simple dialog pretty_json = json . dumps ( self . dataset , indent = 4 , separators = ( ',' , ': ' ), cls = dataset_manager . DataSetJSONDecoder ) dialog_print ( window = self , title = f \"DataSet RAW: { self . dataset . get_name () } \" , contents = pretty_json ) return None def display_history ( self ): if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Prints only the console history to a simple dialog pretty_history = \"\" for k , v in sorted ( self . dataset . get_console () . items ()): line = f \" { v } \\n \" pretty_history += line dialog_print ( window = self , title = f \"DataSet History: { self . dataset . get_name () } \" , contents = pretty_history ) return None def add_notes ( self ): if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Add any notes to the dataset_manager with a trailing new line self . dataset . add_notes ( self . notesPlainText . toPlainText () + \" \\n \" ) self . console_print ( \"Notes added to dataset_manager\" ) self . autosave () return None def update_header ( self ): # Header should reflect opened dataset self . currSetNameLineEdit . setText ( self . dataset . get_name ()) self . currDeviceLineEdit . setText ( self . dataset . get_device ()) # Stacked widget should show the correct widget for the opened dataset new_page = self . stackedWidget . widget ( self . devices [ self . dataset . get_device ()]) self . stackedWidget . setCurrentWidget ( new_page ) def report_progress ( self , progress : int ): if not ( isinstance ( progress , int ) and 0 <= progress <= 100 ): raise ValueError ( \"Progress must be an integer between 0 and 100\" ) self . progressBar . setValue ( progress ) def on_plot_thread_finished ( self ): # Reset UI elements self . progressBar . setValue ( 0 ) # Free button and log to console self . plotBtn . setEnabled ( True ) self . console_print ( f \"(run { self . device_worker . identifier } ) finished\" ) # Drop strong references so GC can do its thing self . device_worker = None self . thread = None def save_to_file ( self , plaintext : str ): file_dialog = QtWidgets . QFileDialog . getSaveFileName ( self , \"Save File\" , \"\" , \"Text Files (*.txt);;All Files (*)\" ) if file_dialog [ 0 ]: # Check if a file was selected file_path = file_dialog [ 0 ] with open ( file_path , 'w' ) as file : file . write ( plaintext ) def console_print ( self , fstring , level = \"normal\" ): # Print a message to the gui console now = datetime . datetime . now () fstring_to_print = now . strftime ( f \" { constants . DATETIME_FORMAT } : \" ) + fstring c = ConsoleColours () self . consoleTextEdit . setTextColor ( c . get_colour ( level )) self . consoleTextEdit . append ( fstring_to_print ) self . consoleTextEdit . setTextColor ( c . get_colour ( \"normal\" )) def append_console_to_set ( self ): if self . dataset is None : return self . console_print ( \"Err: Must first load DataSet\" , level = \"warning\" ) # Append console contents to the dataset_manager console_text = self . consoleTextEdit . toPlainText () now = datetime . datetime . now () self . dataset . add_console ( now . strftime ( constants . DATETIME_FORMAT ), console_text ) self . console_print ( \"Added console contents to set\" ) self . autosave () return None def show_about ( self ): \"\"\" Shows a simple window with licence, authorship and build information \"\"\" # Grab the \"about\" info from about.txt with open ( constant_paths . ABOUT_PATH ) as about_file : about_contents = about_file . read () about_dialog = generate_about_dialog ( about_contents , self . centralWidget (), constant_paths . LOGO_PATH ) # Show the about dialog about_dialog . exec_ () def navigate_to_docs ( self ): \"\"\" Opens the default web browser and navigates to the documentation URL. \"\"\" import webbrowser webbrowser . open ( constant_paths . DOCS_URL ) def not_implemented ( self ): \"\"\" Shows the user a message that the current feature is planned but not yet implemented. \"\"\" self . console_print ( \"Feature not implemented\" , level = 'warning' ) # ESC now triggers a program exit def keyPressEvent ( self , event ) -> None : if event . key () == QtCore . Qt . Key . Key_Escape : self . quit () else : super ( UiMainWindow , self ) . keyPressEvent ( event ) # CHECK: Program exit is not safe @staticmethod def quit (): # Terminate the application sys . exit ()","title":"Responsibilities"},{"location":"api/gui/windows_and_dialogs/#gui.windows.MainWindow.UiMainWindow.navigate_to_docs","text":"Opens the default web browser and navigates to the documentation URL. Source code in gui\\windows\\MainWindow.py 315 316 317 318 319 320 def navigate_to_docs ( self ): \"\"\" Opens the default web browser and navigates to the documentation URL. \"\"\" import webbrowser webbrowser . open ( constant_paths . DOCS_URL )","title":"navigate_to_docs"},{"location":"api/gui/windows_and_dialogs/#gui.windows.MainWindow.UiMainWindow.not_implemented","text":"Shows the user a message that the current feature is planned but not yet implemented. Source code in gui\\windows\\MainWindow.py 322 323 324 325 326 def not_implemented ( self ): \"\"\" Shows the user a message that the current feature is planned but not yet implemented. \"\"\" self . console_print ( \"Feature not implemented\" , level = 'warning' )","title":"not_implemented"},{"location":"api/gui/windows_and_dialogs/#gui.windows.MainWindow.UiMainWindow.show_about","text":"Shows a simple window with licence, authorship and build information Source code in gui\\windows\\MainWindow.py 302 303 304 305 306 307 308 309 310 311 312 313 def show_about ( self ): \"\"\" Shows a simple window with licence, authorship and build information \"\"\" # Grab the \"about\" info from about.txt with open ( constant_paths . ABOUT_PATH ) as about_file : about_contents = about_file . read () about_dialog = generate_about_dialog ( about_contents , self . centralWidget (), constant_paths . LOGO_PATH ) # Show the about dialog about_dialog . exec_ () Bases: QDialog Dialog for interactively creating new DataSet instances.","title":"show_about"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow--overview","text":"This window guides the user through constructing a dataset by: - Selecting a device type from a combobox. - Adding individual files with custom labels, or - Auto-generating filepaths from a directory according to a chosen structure. - Setting the experiment name and experiment date/time.","title":"Overview"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow--behaviour","text":"Maintains an internal DataSet object that is updated as the user adds files or generates sets from directories. Displays the current file mapping as formatted JSON in a plain-text widget. Validates that both a name and at least one file are present before enabling the \u201cDone\u201d button. On completion ( finish ), writes name, device type, and experiment datetime into the dataset and closes with an accepted result.","title":"Behaviour"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow--parameters","text":"devices : list[str], optional List of available device names to present in the device selection combo box. Defaults to a single \"N/A\" entry when not specified. Source code in gui\\windows\\DataSetCreatorWindow.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class UiDataCreatorWindow ( QtWidgets . QDialog ): \"\"\" Dialog for interactively creating new `DataSet` instances. Overview -------- This window guides the user through constructing a dataset by: - Selecting a device type from a combobox. - Adding individual files with custom labels, or - Auto-generating filepaths from a directory according to a chosen structure. - Setting the experiment name and experiment date/time. Behaviour --------- - Maintains an internal `DataSet` object that is updated as the user adds files or generates sets from directories. - Displays the current file mapping as formatted JSON in a plain-text widget. - Validates that both a name and at least one file are present before enabling the \u201cDone\u201d button. - On completion (`finish`), writes name, device type, and experiment datetime into the dataset and closes with an accepted result. Parameters ---------- devices : list[str], optional List of available device names to present in the device selection combo box. Defaults to a single `\"N/A\"` entry when not specified. \"\"\" def __init__ ( self , devices : list [ str ] = [ \"N/A\" ]): super ( UiDataCreatorWindow , self ) . __init__ () # Load the UI, # Note that loadUI adds objects to 'self' using objectName uic . loadUi ( \"gui/windows/DataSetCreatorWindow.ui\" , self ) self . dataset = dataset_manager . DataSet ( datetime . datetime . now () . strftime ( \"%Y.%m. %d _%H.%M.%S\" )) # Add the correct devices to the experiment combo box self . dataTypeCombo . addItems ( devices ) # Set date to today by default self . dateTimeEdit . setDateTime ( datetime . datetime . now ()) # Set starting tab to manual dataset creation self . tabWidget . setCurrentIndex ( 0 ) # Define widget action self . browseFilesBtn . clicked . connect ( self . browse_files ) self . browseDirBtn . clicked . connect ( self . browse_dir ) self . addLabelBtn . clicked . connect ( self . add_file_to_set ) self . generateBtn . clicked . connect ( self . generate_set ) self . resetBtn . clicked . connect ( self . reset ) self . doneBtn . clicked . connect ( self . finish ) # Enable button when all is filled self . showSetPlainText . textChanged . connect ( self . button_state ) self . nameEdit . textChanged . connect ( self . button_state ) # Show the app self . show () def get_dataset ( self ) -> dataset_manager . dataset . DataSet : return self . dataset def browse_files ( self ): \"\"\" # Open file selection dialog to get a file path and update gui when confirmed \"\"\" file_name = QtWidgets . QFileDialog . getOpenFileName ( self , \"Open File\" ) self . browseFilesText . setPlainText ( file_name [ 0 ]) def browse_dir ( self ): \"\"\" # Open directory selection dialog to get a path and update gui when confirmed \"\"\" dir_name = QtWidgets . QFileDialog . getExistingDirectory ( self , 'Select Directory' ) self . browseDirText . setPlainText ( dir_name ) def add_file_to_set ( self ): \"\"\" # Gets the path and label and adds it to the current DataSet instance while updating GUI \"\"\" # Read name and legend label from gui file_name = self . browseFilesText . toPlainText () file_label = self . labelEdit . text () # Check for duplicate label if file_label in self . dataset . get_labels (): self . show_message ( title = \"Duplicate Label\" , message = \"\"\"This label has already been used. Choose another label and try again.\"\"\" ) else : # Add the file to the dataset and update the gui self . dataset . set_structure_type ( \"flat\" ) self . dataset . add_filepath ( file_name , file_label ) self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . browseFilesText . clear () # Empty label widget self . labelEdit . clear () def generate_set ( self ): \"\"\" Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired \"\"\" path = self . browseDirText . toPlainText () # If path is not selected, show message and return None if not path : self . show_message ( title = \"No directory selected\" , message = \"\"\"No directory was selected, please select directory and try again\"\"\" ) return None # Construct the filepaths for this dataset active_button = split_camel_case ( search_for_first_active_radio_button ( self ) . objectName ())[ 0 ] errors = self . dataset . construct_filepaths ( root_dir = path , type = active_button ) # Show the directories/files that were ignored to the user if errors != \"\" : self . show_message ( title = \"Files were ignored\" , message = errors ) # Show the files in the gui self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . dataset . set_structure_type ( active_button ) def button_state ( self ): \"\"\" Only enable closing when some data was included \"\"\" # TODO: hmmmmmmmmmmmm, should I be able to close the window if I mistakenly opened it? nameTxt = self . nameEdit . text () files = self . showSetPlainText . toPlainText () if ( files != \"\" ) and ( nameTxt != \"\" ): self . doneBtn . setEnabled ( True ) else : self . doneBtn . setEnabled ( False ) @staticmethod def show_message ( title , message ): msg = QtWidgets . QMessageBox () msg . setWindowTitle ( title ) msg . setText ( message ) x = msg . exec_ () def reset ( self ): \"\"\" Completely reset this UI by clearing all elements \"\"\" self . nameEdit . clear () self . labelEdit . clear () self . browseDirText . clear () self . browseFilesText . clear () self . showSetPlainText . clear () self . button_state () def finish ( self ): \"\"\" Add name, device type, and date and time dataset before exiting \"\"\" self . dataset . set_name ( self . nameEdit . text ()) self . dataset . set_device ( self . dataTypeCombo . currentText ()) experiment_date_time = self . dateTimeEdit . dateTime () . toPyDateTime () . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) self . dataset . set_experiment_date ( experiment_date_time ) self . done ( 1 )","title":"Parameters"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.add_file_to_set","text":"","title":"add_file_to_set"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.add_file_to_set--gets-the-path-and-label-and-adds-it-to-the-current-dataset-instance-while-updating-gui","text":"Source code in gui\\windows\\DataSetCreatorWindow.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def add_file_to_set ( self ): \"\"\" # Gets the path and label and adds it to the current DataSet instance while updating GUI \"\"\" # Read name and legend label from gui file_name = self . browseFilesText . toPlainText () file_label = self . labelEdit . text () # Check for duplicate label if file_label in self . dataset . get_labels (): self . show_message ( title = \"Duplicate Label\" , message = \"\"\"This label has already been used. Choose another label and try again.\"\"\" ) else : # Add the file to the dataset and update the gui self . dataset . set_structure_type ( \"flat\" ) self . dataset . add_filepath ( file_name , file_label ) self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . browseFilesText . clear () # Empty label widget self . labelEdit . clear ()","title":"Gets the path and label and adds it to the current DataSet instance while updating GUI"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.browse_dir","text":"","title":"browse_dir"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.browse_dir--open-directory-selection-dialog-to-get-a-path-and-update-gui-when-confirmed","text":"Source code in gui\\windows\\DataSetCreatorWindow.py 82 83 84 85 86 87 def browse_dir ( self ): \"\"\" # Open directory selection dialog to get a path and update gui when confirmed \"\"\" dir_name = QtWidgets . QFileDialog . getExistingDirectory ( self , 'Select Directory' ) self . browseDirText . setPlainText ( dir_name )","title":"Open directory selection dialog to get a path and update gui when confirmed"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.browse_files","text":"","title":"browse_files"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.browse_files--open-file-selection-dialog-to-get-a-file-path-and-update-gui-when-confirmed","text":"Source code in gui\\windows\\DataSetCreatorWindow.py 75 76 77 78 79 80 def browse_files ( self ): \"\"\" # Open file selection dialog to get a file path and update gui when confirmed \"\"\" file_name = QtWidgets . QFileDialog . getOpenFileName ( self , \"Open File\" ) self . browseFilesText . setPlainText ( file_name [ 0 ])","title":"Open file selection dialog to get a file path and update gui when confirmed"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.button_state","text":"Only enable closing when some data was included Source code in gui\\windows\\DataSetCreatorWindow.py 148 149 150 151 152 153 154 155 156 def button_state ( self ): \"\"\" Only enable closing when some data was included \"\"\" # TODO: hmmmmmmmmmmmm, should I be able to close the window if I mistakenly opened it? nameTxt = self . nameEdit . text () files = self . showSetPlainText . toPlainText () if ( files != \"\" ) and ( nameTxt != \"\" ): self . doneBtn . setEnabled ( True ) else : self . doneBtn . setEnabled ( False )","title":"button_state"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.finish","text":"Add name, device type, and date and time dataset before exiting Source code in gui\\windows\\DataSetCreatorWindow.py 174 175 176 177 178 179 180 181 def finish ( self ): \"\"\" Add name, device type, and date and time dataset before exiting \"\"\" self . dataset . set_name ( self . nameEdit . text ()) self . dataset . set_device ( self . dataTypeCombo . currentText ()) experiment_date_time = self . dateTimeEdit . dateTime () . toPyDateTime () . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) self . dataset . set_experiment_date ( experiment_date_time ) self . done ( 1 )","title":"finish"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.generate_set","text":"Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired Source code in gui\\windows\\DataSetCreatorWindow.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def generate_set ( self ): \"\"\" Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired \"\"\" path = self . browseDirText . toPlainText () # If path is not selected, show message and return None if not path : self . show_message ( title = \"No directory selected\" , message = \"\"\"No directory was selected, please select directory and try again\"\"\" ) return None # Construct the filepaths for this dataset active_button = split_camel_case ( search_for_first_active_radio_button ( self ) . objectName ())[ 0 ] errors = self . dataset . construct_filepaths ( root_dir = path , type = active_button ) # Show the directories/files that were ignored to the user if errors != \"\" : self . show_message ( title = \"Files were ignored\" , message = errors ) # Show the files in the gui self . showSetPlainText . setPlainText ( json . dumps ( self . dataset . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . dataset . set_structure_type ( active_button )","title":"generate_set"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSetCreatorWindow.UiDataCreatorWindow.reset","text":"Completely reset this UI by clearing all elements Source code in gui\\windows\\DataSetCreatorWindow.py 165 166 167 168 169 170 171 172 def reset ( self ): \"\"\" Completely reset this UI by clearing all elements \"\"\" self . nameEdit . clear () self . labelEdit . clear () self . browseDirText . clear () self . browseFilesText . clear () self . showSetPlainText . clear () self . button_state () Bases: Handler , QTextEdit QTextEdit-based logging console widget for the GUI. This class bridges the logging module with a Qt text widget by: - Subclassing both logging.Handler and QTextEdit . - Emitting formatted log messages through a dedicated Qt signal ( appendTextEdit ), which is connected to the widget's append slot. - Keeping the text area read-only so it behaves like a console.","title":"reset"},{"location":"api/gui/windows_and_dialogs/#gui.windows.qtexteditconsole.QTextEditConsole--typical-usage","text":"Create an instance and add it as a handler to a logging.Logger . Configure a formatter for the handler. Logged messages will appear in the GUI with the configured format.","title":"Typical usage"},{"location":"api/gui/windows_and_dialogs/#gui.windows.qtexteditconsole.QTextEditConsole--parameters","text":"parent : QWidget Parent widget that will own this console. Source code in gui\\windows\\qtexteditconsole.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class QTextEditConsole ( logging . Handler , QtWidgets . QTextEdit ): \"\"\" QTextEdit-based logging console widget for the GUI. This class bridges the `logging` module with a Qt text widget by: - Subclassing both `logging.Handler` and `QTextEdit`. - Emitting formatted log messages through a dedicated Qt signal (`appendTextEdit`), which is connected to the widget's `append` slot. - Keeping the text area read-only so it behaves like a console. Typical usage ------------- - Create an instance and add it as a handler to a `logging.Logger`. - Configure a formatter for the handler. - Logged messages will appear in the GUI with the configured format. Parameters ---------- parent : QWidget Parent widget that will own this console. \"\"\" appendTextEdit = QtCore . pyqtSignal ( str ) def __init__ ( self , parent ): logging . Handler . __init__ ( self ) super ( QtWidgets . QTextEdit , self ) . __init__ ( parent ) self . setReadOnly ( True ) self . appendTextEdit . connect ( self . append ) def emit ( self , record ): msg = self . format ( record ) self . appendTextEdit . emit ( msg ) Display text content inside a modal dialog with optional saving. The dialog contains: - A read-only text editor showing contents . - \u201cOK\u201d to close the dialog. - \u201cSAVE\u201d to delegate saving via window.save_to_file .","title":"Parameters"},{"location":"api/gui/windows_and_dialogs/#gui.windows.dialogs.dialog_print.dialog_print--parameters","text":"window : QMainWindow Parent window providing the save callback. title : str Dialog title bar text. contents : str Text content to display. Source code in gui\\windows\\dialogs\\dialog_print.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def dialog_print ( window : QtWidgets . QMainWindow , title , contents ): \"\"\" Display text content inside a modal dialog with optional saving. The dialog contains: - A read-only text editor showing `contents`. - \u201cOK\u201d to close the dialog. - \u201cSAVE\u201d to delegate saving via `window.save_to_file`. Parameters ---------- window : QMainWindow Parent window providing the save callback. title : str Dialog title bar text. contents : str Text content to display. \"\"\" # Prepare a text edit widget to host the contents history_text_edit = QtWidgets . QTextEdit ( window ) history_text_edit . setPlainText ( contents ) # Initialise the window dialog = QtWidgets . QDialog ( window ) dialog . setWindowTitle ( title ) # Set a default width and minimum height for the dialog dialog . resize ( 600 , 400 ) # Create a QVBoxLayout for the dialog layout = QtWidgets . QVBoxLayout ( dialog ) # Add the QTextEdit widget to the layout layout . addWidget ( history_text_edit ) # Create a QHBoxLayout and host buttons button_layout = QtWidgets . QHBoxLayout () ok_button = QtWidgets . QPushButton ( \"OK\" ) save_button = QtWidgets . QPushButton ( \"SAVE\" ) button_layout . addWidget ( ok_button ) button_layout . addWidget ( save_button ) # Add the button layout to the main layout layout . addLayout ( button_layout ) # Connect the \"OK\" button to close the dialog ok_button . clicked . connect ( dialog . accept ) save_button . clicked . connect ( lambda : window . save_to_file ( history_text_edit . toPlainText ()) ) # Show the dialog dialog . exec_ () Build and return an 'About' information dialog containing a logo and text. Features: - Displays an application logo loaded via QPixmap. - Shows about text with HTML formatting support. - Uses a fixed-size vertical layout.","title":"Parameters"},{"location":"api/gui/windows_and_dialogs/#gui.windows.dialogs.generate_about_dialog.generate_about_dialog--parameters","text":"about_contents : str HTML/markdown-like text describing the application. centralwidget : QWidget Parent widget for modal behavior. logo_path : str Directory path to the logo image file.","title":"Parameters"},{"location":"api/gui/windows_and_dialogs/#gui.windows.dialogs.generate_about_dialog.generate_about_dialog--returns","text":"QDialog Configured dialog ready to be shown. Source code in gui\\windows\\dialogs\\generate_about_dialog.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def generate_about_dialog ( about_contents , centralwidget , logo_path ): \"\"\" Build and return an 'About' information dialog containing a logo and text. Features: - Displays an application logo loaded via QPixmap. - Shows about text with HTML formatting support. - Uses a fixed-size vertical layout. Parameters ---------- about_contents : str HTML/markdown-like text describing the application. centralwidget : QWidget Parent widget for modal behavior. logo_path : str Directory path to the logo image file. Returns ------- QDialog Configured dialog ready to be shown. \"\"\" # Create a custom QDialog for the about information about_dialog = QtWidgets . QDialog ( centralwidget ) about_dialog . setWindowTitle ( \"About\" ) # Set the fixed size of the dialog about_dialog . setFixedSize ( 650 , 700 ) # Adjust the dimensions as needed # Load and set the image using QPixmap (make sure the path is correct) pixmap = QtGui . QPixmap ( logo_path + \"X_logo_x-lab_baseline_KL.png\" ) pixmap = pixmap . scaled ( 600 , 200 , QtCore . Qt . KeepAspectRatio ) image_label = QtWidgets . QLabel ( about_dialog ) image_label . setPixmap ( pixmap ) # Create a QLabel for the text (using HTML formatting) text_label = QtWidgets . QLabel ( about_dialog ) text_label . setWordWrap ( True ) text_label . setText ( about_contents ) # Create a QVBoxLayout for the dialog and add the image and text labels layout = QtWidgets . QVBoxLayout ( about_dialog ) layout . addWidget ( image_label ) layout . addWidget ( text_label ) about_dialog . setLayout ( layout ) return about_dialog","title":"Returns"},{"location":"api/utils/class_utils/","text":"Class Utils Scan a package for class_utils definitions without importing all modules at once. Returns a dict mapping class_utils name to (module_name, class_name). Source code in utils\\class_utils\\build_class_index.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def build_class_index ( package_name : str ): \"\"\" Scan a package for class_utils definitions without importing all modules at once. Returns a dict mapping class_utils name to (module_name, class_name). \"\"\" index = {} package = importlib . import_module ( package_name ) for _ , module_name , _ in pkgutil . walk_packages ( package . __path__ , package . __name__ + \".\" ): module = importlib . import_module ( module_name ) # minimal import to inspect for name , obj in inspect . getmembers ( module , inspect . isclass ): if obj . __module__ == module . __name__ : index [ name ] = ( module_name , name ) return index Given a class_utils index (from build_class_index) and a class_utils name, import and return the class_utils object. Source code in utils\\class_utils\\load_class_from_index.py 4 5 6 7 8 9 10 11 12 13 14 def load_class_from_index ( class_index , class_name : str ): \"\"\" Given a class_utils index (from build_class_index) and a class_utils name, import and return the class_utils object. \"\"\" if class_name not in class_index : raise ValueError ( f \"Class ' { class_name } ' not found.\" ) module_name , cls_name = class_index [ class_name ] module = importlib . import_module ( module_name ) return getattr ( module , cls_name ) Return the names of public methods defined directly on a class. Parameters cls: Class whose methods should be inspected. ignore: Optional list of method names to exclude from the result. Returns list[str] Names of methods defined on cls that are: - plain functions (no descriptors), - not dunder methods, - not starting with set , - not listed in ignore . Source code in utils\\class_utils\\get_class_methods.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def get_class_methods ( cls , ignore = []) -> list : \"\"\" Return the names of public methods defined directly on a class. Parameters ---------- cls: Class whose methods should be inspected. ignore: Optional list of method names to exclude from the result. Returns ------- list[str] Names of methods defined on ``cls`` that are: - plain functions (no descriptors), - not dunder methods, - not starting with ``set``, - not listed in ``ignore``. \"\"\" methods = [] for name , func in cls . __dict__ . items (): # Skip items that are not of the function type if type ( func ) != FunctionType : continue # ignore dunder_methods, setters and explicitly ignored function names if not name . startswith ( '_' ) and not name . startswith ( 'set' ) and name not in ignore : methods . append ( name ) return methods","title":"Utils - Class Utils"},{"location":"api/utils/class_utils/#class-utils","text":"Scan a package for class_utils definitions without importing all modules at once. Returns a dict mapping class_utils name to (module_name, class_name). Source code in utils\\class_utils\\build_class_index.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def build_class_index ( package_name : str ): \"\"\" Scan a package for class_utils definitions without importing all modules at once. Returns a dict mapping class_utils name to (module_name, class_name). \"\"\" index = {} package = importlib . import_module ( package_name ) for _ , module_name , _ in pkgutil . walk_packages ( package . __path__ , package . __name__ + \".\" ): module = importlib . import_module ( module_name ) # minimal import to inspect for name , obj in inspect . getmembers ( module , inspect . isclass ): if obj . __module__ == module . __name__ : index [ name ] = ( module_name , name ) return index Given a class_utils index (from build_class_index) and a class_utils name, import and return the class_utils object. Source code in utils\\class_utils\\load_class_from_index.py 4 5 6 7 8 9 10 11 12 13 14 def load_class_from_index ( class_index , class_name : str ): \"\"\" Given a class_utils index (from build_class_index) and a class_utils name, import and return the class_utils object. \"\"\" if class_name not in class_index : raise ValueError ( f \"Class ' { class_name } ' not found.\" ) module_name , cls_name = class_index [ class_name ] module = importlib . import_module ( module_name ) return getattr ( module , cls_name ) Return the names of public methods defined directly on a class.","title":"Class Utils"},{"location":"api/utils/class_utils/#utils.class_utils.get_class_methods.get_class_methods--parameters","text":"cls: Class whose methods should be inspected. ignore: Optional list of method names to exclude from the result.","title":"Parameters"},{"location":"api/utils/class_utils/#utils.class_utils.get_class_methods.get_class_methods--returns","text":"list[str] Names of methods defined on cls that are: - plain functions (no descriptors), - not dunder methods, - not starting with set , - not listed in ignore . Source code in utils\\class_utils\\get_class_methods.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def get_class_methods ( cls , ignore = []) -> list : \"\"\" Return the names of public methods defined directly on a class. Parameters ---------- cls: Class whose methods should be inspected. ignore: Optional list of method names to exclude from the result. Returns ------- list[str] Names of methods defined on ``cls`` that are: - plain functions (no descriptors), - not dunder methods, - not starting with ``set``, - not listed in ``ignore``. \"\"\" methods = [] for name , func in cls . __dict__ . items (): # Skip items that are not of the function type if type ( func ) != FunctionType : continue # ignore dunder_methods, setters and explicitly ignored function names if not name . startswith ( '_' ) and not name . startswith ( 'set' ) and name not in ignore : methods . append ( name ) return methods","title":"Returns"},{"location":"api/utils/errors/","text":"Error Handling Bases: ValueError Raised when an open-circuit voltage (Voc) value cannot be located. Source code in utils\\errors\\errors.py 1 2 3 class VocNotFoundError ( ValueError ): \"\"\"Raised when an open-circuit voltage (Voc) value cannot be located.\"\"\" pass Bases: ValueError Raised when a short-circuit current (Isc) value cannot be located. Source code in utils\\errors\\errors.py 6 7 8 class IscNotFoundError ( ValueError ): \"\"\"Raised when a short-circuit current (Isc) value cannot be located.\"\"\" pass Bases: ValueError Raised when a requested observable cannot be derived from the available data. Source code in utils\\errors\\errors.py 11 12 13 class ObservableNotComputableError ( ValueError ): \"\"\"Raised when a requested observable cannot be derived from the available data.\"\"\" pass Bases: KeyError Raised when a dataset or configuration refers to an unknown device type. Source code in utils\\errors\\errors.py 16 17 18 class IncompatibleDeviceTypeFound ( KeyError ): \"\"\"Raised when a dataset or configuration refers to an unknown device type.\"\"\" pass Bases: RuntimeError Raised when the implementations package fails validation. Source code in utils\\errors\\errors.py 21 22 class ImplementationError ( RuntimeError ): \"\"\"Raised when the implementations package fails validation.\"\"\" Wrap a function so that :class: VocNotFoundError is logged and suppressed. Parameters func: Callable to execute. logger: Logger instance used to record the error. Returns Callable[..., Any] A wrapper that calls func and logs any :class: VocNotFoundError instead of propagating it. Source code in utils\\errors\\logging.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def error_with_logging ( func : Callable [ ... , Any ], logger : logging . Logger ) -> Callable [ ... , Any ]: \"\"\" Wrap a function so that :class:`VocNotFoundError` is logged and suppressed. Parameters ---------- func: Callable to execute. logger: Logger instance used to record the error. Returns ------- Callable[..., Any] A wrapper that calls ``func`` and logs any :class:`VocNotFoundError` instead of propagating it. \"\"\" @functools . wraps ( func ) def wrapper ( * args : Any , ** kwargs : Any ) -> Any : try : func ( * args , ** kwargs ) except VocNotFoundError as err : logger . error ( f \"Found error { err } calling { func . __name__ } \" ) return wrapper Decorator that logs and re-raises any exception raised by func . Parameters func: Callable to wrap. logger: Logger instance used to record the exception and traceback. Returns Callable[..., Any] A wrapper that logs the exception details before re-raising them. Source code in utils\\errors\\logging.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def exceptions_logging ( func : Callable [ ... , Any ], logger : logging . Logger ) -> Callable [ ... , Any ]: \"\"\" Decorator that logs and re-raises any exception raised by ``func``. Parameters ---------- func: Callable to wrap. logger: Logger instance used to record the exception and traceback. Returns ------- Callable[..., Any] A wrapper that logs the exception details before re-raising them. \"\"\" @functools . wraps ( func ) def wrapper ( * args , ** kwargs ): try : func ( * args , ** kwargs ) except Exception as exc : import traceback logger . error ( f \"Found error { exc } calling { func . __name__ } \" ) logger . error ( f \"Reported trace: { traceback . format_exc () } \" ) raise return wrapper","title":"Utils - Errors"},{"location":"api/utils/errors/#error-handling","text":"Bases: ValueError Raised when an open-circuit voltage (Voc) value cannot be located. Source code in utils\\errors\\errors.py 1 2 3 class VocNotFoundError ( ValueError ): \"\"\"Raised when an open-circuit voltage (Voc) value cannot be located.\"\"\" pass Bases: ValueError Raised when a short-circuit current (Isc) value cannot be located. Source code in utils\\errors\\errors.py 6 7 8 class IscNotFoundError ( ValueError ): \"\"\"Raised when a short-circuit current (Isc) value cannot be located.\"\"\" pass Bases: ValueError Raised when a requested observable cannot be derived from the available data. Source code in utils\\errors\\errors.py 11 12 13 class ObservableNotComputableError ( ValueError ): \"\"\"Raised when a requested observable cannot be derived from the available data.\"\"\" pass Bases: KeyError Raised when a dataset or configuration refers to an unknown device type. Source code in utils\\errors\\errors.py 16 17 18 class IncompatibleDeviceTypeFound ( KeyError ): \"\"\"Raised when a dataset or configuration refers to an unknown device type.\"\"\" pass Bases: RuntimeError Raised when the implementations package fails validation. Source code in utils\\errors\\errors.py 21 22 class ImplementationError ( RuntimeError ): \"\"\"Raised when the implementations package fails validation.\"\"\" Wrap a function so that :class: VocNotFoundError is logged and suppressed.","title":"Error Handling"},{"location":"api/utils/errors/#utils.errors.logging.error_with_logging--parameters","text":"func: Callable to execute. logger: Logger instance used to record the error.","title":"Parameters"},{"location":"api/utils/errors/#utils.errors.logging.error_with_logging--returns","text":"Callable[..., Any] A wrapper that calls func and logs any :class: VocNotFoundError instead of propagating it. Source code in utils\\errors\\logging.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def error_with_logging ( func : Callable [ ... , Any ], logger : logging . Logger ) -> Callable [ ... , Any ]: \"\"\" Wrap a function so that :class:`VocNotFoundError` is logged and suppressed. Parameters ---------- func: Callable to execute. logger: Logger instance used to record the error. Returns ------- Callable[..., Any] A wrapper that calls ``func`` and logs any :class:`VocNotFoundError` instead of propagating it. \"\"\" @functools . wraps ( func ) def wrapper ( * args : Any , ** kwargs : Any ) -> Any : try : func ( * args , ** kwargs ) except VocNotFoundError as err : logger . error ( f \"Found error { err } calling { func . __name__ } \" ) return wrapper Decorator that logs and re-raises any exception raised by func .","title":"Returns"},{"location":"api/utils/errors/#utils.errors.logging.exceptions_logging--parameters","text":"func: Callable to wrap. logger: Logger instance used to record the exception and traceback.","title":"Parameters"},{"location":"api/utils/errors/#utils.errors.logging.exceptions_logging--returns","text":"Callable[..., Any] A wrapper that logs the exception details before re-raising them. Source code in utils\\errors\\logging.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def exceptions_logging ( func : Callable [ ... , Any ], logger : logging . Logger ) -> Callable [ ... , Any ]: \"\"\" Decorator that logs and re-raises any exception raised by ``func``. Parameters ---------- func: Callable to wrap. logger: Logger instance used to record the exception and traceback. Returns ------- Callable[..., Any] A wrapper that logs the exception details before re-raising them. \"\"\" @functools . wraps ( func ) def wrapper ( * args , ** kwargs ): try : func ( * args , ** kwargs ) except Exception as exc : import traceback logger . error ( f \"Found error { exc } calling { func . __name__ } \" ) logger . error ( f \"Reported trace: { traceback . format_exc () } \" ) raise return wrapper","title":"Returns"},{"location":"api/utils/logging/","text":"Logging Thin wrapper around the shared application logger. The class provides a simple console_print method used by the GUI to write messages to the configured logger identified by constants.LOG_NAME . Source code in utils\\logging.py 14 15 16 17 18 19 20 21 22 23 24 class ConsoleLogging : \"\"\"Thin wrapper around the shared application logger. The class provides a simple ``console_print`` method used by the GUI to write messages to the configured logger identified by ``constants.LOG_NAME``. \"\"\" def __init__ ( self ): self . logger = logging . getLogger ( constants . LOG_NAME ) def console_print ( self , level = 10 , message = None ): self . logger . log ( level , message ) Logging decorator usable as @with_logging @with_logging() @with_logging(log_level=...) Source code in utils\\logging.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def with_logging ( func = None , * , log_level : int = 10 ): \"\"\" Logging decorator usable as: @with_logging @with_logging() @with_logging(log_level=...) \"\"\" def decorator ( func ): @functools . wraps ( func ) def wrapper ( * args , ** kwargs ): logger = logging . getLogger ( constants . LOG_NAME ) logger . log ( log_level , f \"Calling { func . __qualname__ } \" ) value = func ( * args , ** kwargs ) logger . log ( log_level , f \"Finished calling { func . __qualname__ } \" ) return value return wrapper # CASE 1: @with_logging \u2192 func is the decorated function if callable ( func ): return decorator ( func ) # CASE 2: @with_logging(...) \u2192 func is None, return real decorator return decorator Class decorator that wraps explicitly defined methods on a class with with_logging , without touching Qt signals or other descriptors. Only items in cls.__dict__ that are real functions (or class/staticmethods) are wrapped. By default, public methods (no leading underscore) are wrapped. You can narrow/adjust behaviour with include / exclude . Source code in utils\\logging.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def decorate_class_with_logging ( log_level : int = 10 , include : set [ str ] | None = None , exclude : set [ str ] | None = None , ): \"\"\" Class decorator that wraps explicitly defined *methods* on a class with `with_logging`, without touching Qt signals or other descriptors. - Only items in `cls.__dict__` that are real functions (or class/staticmethods) are wrapped. - By default, public methods (no leading underscore) are wrapped. - You can narrow/adjust behaviour with `include` / `exclude`. \"\"\" def decorator ( cls ): for name , attr in cls . __dict__ . items (): # unwrap classmethod / staticmethod is_classmethod = isinstance ( attr , classmethod ) is_staticmethod = isinstance ( attr , staticmethod ) func = attr . __func__ if ( is_classmethod or is_staticmethod ) else attr # only wrap *real* functions, not pyqtSignal, properties, etc. if not isinstance ( func , FunctionType ): continue # skip dunder + private-ish names if name . startswith ( \"__\" ) and name . endswith ( \"__\" ): continue if name . startswith ( \"_\" ): continue # optional filters if include is not None and name not in include : continue if exclude is not None and name in exclude : continue # your existing with_logging(func, log_level=...) wrapped_func = with_logging ( func , log_level = log_level ) # re-wrap as classmethod/staticmethod if needed if is_classmethod : wrapped_attr = classmethod ( wrapped_func ) elif is_staticmethod : wrapped_attr = staticmethod ( wrapped_func ) else : wrapped_attr = wrapped_func setattr ( cls , name , wrapped_attr ) return cls return decorator","title":"Utils - Logging"},{"location":"api/utils/logging/#logging","text":"Thin wrapper around the shared application logger. The class provides a simple console_print method used by the GUI to write messages to the configured logger identified by constants.LOG_NAME . Source code in utils\\logging.py 14 15 16 17 18 19 20 21 22 23 24 class ConsoleLogging : \"\"\"Thin wrapper around the shared application logger. The class provides a simple ``console_print`` method used by the GUI to write messages to the configured logger identified by ``constants.LOG_NAME``. \"\"\" def __init__ ( self ): self . logger = logging . getLogger ( constants . LOG_NAME ) def console_print ( self , level = 10 , message = None ): self . logger . log ( level , message ) Logging decorator usable as @with_logging @with_logging() @with_logging(log_level=...) Source code in utils\\logging.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def with_logging ( func = None , * , log_level : int = 10 ): \"\"\" Logging decorator usable as: @with_logging @with_logging() @with_logging(log_level=...) \"\"\" def decorator ( func ): @functools . wraps ( func ) def wrapper ( * args , ** kwargs ): logger = logging . getLogger ( constants . LOG_NAME ) logger . log ( log_level , f \"Calling { func . __qualname__ } \" ) value = func ( * args , ** kwargs ) logger . log ( log_level , f \"Finished calling { func . __qualname__ } \" ) return value return wrapper # CASE 1: @with_logging \u2192 func is the decorated function if callable ( func ): return decorator ( func ) # CASE 2: @with_logging(...) \u2192 func is None, return real decorator return decorator Class decorator that wraps explicitly defined methods on a class with with_logging , without touching Qt signals or other descriptors. Only items in cls.__dict__ that are real functions (or class/staticmethods) are wrapped. By default, public methods (no leading underscore) are wrapped. You can narrow/adjust behaviour with include / exclude . Source code in utils\\logging.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def decorate_class_with_logging ( log_level : int = 10 , include : set [ str ] | None = None , exclude : set [ str ] | None = None , ): \"\"\" Class decorator that wraps explicitly defined *methods* on a class with `with_logging`, without touching Qt signals or other descriptors. - Only items in `cls.__dict__` that are real functions (or class/staticmethods) are wrapped. - By default, public methods (no leading underscore) are wrapped. - You can narrow/adjust behaviour with `include` / `exclude`. \"\"\" def decorator ( cls ): for name , attr in cls . __dict__ . items (): # unwrap classmethod / staticmethod is_classmethod = isinstance ( attr , classmethod ) is_staticmethod = isinstance ( attr , staticmethod ) func = attr . __func__ if ( is_classmethod or is_staticmethod ) else attr # only wrap *real* functions, not pyqtSignal, properties, etc. if not isinstance ( func , FunctionType ): continue # skip dunder + private-ish names if name . startswith ( \"__\" ) and name . endswith ( \"__\" ): continue if name . startswith ( \"_\" ): continue # optional filters if include is not None and name not in include : continue if exclude is not None and name in exclude : continue # your existing with_logging(func, log_level=...) wrapped_func = with_logging ( func , log_level = log_level ) # re-wrap as classmethod/staticmethod if needed if is_classmethod : wrapped_attr = classmethod ( wrapped_func ) elif is_staticmethod : wrapped_attr = staticmethod ( wrapped_func ) else : wrapped_attr = wrapped_func setattr ( cls , name , wrapped_attr ) return cls return decorator","title":"Logging"},{"location":"api/utils/others/","text":"Additional utilities Run all checks on the implementations package. Source code in utils\\check_implementations.py 23 24 25 26 27 28 29 30 def check_implementations () -> None : \"\"\"Run all checks on the `implementations` package.\"\"\" _ , impl_root = _require_implementations_package () _check_directory_structure ( impl_root ) modules = _import_impl_modules () _check_contract_implementations ( modules ) _check_device_ui_files ( impl_root , modules [ \"devices_workers\" ]) _check_config_file ( impl_root ) Helper for mapping message level names to QColor instances. The colours are used by the GUI console to display messages with different visual emphasis (alert, warning, normal). Source code in utils\\console_colours.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ConsoleColours : \"\"\" Helper for mapping message level names to QColor instances. The colours are used by the GUI console to display messages with different visual emphasis (alert, warning, normal). \"\"\" def __init__ ( self ): self . _alert = QtGui . QColor ( 255 , 0 , 0 ) self . _warning = QtGui . QColor ( 255 , 127 , 0 ) self . _normal = QtGui . QColor ( 255 , 255 , 255 ) def get_colour ( self , level ): return getattr ( self , f \"_ { level } \" ) Utility for parsing and serialising my custom timestamp format. The helper supports flexible separators and format strings used to construct filenames and labels, and provides round-tripping between strings and :class: datetime.datetime objects. Source code in utils\\custom_datetime.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class CustomDatetime : \"\"\" Utility for parsing and serialising my custom timestamp format. The helper supports flexible separators and format strings used to construct filenames and labels, and provides round-tripping between strings and :class:`datetime.datetime` objects. \"\"\" def __init__ ( self , separators = \"-_\" , label_format = \"%Y_%m_ %d _%H_%M_%S\" , default_time = \"09_00_00\" , date_pattern = None , time_pattern = None ): self . separators = separators self . label_format = label_format self . default_time = default_time # If user didn't pass custom patterns, use default YYYY_MM_DD / HH_MM_SS self . date_pattern = date_pattern or rf \"(\\d {{ 4 }} )[ { self . separators } ](\\d {{ 2 }} )[ { self . separators } ](\\d {{ 2 }} )\" self . time_pattern = time_pattern or rf \"(\\d {{ 2 }} )[ { self . separators } ](\\d {{ 2 }} )[ { self . separators } ](\\d {{ 2 }} )\" def create_datetime_from_string ( self , input_datetime_str : str = None ) -> datetime : \"\"\" Creates a datetime object from an input datetime string. - Infers %Y vs %y from the year token length. - Allows HH_MM or HH_MM_SS; pads seconds to 00 when missing. \"\"\" if input_datetime_str is None : raise ValueError ( \"Input datetime string cannot be None\" ) # --- Find date --- date_match = re . search ( self . date_pattern , input_datetime_str ) if not date_match : raise ValueError ( f \"Input string { input_datetime_str } does not contain a valid date\" ) date_groups = date_match . groups () if len ( date_groups ) != 3 : raise ValueError ( \"Date pattern must capture exactly 3 groups (Y, m, d)\" ) year_token = date_groups [ 0 ] if len ( year_token ) == 4 : date_fmt = \"%Y_%m_ %d \" elif len ( year_token ) == 2 : date_fmt = \"%y_%m_ %d \" else : raise ValueError ( \"Year group must be 2 or 4 digits\" ) date_str = \"_\" . join ( date_groups ) # --- Find time (search only after date to avoid picking up pre-date tokens) --- remaining_str = input_datetime_str [ date_match . end ():] time_match = re . search ( self . time_pattern , remaining_str ) if time_match : time_groups = time_match . groups () if len ( time_groups ) == 3 : time_str = \"_\" . join ( time_groups ) # HH_MM_SS time_fmt = \"%H_%M_%S\" elif len ( time_groups ) == 2 : time_str = f \" { time_groups [ 0 ] } _ { time_groups [ 1 ] } _00\" # HH_MM_00 time_fmt = \"%H_%M_%S\" else : raise ValueError ( \"Time pattern must capture 2 (H,M) or 3 (H,M,S) groups\" ) else : # Use default time (assumed HH_MM_SS like \"09_00_00\") time_str = self . default_time time_fmt = \"%H_%M_%S\" # Final assemble + parse datetime_str = f \" { date_str } _ { time_str } \" fmt = f \" { date_fmt } _ { time_fmt } \" return datetime . strptime ( datetime_str , fmt ) def write_datetime_to_string ( self , input_datetime : datetime ) -> str : if input_datetime is None : raise ValueError ( \"Input datetime cannot be None\" ) return input_datetime . strftime ( self . label_format ) def get_current_timestamp ( self , now : datetime | None = None ) -> str : \"\"\" Returns a timestamp string using `label_format`, suitable for filenames. Pass `now` for deterministic testing; otherwise uses current local time. \"\"\" current = now or datetime . now () return self . write_datetime_to_string ( current ) create_datetime_from_string ( input_datetime_str = None ) Creates a datetime object from an input datetime string. Infers %Y vs %y from the year token length. Allows HH_MM or HH_MM_SS; pads seconds to 00 when missing. Source code in utils\\custom_datetime.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def create_datetime_from_string ( self , input_datetime_str : str = None ) -> datetime : \"\"\" Creates a datetime object from an input datetime string. - Infers %Y vs %y from the year token length. - Allows HH_MM or HH_MM_SS; pads seconds to 00 when missing. \"\"\" if input_datetime_str is None : raise ValueError ( \"Input datetime string cannot be None\" ) # --- Find date --- date_match = re . search ( self . date_pattern , input_datetime_str ) if not date_match : raise ValueError ( f \"Input string { input_datetime_str } does not contain a valid date\" ) date_groups = date_match . groups () if len ( date_groups ) != 3 : raise ValueError ( \"Date pattern must capture exactly 3 groups (Y, m, d)\" ) year_token = date_groups [ 0 ] if len ( year_token ) == 4 : date_fmt = \"%Y_%m_ %d \" elif len ( year_token ) == 2 : date_fmt = \"%y_%m_ %d \" else : raise ValueError ( \"Year group must be 2 or 4 digits\" ) date_str = \"_\" . join ( date_groups ) # --- Find time (search only after date to avoid picking up pre-date tokens) --- remaining_str = input_datetime_str [ date_match . end ():] time_match = re . search ( self . time_pattern , remaining_str ) if time_match : time_groups = time_match . groups () if len ( time_groups ) == 3 : time_str = \"_\" . join ( time_groups ) # HH_MM_SS time_fmt = \"%H_%M_%S\" elif len ( time_groups ) == 2 : time_str = f \" { time_groups [ 0 ] } _ { time_groups [ 1 ] } _00\" # HH_MM_00 time_fmt = \"%H_%M_%S\" else : raise ValueError ( \"Time pattern must capture 2 (H,M) or 3 (H,M,S) groups\" ) else : # Use default time (assumed HH_MM_SS like \"09_00_00\") time_str = self . default_time time_fmt = \"%H_%M_%S\" # Final assemble + parse datetime_str = f \" { date_str } _ { time_str } \" fmt = f \" { date_fmt } _ { time_fmt } \" return datetime . strptime ( datetime_str , fmt ) get_current_timestamp ( now = None ) Returns a timestamp string using label_format , suitable for filenames. Pass now for deterministic testing; otherwise uses current local time. Source code in utils\\custom_datetime.py 87 88 89 90 91 92 93 def get_current_timestamp ( self , now : datetime | None = None ) -> str : \"\"\" Returns a timestamp string using `label_format`, suitable for filenames. Pass `now` for deterministic testing; otherwise uses current local time. \"\"\" current = now or datetime . now () return self . write_datetime_to_string ( current ) Export matrix to a delimiter-separated text file. Parameters filename: Path to the output file that will be created/overwritten. list_of_lists: List of equal-length iterables, each representing a column of data. header: List of column labels written as the first line of the file. delimiter: String used to join header fields and row values (defaults to tab). Notes The function assumes that all columns in list_of_lists have the same length and will raise IndexError if this is not the case. Source code in utils\\export_to_csv.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def export_to_csv ( filename : str , list_of_lists : list , header : list , delimiter : str = ' \\t ' ): \"\"\" Export matrix to a delimiter-separated text file. Parameters ---------- filename: Path to the output file that will be created/overwritten. list_of_lists: List of equal-length iterables, each representing a column of data. header: List of column labels written as the first line of the file. delimiter: String used to join header fields and row values (defaults to tab). Notes ----- The function assumes that all columns in ``list_of_lists`` have the same length and will raise ``IndexError`` if this is not the case. \"\"\" first_list = list_of_lists [ 0 ] # Open a file with open ( filename , 'w' ) as csv_file : # Save the header row csv_file . write ( delimiter . join ( header )) csv_file . write ( ' \\n ' ) # Go through all columns and write the data for index in range ( len ( first_list )): row = [] for sublist in list_of_lists : row . append ( str ( sublist [ index ])) csv_file . write ( delimiter . join ( row )) csv_file . write ( ' \\n ' ) Read a JSON configuration file and return its contents as a dictionary. Parameters config_path : str The file path to the JSON configuration file. Returns dict A dictionary containing the configuration settings. Source code in utils\\read_config.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def read_config ( config_path : str ) -> dict : \"\"\"Read a JSON configuration file and return its contents as a dictionary. Parameters ---------- config_path : str The file path to the JSON configuration file. Returns ------- dict A dictionary containing the configuration settings. \"\"\" with open ( config_path , 'r' ) as file : config = json . load ( file ) return config","title":"Utils - Others"},{"location":"api/utils/others/#additional-utilities","text":"Run all checks on the implementations package. Source code in utils\\check_implementations.py 23 24 25 26 27 28 29 30 def check_implementations () -> None : \"\"\"Run all checks on the `implementations` package.\"\"\" _ , impl_root = _require_implementations_package () _check_directory_structure ( impl_root ) modules = _import_impl_modules () _check_contract_implementations ( modules ) _check_device_ui_files ( impl_root , modules [ \"devices_workers\" ]) _check_config_file ( impl_root ) Helper for mapping message level names to QColor instances. The colours are used by the GUI console to display messages with different visual emphasis (alert, warning, normal). Source code in utils\\console_colours.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ConsoleColours : \"\"\" Helper for mapping message level names to QColor instances. The colours are used by the GUI console to display messages with different visual emphasis (alert, warning, normal). \"\"\" def __init__ ( self ): self . _alert = QtGui . QColor ( 255 , 0 , 0 ) self . _warning = QtGui . QColor ( 255 , 127 , 0 ) self . _normal = QtGui . QColor ( 255 , 255 , 255 ) def get_colour ( self , level ): return getattr ( self , f \"_ { level } \" ) Utility for parsing and serialising my custom timestamp format. The helper supports flexible separators and format strings used to construct filenames and labels, and provides round-tripping between strings and :class: datetime.datetime objects. Source code in utils\\custom_datetime.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class CustomDatetime : \"\"\" Utility for parsing and serialising my custom timestamp format. The helper supports flexible separators and format strings used to construct filenames and labels, and provides round-tripping between strings and :class:`datetime.datetime` objects. \"\"\" def __init__ ( self , separators = \"-_\" , label_format = \"%Y_%m_ %d _%H_%M_%S\" , default_time = \"09_00_00\" , date_pattern = None , time_pattern = None ): self . separators = separators self . label_format = label_format self . default_time = default_time # If user didn't pass custom patterns, use default YYYY_MM_DD / HH_MM_SS self . date_pattern = date_pattern or rf \"(\\d {{ 4 }} )[ { self . separators } ](\\d {{ 2 }} )[ { self . separators } ](\\d {{ 2 }} )\" self . time_pattern = time_pattern or rf \"(\\d {{ 2 }} )[ { self . separators } ](\\d {{ 2 }} )[ { self . separators } ](\\d {{ 2 }} )\" def create_datetime_from_string ( self , input_datetime_str : str = None ) -> datetime : \"\"\" Creates a datetime object from an input datetime string. - Infers %Y vs %y from the year token length. - Allows HH_MM or HH_MM_SS; pads seconds to 00 when missing. \"\"\" if input_datetime_str is None : raise ValueError ( \"Input datetime string cannot be None\" ) # --- Find date --- date_match = re . search ( self . date_pattern , input_datetime_str ) if not date_match : raise ValueError ( f \"Input string { input_datetime_str } does not contain a valid date\" ) date_groups = date_match . groups () if len ( date_groups ) != 3 : raise ValueError ( \"Date pattern must capture exactly 3 groups (Y, m, d)\" ) year_token = date_groups [ 0 ] if len ( year_token ) == 4 : date_fmt = \"%Y_%m_ %d \" elif len ( year_token ) == 2 : date_fmt = \"%y_%m_ %d \" else : raise ValueError ( \"Year group must be 2 or 4 digits\" ) date_str = \"_\" . join ( date_groups ) # --- Find time (search only after date to avoid picking up pre-date tokens) --- remaining_str = input_datetime_str [ date_match . end ():] time_match = re . search ( self . time_pattern , remaining_str ) if time_match : time_groups = time_match . groups () if len ( time_groups ) == 3 : time_str = \"_\" . join ( time_groups ) # HH_MM_SS time_fmt = \"%H_%M_%S\" elif len ( time_groups ) == 2 : time_str = f \" { time_groups [ 0 ] } _ { time_groups [ 1 ] } _00\" # HH_MM_00 time_fmt = \"%H_%M_%S\" else : raise ValueError ( \"Time pattern must capture 2 (H,M) or 3 (H,M,S) groups\" ) else : # Use default time (assumed HH_MM_SS like \"09_00_00\") time_str = self . default_time time_fmt = \"%H_%M_%S\" # Final assemble + parse datetime_str = f \" { date_str } _ { time_str } \" fmt = f \" { date_fmt } _ { time_fmt } \" return datetime . strptime ( datetime_str , fmt ) def write_datetime_to_string ( self , input_datetime : datetime ) -> str : if input_datetime is None : raise ValueError ( \"Input datetime cannot be None\" ) return input_datetime . strftime ( self . label_format ) def get_current_timestamp ( self , now : datetime | None = None ) -> str : \"\"\" Returns a timestamp string using `label_format`, suitable for filenames. Pass `now` for deterministic testing; otherwise uses current local time. \"\"\" current = now or datetime . now () return self . write_datetime_to_string ( current )","title":"Additional utilities"},{"location":"api/utils/others/#utils.custom_datetime.CustomDatetime.create_datetime_from_string","text":"Creates a datetime object from an input datetime string. Infers %Y vs %y from the year token length. Allows HH_MM or HH_MM_SS; pads seconds to 00 when missing. Source code in utils\\custom_datetime.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def create_datetime_from_string ( self , input_datetime_str : str = None ) -> datetime : \"\"\" Creates a datetime object from an input datetime string. - Infers %Y vs %y from the year token length. - Allows HH_MM or HH_MM_SS; pads seconds to 00 when missing. \"\"\" if input_datetime_str is None : raise ValueError ( \"Input datetime string cannot be None\" ) # --- Find date --- date_match = re . search ( self . date_pattern , input_datetime_str ) if not date_match : raise ValueError ( f \"Input string { input_datetime_str } does not contain a valid date\" ) date_groups = date_match . groups () if len ( date_groups ) != 3 : raise ValueError ( \"Date pattern must capture exactly 3 groups (Y, m, d)\" ) year_token = date_groups [ 0 ] if len ( year_token ) == 4 : date_fmt = \"%Y_%m_ %d \" elif len ( year_token ) == 2 : date_fmt = \"%y_%m_ %d \" else : raise ValueError ( \"Year group must be 2 or 4 digits\" ) date_str = \"_\" . join ( date_groups ) # --- Find time (search only after date to avoid picking up pre-date tokens) --- remaining_str = input_datetime_str [ date_match . end ():] time_match = re . search ( self . time_pattern , remaining_str ) if time_match : time_groups = time_match . groups () if len ( time_groups ) == 3 : time_str = \"_\" . join ( time_groups ) # HH_MM_SS time_fmt = \"%H_%M_%S\" elif len ( time_groups ) == 2 : time_str = f \" { time_groups [ 0 ] } _ { time_groups [ 1 ] } _00\" # HH_MM_00 time_fmt = \"%H_%M_%S\" else : raise ValueError ( \"Time pattern must capture 2 (H,M) or 3 (H,M,S) groups\" ) else : # Use default time (assumed HH_MM_SS like \"09_00_00\") time_str = self . default_time time_fmt = \"%H_%M_%S\" # Final assemble + parse datetime_str = f \" { date_str } _ { time_str } \" fmt = f \" { date_fmt } _ { time_fmt } \" return datetime . strptime ( datetime_str , fmt )","title":"create_datetime_from_string"},{"location":"api/utils/others/#utils.custom_datetime.CustomDatetime.get_current_timestamp","text":"Returns a timestamp string using label_format , suitable for filenames. Pass now for deterministic testing; otherwise uses current local time. Source code in utils\\custom_datetime.py 87 88 89 90 91 92 93 def get_current_timestamp ( self , now : datetime | None = None ) -> str : \"\"\" Returns a timestamp string using `label_format`, suitable for filenames. Pass `now` for deterministic testing; otherwise uses current local time. \"\"\" current = now or datetime . now () return self . write_datetime_to_string ( current ) Export matrix to a delimiter-separated text file.","title":"get_current_timestamp"},{"location":"api/utils/others/#utils.export_to_csv.export_to_csv--parameters","text":"filename: Path to the output file that will be created/overwritten. list_of_lists: List of equal-length iterables, each representing a column of data. header: List of column labels written as the first line of the file. delimiter: String used to join header fields and row values (defaults to tab).","title":"Parameters"},{"location":"api/utils/others/#utils.export_to_csv.export_to_csv--notes","text":"The function assumes that all columns in list_of_lists have the same length and will raise IndexError if this is not the case. Source code in utils\\export_to_csv.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def export_to_csv ( filename : str , list_of_lists : list , header : list , delimiter : str = ' \\t ' ): \"\"\" Export matrix to a delimiter-separated text file. Parameters ---------- filename: Path to the output file that will be created/overwritten. list_of_lists: List of equal-length iterables, each representing a column of data. header: List of column labels written as the first line of the file. delimiter: String used to join header fields and row values (defaults to tab). Notes ----- The function assumes that all columns in ``list_of_lists`` have the same length and will raise ``IndexError`` if this is not the case. \"\"\" first_list = list_of_lists [ 0 ] # Open a file with open ( filename , 'w' ) as csv_file : # Save the header row csv_file . write ( delimiter . join ( header )) csv_file . write ( ' \\n ' ) # Go through all columns and write the data for index in range ( len ( first_list )): row = [] for sublist in list_of_lists : row . append ( str ( sublist [ index ])) csv_file . write ( delimiter . join ( row )) csv_file . write ( ' \\n ' ) Read a JSON configuration file and return its contents as a dictionary.","title":"Notes"},{"location":"api/utils/others/#utils.read_config.read_config--parameters","text":"config_path : str The file path to the JSON configuration file.","title":"Parameters"},{"location":"api/utils/others/#utils.read_config.read_config--returns","text":"dict A dictionary containing the configuration settings. Source code in utils\\read_config.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def read_config ( config_path : str ) -> dict : \"\"\"Read a JSON configuration file and return its contents as a dictionary. Parameters ---------- config_path : str The file path to the JSON configuration file. Returns ------- dict A dictionary containing the configuration settings. \"\"\" with open ( config_path , 'r' ) as file : config = json . load ( file ) return config","title":"Returns"}]}