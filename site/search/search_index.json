{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home This project is a framework for integrating data-processing and plotting into a structured user-interface. The aim of this project is two-fold 1) Provide a straightforward way to collect and consistently plot data from a variety of sources. 2) Provide a framework of modular data-processing and plotting components. At a high level, it provides: Two user interface windows, one for creating dataspecs (which define what data to collect and how to process it) and one for launching and monitoring analyses (which execute dataspecs and plot the results) A set of contracts / interfaces that define how devices, processors, and plotters should behave A layer of general utilities for configuration and general plumbing An easy way to enable logging to the UIs console Instead of hard-coding a single pipeline, the framework focuses on: Modularity Component Reuse Ease of Extension","title":"Home"},{"location":"#home","text":"This project is a framework for integrating data-processing and plotting into a structured user-interface. The aim of this project is two-fold 1) Provide a straightforward way to collect and consistently plot data from a variety of sources. 2) Provide a framework of modular data-processing and plotting components. At a high level, it provides: Two user interface windows, one for creating dataspecs (which define what data to collect and how to process it) and one for launching and monitoring analyses (which execute dataspecs and plot the results) A set of contracts / interfaces that define how devices, processors, and plotters should behave A layer of general utilities for configuration and general plumbing An easy way to enable logging to the UIs console Instead of hard-coding a single pipeline, the framework focuses on: Modularity Component Reuse Ease of Extension","title":"Home"},{"location":"dataspecs/","text":"Dataspecs A dataspec is a central configuration object in this framework. It describes which data it refers to , and how that data should be processed and visualised . Dataspecs are saved as small, human-readable JSON files, typically with extensions such as: .ds .dataspec .json (depending on preference or tooling) These files act as portable analysis definitions . Why dataspecs matter In many ad-hoc analysis workflows, users prepare a Python script containing: A bundle of paths pointing to raw data Hand-written code selecting processors or plotters Hard-coded parameters and metadata This approach becomes fragile quickly: Paths get copied incorrectly Important metadata is lost or scattered across scripts Reuse across experiments becomes painful Sharing analysis logic across a team becomes inconsistent Dataspecs solve this problem. Instead of writing one script per dataset, you describe the experiment or analysis in a structured JSON file . The framework then: Loads the dataspec Resolves the correct devices, processors, readers, and plotters Executes the run in a fully defined and reproducible way This gives repeatable, clean, long-lived analyses\u2014without rewriting code. Typical lifecycle of a dataspec 1. Creation Dataspecs are usually created through the Data Creation Window in the GUI. The window helps users: Label a set of datafiles Select a device type - defining the plots that are compatible Setting an experiment date and time Select data sources and label them Save to disk to a valid dataspec JSON file for reuse This UI is recommended because it ensures correctness and reduces manual JSON editing errors. 2. Storage Dataspecs are stored as JSON files using the framework\u2019s custom encoder/decoder. They are lightweight, human-editable, and versionable (ideal for Git). 3. Execution When a run begins: The dataspec is loaded The framework reads its fields A subset of the files can be selected for plotting The plot manager will construct matching device, processors, and plotters in a separate thread to prevent ui-lockup Loading is reported to the user via the UI progress bar The analysis/plot executes as defined by the devive, plotter and processor implementations Results are shown as defined by the user Because dataspecs are declarative, execution is consistent and repeatable. TL;DR Dataspecs are a powerful, central abstraction in this framework. They describe \u201cwhere to find data\u201d and what can be done with it in a clean, structured way, enabling: Reproducibility Reuse Metadata-driven analysis Clean separation between data and code Easy sharing across users and teams Together with the Data Creation Window, dataspecs transform analysis workflows from scattered scripts into a coherent, modern, configuration-driven system .","title":"Dataspecs"},{"location":"dataspecs/#dataspecs","text":"A dataspec is a central configuration object in this framework. It describes which data it refers to , and how that data should be processed and visualised . Dataspecs are saved as small, human-readable JSON files, typically with extensions such as: .ds .dataspec .json (depending on preference or tooling) These files act as portable analysis definitions .","title":"Dataspecs"},{"location":"dataspecs/#why-dataspecs-matter","text":"In many ad-hoc analysis workflows, users prepare a Python script containing: A bundle of paths pointing to raw data Hand-written code selecting processors or plotters Hard-coded parameters and metadata This approach becomes fragile quickly: Paths get copied incorrectly Important metadata is lost or scattered across scripts Reuse across experiments becomes painful Sharing analysis logic across a team becomes inconsistent Dataspecs solve this problem. Instead of writing one script per dataset, you describe the experiment or analysis in a structured JSON file . The framework then: Loads the dataspec Resolves the correct devices, processors, readers, and plotters Executes the run in a fully defined and reproducible way This gives repeatable, clean, long-lived analyses\u2014without rewriting code.","title":"Why dataspecs matter"},{"location":"dataspecs/#typical-lifecycle-of-a-dataspec","text":"","title":"Typical lifecycle of a dataspec"},{"location":"dataspecs/#1-creation","text":"Dataspecs are usually created through the Data Creation Window in the GUI. The window helps users: Label a set of datafiles Select a device type - defining the plots that are compatible Setting an experiment date and time Select data sources and label them Save to disk to a valid dataspec JSON file for reuse This UI is recommended because it ensures correctness and reduces manual JSON editing errors.","title":"1. Creation"},{"location":"dataspecs/#2-storage","text":"Dataspecs are stored as JSON files using the framework\u2019s custom encoder/decoder. They are lightweight, human-editable, and versionable (ideal for Git).","title":"2. Storage"},{"location":"dataspecs/#3-execution","text":"When a run begins: The dataspec is loaded The framework reads its fields A subset of the files can be selected for plotting The plot manager will construct matching device, processors, and plotters in a separate thread to prevent ui-lockup Loading is reported to the user via the UI progress bar The analysis/plot executes as defined by the devive, plotter and processor implementations Results are shown as defined by the user Because dataspecs are declarative, execution is consistent and repeatable.","title":"3. Execution"},{"location":"dataspecs/#tldr","text":"Dataspecs are a powerful, central abstraction in this framework. They describe \u201cwhere to find data\u201d and what can be done with it in a clean, structured way, enabling: Reproducibility Reuse Metadata-driven analysis Clean separation between data and code Easy sharing across users and teams Together with the Data Creation Window, dataspecs transform analysis workflows from scattered scripts into a coherent, modern, configuration-driven system .","title":"TL;DR"},{"location":"getting_started/","text":"Getting started Installation pip install -r requirements.txt Implementation of contracts To use this framework, you will need to implement the contracts defined in the contracts module. Crucially, the following contracts must be implemented at least once in an implementations module: DeviceWorker | DeviceWorkerCore : Starts in a thread and exposes available plot types for any given abstract 'device'. It is responsible for connecting Plotter, DataProcessor and Data components. Data | DataCore : Handles raw data access from files DataProcessor | DataProcessorCore : Handles computation of any derived quantities from raw data, is the primary interface to obtain data for plotting. Defers to Data for raw data access. Plotter : Handles plots and formatting, data is requested from DataProcessor The implementations module must have the following structure: implementations/ \u251c\u2500\u2500 data/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 data_processors/ \u2502 \u2502 \u2514\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 data_types/ \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 devices/ \u2502 \u251c\u2500\u2500 widgets/ \u2502 \u2502 \u2514\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 workers/ \u2502 \u2502 \u2514\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 plotters/ \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 utils/ \u2502 \u251c\u2500\u2500 constants.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 config.json \u2514\u2500\u2500 __init__.py A basic example/starting point can be found in the following repository: X-LAB Plotting Manager Implementations Running the GUI python -m gui.windows.MainWindow","title":"Getting started"},{"location":"getting_started/#getting-started","text":"","title":"Getting started"},{"location":"getting_started/#installation","text":"pip install -r requirements.txt","title":"Installation"},{"location":"getting_started/#implementation-of-contracts","text":"To use this framework, you will need to implement the contracts defined in the contracts module. Crucially, the following contracts must be implemented at least once in an implementations module: DeviceWorker | DeviceWorkerCore : Starts in a thread and exposes available plot types for any given abstract 'device'. It is responsible for connecting Plotter, DataProcessor and Data components. Data | DataCore : Handles raw data access from files DataProcessor | DataProcessorCore : Handles computation of any derived quantities from raw data, is the primary interface to obtain data for plotting. Defers to Data for raw data access. Plotter : Handles plots and formatting, data is requested from DataProcessor The implementations module must have the following structure: implementations/ \u251c\u2500\u2500 data/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 data_processors/ \u2502 \u2502 \u2514\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 data_types/ \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 devices/ \u2502 \u251c\u2500\u2500 widgets/ \u2502 \u2502 \u2514\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 workers/ \u2502 \u2502 \u2514\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 plotters/ \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 utils/ \u2502 \u251c\u2500\u2500 constants.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 config.json \u2514\u2500\u2500 __init__.py A basic example/starting point can be found in the following repository: X-LAB Plotting Manager Implementations","title":"Implementation of contracts"},{"location":"getting_started/#running-the-gui","text":"python -m gui.windows.MainWindow","title":"Running the GUI"},{"location":"logging/","text":"Logging Logging provides insight into what the framework is doing , both internally and in your own extensions. It is especially important when: Running long or complex analyses Debugging failing devices, processors or plotters Understanding what happened in a past run This project provides a central logging setup that can write to the UI console , so users can see messages directly in the application Design goals The logging system is designed to: Feed logs into the GUI console for live feedback Make it easy to add logging to user defined methods and classes Enables logging by default on Data, DataProcessor, and Worker Core classes Conceptually, there are three main pieces: A shared logging configuration and helpers Pre-decorated framework components (especially worker cores) Decorators you can use on your own code (plotters, custom methods, etc.) Plotters and other user code Unlike workers, plotters do not have a core class that is pre-decorated. This is an intentional design choice: Plotters can be very simple or very complex Users may want fine-grained control over what is logged and when As a result: Plotters must be explicitly decorated by the user if they should participate in the logging system. The same is true for any other user-defined methods or classes that you want to show up in the logs (and optionally in the UI console): Custom data processors not deriving from DataProcessorCore Helper functions Utility classes By decorating them yourself, you decide: Which functions are logged At what level (info, debug, warning, error) How verbose the output should be Logging decorators The utilities module exposes decorators that do the heavy lifting. Typical patterns include: A function decorator \u2013 logs entry and exit of a function, plus optional details. A class decorator \u2013 automatically decorates every (or selected) method of a class. At a conceptual level, usage looks like this: from utils.logging import with_logging, decorate_class_with_logging @with_logging def my_helper_function(...): # your helper logic here ... @decorate_class_with_logging class MyCustomPlotter: def draw_plot(self, ...): Summary: Decorators are provided to decorate classes @decorate_class_with_logging and functions @with_logging . Cores come pre-decorated with logging, and their messages go to the UI console without extra effort. Plotters, and any other user-defined components, must be decorated explicitly to participate in the logging ecosystem. The logging utilities make it easy to track the execution of your code in a consistent way, providing a unified view of the system\u2019s behaviour. By using the logging system thoughtfully, you get a transparent, traceable view of your data analysis runs, from dataspec-driven configuration through to final plots.","title":"Logging & debugging"},{"location":"logging/#logging","text":"Logging provides insight into what the framework is doing , both internally and in your own extensions. It is especially important when: Running long or complex analyses Debugging failing devices, processors or plotters Understanding what happened in a past run This project provides a central logging setup that can write to the UI console , so users can see messages directly in the application","title":"Logging"},{"location":"logging/#design-goals","text":"The logging system is designed to: Feed logs into the GUI console for live feedback Make it easy to add logging to user defined methods and classes Enables logging by default on Data, DataProcessor, and Worker Core classes Conceptually, there are three main pieces: A shared logging configuration and helpers Pre-decorated framework components (especially worker cores) Decorators you can use on your own code (plotters, custom methods, etc.)","title":"Design goals"},{"location":"logging/#plotters-and-other-user-code","text":"Unlike workers, plotters do not have a core class that is pre-decorated. This is an intentional design choice: Plotters can be very simple or very complex Users may want fine-grained control over what is logged and when As a result: Plotters must be explicitly decorated by the user if they should participate in the logging system. The same is true for any other user-defined methods or classes that you want to show up in the logs (and optionally in the UI console): Custom data processors not deriving from DataProcessorCore Helper functions Utility classes By decorating them yourself, you decide: Which functions are logged At what level (info, debug, warning, error) How verbose the output should be","title":"Plotters and other user code"},{"location":"logging/#logging-decorators","text":"The utilities module exposes decorators that do the heavy lifting. Typical patterns include: A function decorator \u2013 logs entry and exit of a function, plus optional details. A class decorator \u2013 automatically decorates every (or selected) method of a class. At a conceptual level, usage looks like this: from utils.logging import with_logging, decorate_class_with_logging @with_logging def my_helper_function(...): # your helper logic here ... @decorate_class_with_logging class MyCustomPlotter: def draw_plot(self, ...): Summary: Decorators are provided to decorate classes @decorate_class_with_logging and functions @with_logging . Cores come pre-decorated with logging, and their messages go to the UI console without extra effort. Plotters, and any other user-defined components, must be decorated explicitly to participate in the logging ecosystem. The logging utilities make it easy to track the execution of your code in a consistent way, providing a unified view of the system\u2019s behaviour. By using the logging system thoughtfully, you get a transparent, traceable view of your data analysis runs, from dataspec-driven configuration through to final plots.","title":"Logging decorators"},{"location":"api/dataspec_manager/","text":"DataSpec Manager API Documentation Container for experiment metadata and associated data file locations. A DataSpec instance describes a single experiment or dataset in terms of: - Basic metadata: name, creation date, experiment date/time, device identifier. - User annotations: free-form notes and a simple time-stamped console log. - File layout: a mapping from human-readable labels to absolute file paths. - Optional colour mapping: label-to-colour mapping for consistent plotting. - Structure type: how files are organised on disk (e.g. flat vs. directory-labelled). The class does not interpret the contents of the files; it only tracks their locations and minimal metadata. Filepaths can be: - Added manually via add_filepath , or - Auto-populated from a root directory using construct_filepaths(...) . Structure types \"flat\" : A simple one-level mapping from label -> file path. This is the default and most common mode; construct_filepaths_nrecursive will scan a single directory and register all supported files using their stem as label. \"dirlabelled\" : A directory-labelled mode where each top-level directory becomes a label and contains its own mapping of files. This is handled by construct_structured_filepaths and is considered deprecated in favour of the generic construct_filepaths . \"structured\" : Reserved for legacy/experimental layouts; treated as an allowed but user-managed structure type. Validation All paths added to the dataspec are checked for: - Existence on disk. - Being a file (not a directory). - Having an extension in the accepted set ( xlsx , xls , csv , txt , dpt , json ). Two DataSpec instances are considered equal if all their attributes (including filepaths, colours, and metadata) match exactly. Source code in dataspec_manager\\dataspec.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 @decorate_class_with_logging ( log_level = DEBUG ) class DataSpec : \"\"\" Container for experiment metadata and associated data file locations. A `DataSpec` instance describes a single experiment or dataset in terms of: - Basic metadata: name, creation date, experiment date/time, device identifier. - User annotations: free-form notes and a simple time-stamped console log. - File layout: a mapping from human-readable labels to absolute file paths. - Optional colour mapping: label-to-colour mapping for consistent plotting. - Structure type: how files are organised on disk (e.g. flat vs. directory-labelled). The class does *not* interpret the contents of the files; it only tracks their locations and minimal metadata. Filepaths can be: - Added manually via `add_filepath`, or - Auto-populated from a root directory using `construct_filepaths(...)`. Structure types ---------------- - ``\"flat\"``: A simple one-level mapping from label -> file path. This is the default and most common mode; `construct_filepaths_nrecursive` will scan a single directory and register all supported files using their stem as label. - ``\"dirlabelled\"``: A directory-labelled mode where each top-level directory becomes a label and contains its own mapping of files. This is handled by `construct_structured_filepaths` and is considered deprecated in favour of the generic `construct_filepaths`. - ``\"structured\"``: Reserved for legacy/experimental layouts; treated as an allowed but user-managed structure type. Validation ---------- All paths added to the dataspec are checked for: - Existence on disk. - Being a file (not a directory). - Having an extension in the accepted set (``xlsx``, ``xls``, ``csv``, ``txt``, ``dpt``, ``json``). Two `DataSpec` instances are considered equal if all their attributes (including filepaths, colours, and metadata) match exactly. \"\"\" # TODO: properly deprecate structured, assume flat for now _allowed_structure_types = ( \"flat\" , \"dirlabelled\" , \"structured\" ) _accepted_extensions = ( \"xlsx\" , \"xls\" , \"csv\" , \"txt\" , \"dpt\" , \"json\" ) def __init__ ( self , creation_date : str ): if not isinstance ( creation_date , str ): raise ValueError ( \"creation_date must be a string in format YYYY.MM.DD_HH.MM.SS\" ) self . location = None self . name = \"\" self . creation_date = datetime . strptime ( creation_date , \"%Y.%m. %d _%H.%M.%S\" ) self . experiment_date_time = None # FEATURE REQUEST: Allow multiple device types to be compatible with the same set self . device = \"\" self . notes = \"\" self . console = {} self . structure_type = None self . filepaths = {} self . colours = {} # Setters def set_name ( self , name : str ): if not isinstance ( name , str ): raise ValueError ( \"name must be a string\" ) self . name = name def set_experiment_date ( self , experiment_date_time : str ): if not isinstance ( experiment_date_time , str ): raise ValueError ( \"experiment_date_time must be a string in format YYYY.MM.DD_HH.MM.SS\" ) self . experiment_date_time = datetime . strptime ( experiment_date_time , \"%Y.%m. %d _%H.%M.%S\" ) def set_device ( self , device : str ): if not isinstance ( device , str ): raise ValueError ( \"device must be a string\" ) self . device = device def set_structure_type ( self , desired_type : str ): if not desired_type in self . _allowed_structure_types : raise ValueError if self . structure_type is None : self . structure_type = desired_type # Warn users when trying to overwrite the structure type def set_notes ( self , notes_content : str ): if not isinstance ( notes_content , str ): raise ValueError ( \"notes_content must be a string\" ) self . notes = notes_content def set_console ( self , console_content : dict ): if not isinstance ( console_content , dict ): raise ValueError ( \"console_content must be a dict\" ) self . console = console_content def set_filepaths ( self , filepaths : dict ): if not isinstance ( filepaths , dict ): raise ValueError ( \"filepaths must be a dict\" ) self . filepaths = filepaths def set_colours ( self , colours : dict ): if not isinstance ( colours , dict ): raise ValueError ( \"colours must be a dict\" ) self . colours = colours def set_location ( self , location : str ): if not isinstance ( location , str ): raise ValueError ( \"location must be a string/path\" ) self . location = location def construct_filepaths ( self , root_dir : str , type : str ) -> str : warnings . warn ( \"New function construct_filepaths_nrecursive not implemented recursively\" ) # TODO: Should depend on experiment type (making structure redundant)? # TODO: Something about the experiment type compatibility here. if type in self . _allowed_structure_types : self . set_structure_type ( type ) else : return f \"Incompatible structure type ( { type } ). Choose from { self . _allowed_structure_types } \" match type : case \"flat\" : return self . construct_filepaths_nrecursive ( root_dir ) case \"dirlabelled\" : return self . construct_structured_filepaths ( root_dir ) def construct_filepaths_nrecursive ( self , root_dir ) -> str : \"\"\" Will generate a flat file set and add it to the current filepaths. This will seek all files and of the giver root_dir and append all dataspec files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" errors = \"\" # Checks which files are contained in the root dir items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : # Ignores duplicates if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Only add valid files path = f \" { root_dir } / { item } \" is_path_valid , error_msg = self . _check_valid_path ( path ) if is_path_valid : # Use filename as path label self . add_filepath ( path = path , label = Path ( path ) . stem ) else : errors += error_msg return errors def construct_filepaths_recursive ( self , root_dir ) -> str : raise NotImplementedError def construct_structured_filepaths ( self , root_dir : str ) -> str : \"\"\" Will generate a dirlabelled file set and add it to the current filepaths. This will seek all files and subdirectories of the giver root_dir and append all dataspec files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" warnings . warn ( \"Function construct_structured_filepaths is deprecated use construct_filepaths instead\" , DeprecationWarning ) if self . get_structure_type () != \"flat\" : errors = \"\" items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Create nested dict for subdirectories path = f \" { root_dir } / { item } \" if not os . path . isfile ( path ): self . filepaths [ item ] = {} for file in natsort . natsorted ( os . listdir ( path )): # Only append to dataset if file is actually a file with an accepted extension filepath = f \" { path } / { file } \" is_path_valid , error_msg = self . _check_valid_path ( filepath ) if is_path_valid : self . filepaths [ item ][ file ] = filepath else : errors += error_msg else : errors = \"Flat dataspec_manager cannot use dirlabelled construction\" return errors # Getters def get_filepath ( self , label : str ) -> str : return self . filepaths [ label ] def get_filepaths ( self ) -> dict : return self . filepaths def get_experiment_date ( self ): return self . experiment_date_time def get_single_colour ( self , label : str ) -> str : if label in self . colours . keys (): return self . colours [ label ] return None def get_all_colours ( self ) -> dict : if len ( self . colours ) == 0 : return None return self . colours def get_labels ( self ): return self . filepaths . keys () def get_console ( self ) -> dict : return self . console def get_notes ( self ) -> str : return self . notes def get_structure_type ( self ) -> str : return self . structure_type def get_device ( self ) -> str : return self . device def get_creation_date ( self ) -> datetime : return self . creation_date def get_name ( self ) -> str : return self . name def get_location ( self ) -> str | None : if self . location : return self . location return None # Adding / Appending def add_notes ( self , additional_notes : str ): if not isinstance ( additional_notes , str ): raise ValueError ( \"additional_notes must be a string\" ) self . notes += additional_notes def add_console ( self , date_and_time : str , additional_console : str ): if not isinstance ( date_and_time , str ): raise ValueError ( \"date_and_time must be a string\" ) if not isinstance ( additional_console , str ): raise ValueError ( \"additional_console must be a string\" ) self . console [ date_and_time ] = additional_console # Path management def add_filepath ( self , path : str , label : str ): # Wrap flat paths for validation if self . get_structure_type () == 'flat' : path_to_validate = { label : path } else : path_to_validate = path path_to_store = path # Check for duplicate label if label in self . filepaths . keys (): return \"Duplicate label found in dataspec_manager\" # Check that all paths are valid for sublabel in path_to_validate : # Check path before adding: is_path_valid , error_msg = self . _check_valid_path ( path = path_to_validate [ sublabel ]) if not is_path_valid : print ( error_msg ) return \"Will not add file with disallowed extension\" # Add the path self . filepaths [ label ] = path_to_store return \"\" def add_colour ( self , colour : str , label : str ): # Checks for duplicate label if label in self . colours . keys (): return \"Duplicate label found in colours\" else : # Add the file to the dataset and update the gui self . colours [ label ] = colour # Checks are needed before paths are added to the dataspec_manager def _check_valid_path ( self , path : str ): if not isinstance ( path , str ): raise ValueError ( \"path must be a string\" ) # Checks whether the path exists and points to a file if os . path . exists ( path ) and os . path . isfile ( path ): # Checks if the file has the proper extension if path . endswith ( self . _accepted_extensions ): return True , \"\" else : return False , f \"DataSpec Forbidden Extension: Ignored { path } \\n \" elif os . path . exists ( path ) and not os . path . isfile ( path ): return False , f \"DataSpec Not a File: Ignored { path } \\n \" else : return False , f \"DataSpec Filesystem Error: Ignored { path } \\n \" def __eq__ ( self , other ): if type ( other ) is type ( self ): return self . __dict__ == other . __dict__ return False construct_filepaths_nrecursive ( root_dir ) Will generate a flat file set and add it to the current filepaths. This will seek all files and of the giver root_dir and append all dataspec files to the filepaths attribute. Note that root_dir should be an absolute path. Source code in dataspec_manager\\dataspec.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def construct_filepaths_nrecursive ( self , root_dir ) -> str : \"\"\" Will generate a flat file set and add it to the current filepaths. This will seek all files and of the giver root_dir and append all dataspec files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" errors = \"\" # Checks which files are contained in the root dir items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : # Ignores duplicates if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Only add valid files path = f \" { root_dir } / { item } \" is_path_valid , error_msg = self . _check_valid_path ( path ) if is_path_valid : # Use filename as path label self . add_filepath ( path = path , label = Path ( path ) . stem ) else : errors += error_msg return errors construct_structured_filepaths ( root_dir ) Will generate a dirlabelled file set and add it to the current filepaths. This will seek all files and subdirectories of the giver root_dir and append all dataspec files to the filepaths attribute. Note that root_dir should be an absolute path. Source code in dataspec_manager\\dataspec.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def construct_structured_filepaths ( self , root_dir : str ) -> str : \"\"\" Will generate a dirlabelled file set and add it to the current filepaths. This will seek all files and subdirectories of the giver root_dir and append all dataspec files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" warnings . warn ( \"Function construct_structured_filepaths is deprecated use construct_filepaths instead\" , DeprecationWarning ) if self . get_structure_type () != \"flat\" : errors = \"\" items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Create nested dict for subdirectories path = f \" { root_dir } / { item } \" if not os . path . isfile ( path ): self . filepaths [ item ] = {} for file in natsort . natsorted ( os . listdir ( path )): # Only append to dataset if file is actually a file with an accepted extension filepath = f \" { path } / { file } \" is_path_valid , error_msg = self . _check_valid_path ( filepath ) if is_path_valid : self . filepaths [ item ][ file ] = filepath else : errors += error_msg else : errors = \"Flat dataspec_manager cannot use dirlabelled construction\" return errors Bases: JSONEncoder JSON encoder for DataSpec objects and related dataclasses. This encoder provides two custom behaviours: datetime.datetime instances are serialised to a compact string representation using the format \"%Y.%m.%d_%H.%M.%S\" . This matches the format expected by DataSpec and the corresponding JSON decoder. All other objects are serialised via their __dict__ attribute, which is sufficient for simple container-like classes such as DataSpec . The encoder is intended to be used together with DataSpecJSONDecoder to provide a round-trip-safe JSON representation of dataspecs. Source code in dataspec_manager\\dataspec_json_encoder.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @decorate_class_with_logging ( log_level = DEBUG ) class DataSpecJSONEncoder ( JSONEncoder ): \"\"\" JSON encoder for `DataSpec` objects and related dataclasses. This encoder provides two custom behaviours: - ``datetime.datetime`` instances are serialised to a compact string representation using the format ``\"%Y.%m.%d_%H.%M.%S\"``. This matches the format expected by `DataSpec` and the corresponding JSON decoder. - All other objects are serialised via their ``__dict__`` attribute, which is sufficient for simple container-like classes such as `DataSpec`. The encoder is intended to be used together with `DataSpecJSONDecoder` to provide a round-trip-safe JSON representation of dataspecs. \"\"\" def default ( self , o ): if isinstance ( o , datetime . datetime ): return o . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) else : return o . __dict__ Bases: JSONDecoder Custom JSON decoder that reconstructs DataSpec instances from JSON. This decoder installs an object_hook that: - Detects dictionaries carrying the expected DataSpec fields (e.g. creation_date , name , device , experiment_date_time , notes , console , structure_type , filepaths , colours ). - Instantiates a new DataSpec using the stored creation date. - Replays all relevant setters to restore metadata, structure type, paths, colours, and annotations. If a JSON object does not match the expected shape, it is returned unchanged, allowing non- DataSpec data to be decoded normally. Source code in dataspec_manager\\dataspec_json_decoder.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @decorate_class_with_logging ( log_level = DEBUG ) class DataSpecJSONDecoder ( JSONDecoder ): \"\"\" Custom JSON decoder that reconstructs `DataSpec` instances from JSON. This decoder installs an `object_hook` that: - Detects dictionaries carrying the expected `DataSpec` fields (e.g. ``creation_date``, ``name``, ``device``, ``experiment_date_time``, ``notes``, ``console``, ``structure_type``, ``filepaths``, ``colours``). - Instantiates a new `DataSpec` using the stored creation date. - Replays all relevant setters to restore metadata, structure type, paths, colours, and annotations. If a JSON object does not match the expected shape, it is returned unchanged, allowing non-`DataSpec` data to be decoded normally. \"\"\" def __init__ ( self , ** kwargs ): kwargs . setdefault ( \"object_hook\" , self . object_hook ) super () . __init__ ( ** kwargs ) @staticmethod def object_hook ( dct ): try : dataspec = DataSpec ( dct [ 'creation_date' ]) dataspec . set_name ( dct [ 'name' ]) dataspec . set_device ( dct [ 'device' ]) dataspec . set_experiment_date ( dct [ 'experiment_date_time' ]) dataspec . set_notes ( dct [ 'notes' ]) dataspec . set_console ( dct [ 'console' ]) dataspec . set_structure_type ( dct [ 'structure_type' ]) dataspec . set_filepaths ( dct [ 'filepaths' ]) dataspec . set_colours ( dct [ 'colours' ]) return dataspec except KeyError : return dct Small helper class for persisting DataSpec instances to and from JSON files. Responsibilities save_dataspec(dataspec, file_name) : Serialises a DataSpec instance to disk using DataSpecJSONEncoder . The method checks that the passed object is a DataSpec and writes the encoded JSON to the given file path. open_dataspec(file_name) : Opens a JSON file and deserialises it into a DataSpec instance using DataSpecJSONDecoder . The manager does not interpret the dataspec content; it only handles the IO and wiring between JSON encoder/decoder and the underlying DataSpec objects. Source code in dataspec_manager\\dataspec_manager.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @decorate_class_with_logging ( log_level = DEBUG ) class DataSpecManager : \"\"\" Small helper class for persisting `DataSpec` instances to and from JSON files. Responsibilities ---------------- - `save_dataspec(dataspec, file_name)`: Serialises a `DataSpec` instance to disk using `DataSpecJSONEncoder`. The method checks that the passed object is a `DataSpec` and writes the encoded JSON to the given file path. - `open_dataspec(file_name)`: Opens a JSON file and deserialises it into a `DataSpec` instance using `DataSpecJSONDecoder`. The manager does not interpret the dataspec content; it only handles the IO and wiring between JSON encoder/decoder and the underlying `DataSpec` objects. \"\"\" def __init__ ( self ): pass @staticmethod def save_dataspec ( dataspec , file_name ): \"\"\" Saves the dataspec_manager data into a JSON file \"\"\" if not isinstance ( dataspec , DataSpec ): raise ValueError ( \"dataspec must be an instance of DataSpec\" ) # Who should check whether the filename is valid? with open ( file_name , \"w\" ) as json_file : json . dump ( dataspec , json_file , cls = DataSpecJSONEncoder ) json_file . close () @staticmethod def open_dataspec ( file_name ): with open ( file_name ) as json_file : return json . load ( json_file , cls = DataSpecJSONDecoder ) save_dataspec ( dataspec , file_name ) staticmethod Saves the dataspec_manager data into a JSON file Source code in dataspec_manager\\dataspec_manager.py 29 30 31 32 33 34 35 36 37 38 @staticmethod def save_dataspec ( dataspec , file_name ): \"\"\" Saves the dataspec_manager data into a JSON file \"\"\" if not isinstance ( dataspec , DataSpec ): raise ValueError ( \"dataspec must be an instance of DataSpec\" ) # Who should check whether the filename is valid? with open ( file_name , \"w\" ) as json_file : json . dump ( dataspec , json_file , cls = DataSpecJSONEncoder ) json_file . close ()","title":"DataSpec"},{"location":"api/dataspec_manager/#dataspec-manager-api-documentation","text":"Container for experiment metadata and associated data file locations. A DataSpec instance describes a single experiment or dataset in terms of: - Basic metadata: name, creation date, experiment date/time, device identifier. - User annotations: free-form notes and a simple time-stamped console log. - File layout: a mapping from human-readable labels to absolute file paths. - Optional colour mapping: label-to-colour mapping for consistent plotting. - Structure type: how files are organised on disk (e.g. flat vs. directory-labelled). The class does not interpret the contents of the files; it only tracks their locations and minimal metadata. Filepaths can be: - Added manually via add_filepath , or - Auto-populated from a root directory using construct_filepaths(...) .","title":"DataSpec Manager API Documentation"},{"location":"api/dataspec_manager/#dataspec_manager.dataspec.DataSpec--structure-types","text":"\"flat\" : A simple one-level mapping from label -> file path. This is the default and most common mode; construct_filepaths_nrecursive will scan a single directory and register all supported files using their stem as label. \"dirlabelled\" : A directory-labelled mode where each top-level directory becomes a label and contains its own mapping of files. This is handled by construct_structured_filepaths and is considered deprecated in favour of the generic construct_filepaths . \"structured\" : Reserved for legacy/experimental layouts; treated as an allowed but user-managed structure type.","title":"Structure types"},{"location":"api/dataspec_manager/#dataspec_manager.dataspec.DataSpec--validation","text":"All paths added to the dataspec are checked for: - Existence on disk. - Being a file (not a directory). - Having an extension in the accepted set ( xlsx , xls , csv , txt , dpt , json ). Two DataSpec instances are considered equal if all their attributes (including filepaths, colours, and metadata) match exactly. Source code in dataspec_manager\\dataspec.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 @decorate_class_with_logging ( log_level = DEBUG ) class DataSpec : \"\"\" Container for experiment metadata and associated data file locations. A `DataSpec` instance describes a single experiment or dataset in terms of: - Basic metadata: name, creation date, experiment date/time, device identifier. - User annotations: free-form notes and a simple time-stamped console log. - File layout: a mapping from human-readable labels to absolute file paths. - Optional colour mapping: label-to-colour mapping for consistent plotting. - Structure type: how files are organised on disk (e.g. flat vs. directory-labelled). The class does *not* interpret the contents of the files; it only tracks their locations and minimal metadata. Filepaths can be: - Added manually via `add_filepath`, or - Auto-populated from a root directory using `construct_filepaths(...)`. Structure types ---------------- - ``\"flat\"``: A simple one-level mapping from label -> file path. This is the default and most common mode; `construct_filepaths_nrecursive` will scan a single directory and register all supported files using their stem as label. - ``\"dirlabelled\"``: A directory-labelled mode where each top-level directory becomes a label and contains its own mapping of files. This is handled by `construct_structured_filepaths` and is considered deprecated in favour of the generic `construct_filepaths`. - ``\"structured\"``: Reserved for legacy/experimental layouts; treated as an allowed but user-managed structure type. Validation ---------- All paths added to the dataspec are checked for: - Existence on disk. - Being a file (not a directory). - Having an extension in the accepted set (``xlsx``, ``xls``, ``csv``, ``txt``, ``dpt``, ``json``). Two `DataSpec` instances are considered equal if all their attributes (including filepaths, colours, and metadata) match exactly. \"\"\" # TODO: properly deprecate structured, assume flat for now _allowed_structure_types = ( \"flat\" , \"dirlabelled\" , \"structured\" ) _accepted_extensions = ( \"xlsx\" , \"xls\" , \"csv\" , \"txt\" , \"dpt\" , \"json\" ) def __init__ ( self , creation_date : str ): if not isinstance ( creation_date , str ): raise ValueError ( \"creation_date must be a string in format YYYY.MM.DD_HH.MM.SS\" ) self . location = None self . name = \"\" self . creation_date = datetime . strptime ( creation_date , \"%Y.%m. %d _%H.%M.%S\" ) self . experiment_date_time = None # FEATURE REQUEST: Allow multiple device types to be compatible with the same set self . device = \"\" self . notes = \"\" self . console = {} self . structure_type = None self . filepaths = {} self . colours = {} # Setters def set_name ( self , name : str ): if not isinstance ( name , str ): raise ValueError ( \"name must be a string\" ) self . name = name def set_experiment_date ( self , experiment_date_time : str ): if not isinstance ( experiment_date_time , str ): raise ValueError ( \"experiment_date_time must be a string in format YYYY.MM.DD_HH.MM.SS\" ) self . experiment_date_time = datetime . strptime ( experiment_date_time , \"%Y.%m. %d _%H.%M.%S\" ) def set_device ( self , device : str ): if not isinstance ( device , str ): raise ValueError ( \"device must be a string\" ) self . device = device def set_structure_type ( self , desired_type : str ): if not desired_type in self . _allowed_structure_types : raise ValueError if self . structure_type is None : self . structure_type = desired_type # Warn users when trying to overwrite the structure type def set_notes ( self , notes_content : str ): if not isinstance ( notes_content , str ): raise ValueError ( \"notes_content must be a string\" ) self . notes = notes_content def set_console ( self , console_content : dict ): if not isinstance ( console_content , dict ): raise ValueError ( \"console_content must be a dict\" ) self . console = console_content def set_filepaths ( self , filepaths : dict ): if not isinstance ( filepaths , dict ): raise ValueError ( \"filepaths must be a dict\" ) self . filepaths = filepaths def set_colours ( self , colours : dict ): if not isinstance ( colours , dict ): raise ValueError ( \"colours must be a dict\" ) self . colours = colours def set_location ( self , location : str ): if not isinstance ( location , str ): raise ValueError ( \"location must be a string/path\" ) self . location = location def construct_filepaths ( self , root_dir : str , type : str ) -> str : warnings . warn ( \"New function construct_filepaths_nrecursive not implemented recursively\" ) # TODO: Should depend on experiment type (making structure redundant)? # TODO: Something about the experiment type compatibility here. if type in self . _allowed_structure_types : self . set_structure_type ( type ) else : return f \"Incompatible structure type ( { type } ). Choose from { self . _allowed_structure_types } \" match type : case \"flat\" : return self . construct_filepaths_nrecursive ( root_dir ) case \"dirlabelled\" : return self . construct_structured_filepaths ( root_dir ) def construct_filepaths_nrecursive ( self , root_dir ) -> str : \"\"\" Will generate a flat file set and add it to the current filepaths. This will seek all files and of the giver root_dir and append all dataspec files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" errors = \"\" # Checks which files are contained in the root dir items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : # Ignores duplicates if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Only add valid files path = f \" { root_dir } / { item } \" is_path_valid , error_msg = self . _check_valid_path ( path ) if is_path_valid : # Use filename as path label self . add_filepath ( path = path , label = Path ( path ) . stem ) else : errors += error_msg return errors def construct_filepaths_recursive ( self , root_dir ) -> str : raise NotImplementedError def construct_structured_filepaths ( self , root_dir : str ) -> str : \"\"\" Will generate a dirlabelled file set and add it to the current filepaths. This will seek all files and subdirectories of the giver root_dir and append all dataspec files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" warnings . warn ( \"Function construct_structured_filepaths is deprecated use construct_filepaths instead\" , DeprecationWarning ) if self . get_structure_type () != \"flat\" : errors = \"\" items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Create nested dict for subdirectories path = f \" { root_dir } / { item } \" if not os . path . isfile ( path ): self . filepaths [ item ] = {} for file in natsort . natsorted ( os . listdir ( path )): # Only append to dataset if file is actually a file with an accepted extension filepath = f \" { path } / { file } \" is_path_valid , error_msg = self . _check_valid_path ( filepath ) if is_path_valid : self . filepaths [ item ][ file ] = filepath else : errors += error_msg else : errors = \"Flat dataspec_manager cannot use dirlabelled construction\" return errors # Getters def get_filepath ( self , label : str ) -> str : return self . filepaths [ label ] def get_filepaths ( self ) -> dict : return self . filepaths def get_experiment_date ( self ): return self . experiment_date_time def get_single_colour ( self , label : str ) -> str : if label in self . colours . keys (): return self . colours [ label ] return None def get_all_colours ( self ) -> dict : if len ( self . colours ) == 0 : return None return self . colours def get_labels ( self ): return self . filepaths . keys () def get_console ( self ) -> dict : return self . console def get_notes ( self ) -> str : return self . notes def get_structure_type ( self ) -> str : return self . structure_type def get_device ( self ) -> str : return self . device def get_creation_date ( self ) -> datetime : return self . creation_date def get_name ( self ) -> str : return self . name def get_location ( self ) -> str | None : if self . location : return self . location return None # Adding / Appending def add_notes ( self , additional_notes : str ): if not isinstance ( additional_notes , str ): raise ValueError ( \"additional_notes must be a string\" ) self . notes += additional_notes def add_console ( self , date_and_time : str , additional_console : str ): if not isinstance ( date_and_time , str ): raise ValueError ( \"date_and_time must be a string\" ) if not isinstance ( additional_console , str ): raise ValueError ( \"additional_console must be a string\" ) self . console [ date_and_time ] = additional_console # Path management def add_filepath ( self , path : str , label : str ): # Wrap flat paths for validation if self . get_structure_type () == 'flat' : path_to_validate = { label : path } else : path_to_validate = path path_to_store = path # Check for duplicate label if label in self . filepaths . keys (): return \"Duplicate label found in dataspec_manager\" # Check that all paths are valid for sublabel in path_to_validate : # Check path before adding: is_path_valid , error_msg = self . _check_valid_path ( path = path_to_validate [ sublabel ]) if not is_path_valid : print ( error_msg ) return \"Will not add file with disallowed extension\" # Add the path self . filepaths [ label ] = path_to_store return \"\" def add_colour ( self , colour : str , label : str ): # Checks for duplicate label if label in self . colours . keys (): return \"Duplicate label found in colours\" else : # Add the file to the dataset and update the gui self . colours [ label ] = colour # Checks are needed before paths are added to the dataspec_manager def _check_valid_path ( self , path : str ): if not isinstance ( path , str ): raise ValueError ( \"path must be a string\" ) # Checks whether the path exists and points to a file if os . path . exists ( path ) and os . path . isfile ( path ): # Checks if the file has the proper extension if path . endswith ( self . _accepted_extensions ): return True , \"\" else : return False , f \"DataSpec Forbidden Extension: Ignored { path } \\n \" elif os . path . exists ( path ) and not os . path . isfile ( path ): return False , f \"DataSpec Not a File: Ignored { path } \\n \" else : return False , f \"DataSpec Filesystem Error: Ignored { path } \\n \" def __eq__ ( self , other ): if type ( other ) is type ( self ): return self . __dict__ == other . __dict__ return False","title":"Validation"},{"location":"api/dataspec_manager/#dataspec_manager.dataspec.DataSpec.construct_filepaths_nrecursive","text":"Will generate a flat file set and add it to the current filepaths. This will seek all files and of the giver root_dir and append all dataspec files to the filepaths attribute. Note that root_dir should be an absolute path. Source code in dataspec_manager\\dataspec.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def construct_filepaths_nrecursive ( self , root_dir ) -> str : \"\"\" Will generate a flat file set and add it to the current filepaths. This will seek all files and of the giver root_dir and append all dataspec files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" errors = \"\" # Checks which files are contained in the root dir items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : # Ignores duplicates if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Only add valid files path = f \" { root_dir } / { item } \" is_path_valid , error_msg = self . _check_valid_path ( path ) if is_path_valid : # Use filename as path label self . add_filepath ( path = path , label = Path ( path ) . stem ) else : errors += error_msg return errors","title":"construct_filepaths_nrecursive"},{"location":"api/dataspec_manager/#dataspec_manager.dataspec.DataSpec.construct_structured_filepaths","text":"Will generate a dirlabelled file set and add it to the current filepaths. This will seek all files and subdirectories of the giver root_dir and append all dataspec files to the filepaths attribute. Note that root_dir should be an absolute path. Source code in dataspec_manager\\dataspec.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def construct_structured_filepaths ( self , root_dir : str ) -> str : \"\"\" Will generate a dirlabelled file set and add it to the current filepaths. This will seek all files and subdirectories of the giver root_dir and append all dataspec files to the filepaths attribute. Note that root_dir should be an absolute path. \"\"\" warnings . warn ( \"Function construct_structured_filepaths is deprecated use construct_filepaths instead\" , DeprecationWarning ) if self . get_structure_type () != \"flat\" : errors = \"\" items = natsort . natsorted ( os . listdir ( root_dir )) for item in items : if item in self . filepaths . keys (): errors += f \"Ignored { item } : duplicate label \\n \" continue # Create nested dict for subdirectories path = f \" { root_dir } / { item } \" if not os . path . isfile ( path ): self . filepaths [ item ] = {} for file in natsort . natsorted ( os . listdir ( path )): # Only append to dataset if file is actually a file with an accepted extension filepath = f \" { path } / { file } \" is_path_valid , error_msg = self . _check_valid_path ( filepath ) if is_path_valid : self . filepaths [ item ][ file ] = filepath else : errors += error_msg else : errors = \"Flat dataspec_manager cannot use dirlabelled construction\" return errors Bases: JSONEncoder JSON encoder for DataSpec objects and related dataclasses. This encoder provides two custom behaviours: datetime.datetime instances are serialised to a compact string representation using the format \"%Y.%m.%d_%H.%M.%S\" . This matches the format expected by DataSpec and the corresponding JSON decoder. All other objects are serialised via their __dict__ attribute, which is sufficient for simple container-like classes such as DataSpec . The encoder is intended to be used together with DataSpecJSONDecoder to provide a round-trip-safe JSON representation of dataspecs. Source code in dataspec_manager\\dataspec_json_encoder.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @decorate_class_with_logging ( log_level = DEBUG ) class DataSpecJSONEncoder ( JSONEncoder ): \"\"\" JSON encoder for `DataSpec` objects and related dataclasses. This encoder provides two custom behaviours: - ``datetime.datetime`` instances are serialised to a compact string representation using the format ``\"%Y.%m.%d_%H.%M.%S\"``. This matches the format expected by `DataSpec` and the corresponding JSON decoder. - All other objects are serialised via their ``__dict__`` attribute, which is sufficient for simple container-like classes such as `DataSpec`. The encoder is intended to be used together with `DataSpecJSONDecoder` to provide a round-trip-safe JSON representation of dataspecs. \"\"\" def default ( self , o ): if isinstance ( o , datetime . datetime ): return o . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) else : return o . __dict__ Bases: JSONDecoder Custom JSON decoder that reconstructs DataSpec instances from JSON. This decoder installs an object_hook that: - Detects dictionaries carrying the expected DataSpec fields (e.g. creation_date , name , device , experiment_date_time , notes , console , structure_type , filepaths , colours ). - Instantiates a new DataSpec using the stored creation date. - Replays all relevant setters to restore metadata, structure type, paths, colours, and annotations. If a JSON object does not match the expected shape, it is returned unchanged, allowing non- DataSpec data to be decoded normally. Source code in dataspec_manager\\dataspec_json_decoder.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @decorate_class_with_logging ( log_level = DEBUG ) class DataSpecJSONDecoder ( JSONDecoder ): \"\"\" Custom JSON decoder that reconstructs `DataSpec` instances from JSON. This decoder installs an `object_hook` that: - Detects dictionaries carrying the expected `DataSpec` fields (e.g. ``creation_date``, ``name``, ``device``, ``experiment_date_time``, ``notes``, ``console``, ``structure_type``, ``filepaths``, ``colours``). - Instantiates a new `DataSpec` using the stored creation date. - Replays all relevant setters to restore metadata, structure type, paths, colours, and annotations. If a JSON object does not match the expected shape, it is returned unchanged, allowing non-`DataSpec` data to be decoded normally. \"\"\" def __init__ ( self , ** kwargs ): kwargs . setdefault ( \"object_hook\" , self . object_hook ) super () . __init__ ( ** kwargs ) @staticmethod def object_hook ( dct ): try : dataspec = DataSpec ( dct [ 'creation_date' ]) dataspec . set_name ( dct [ 'name' ]) dataspec . set_device ( dct [ 'device' ]) dataspec . set_experiment_date ( dct [ 'experiment_date_time' ]) dataspec . set_notes ( dct [ 'notes' ]) dataspec . set_console ( dct [ 'console' ]) dataspec . set_structure_type ( dct [ 'structure_type' ]) dataspec . set_filepaths ( dct [ 'filepaths' ]) dataspec . set_colours ( dct [ 'colours' ]) return dataspec except KeyError : return dct Small helper class for persisting DataSpec instances to and from JSON files.","title":"construct_structured_filepaths"},{"location":"api/dataspec_manager/#dataspec_manager.dataspec_manager.DataSpecManager--responsibilities","text":"save_dataspec(dataspec, file_name) : Serialises a DataSpec instance to disk using DataSpecJSONEncoder . The method checks that the passed object is a DataSpec and writes the encoded JSON to the given file path. open_dataspec(file_name) : Opens a JSON file and deserialises it into a DataSpec instance using DataSpecJSONDecoder . The manager does not interpret the dataspec content; it only handles the IO and wiring between JSON encoder/decoder and the underlying DataSpec objects. Source code in dataspec_manager\\dataspec_manager.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @decorate_class_with_logging ( log_level = DEBUG ) class DataSpecManager : \"\"\" Small helper class for persisting `DataSpec` instances to and from JSON files. Responsibilities ---------------- - `save_dataspec(dataspec, file_name)`: Serialises a `DataSpec` instance to disk using `DataSpecJSONEncoder`. The method checks that the passed object is a `DataSpec` and writes the encoded JSON to the given file path. - `open_dataspec(file_name)`: Opens a JSON file and deserialises it into a `DataSpec` instance using `DataSpecJSONDecoder`. The manager does not interpret the dataspec content; it only handles the IO and wiring between JSON encoder/decoder and the underlying `DataSpec` objects. \"\"\" def __init__ ( self ): pass @staticmethod def save_dataspec ( dataspec , file_name ): \"\"\" Saves the dataspec_manager data into a JSON file \"\"\" if not isinstance ( dataspec , DataSpec ): raise ValueError ( \"dataspec must be an instance of DataSpec\" ) # Who should check whether the filename is valid? with open ( file_name , \"w\" ) as json_file : json . dump ( dataspec , json_file , cls = DataSpecJSONEncoder ) json_file . close () @staticmethod def open_dataspec ( file_name ): with open ( file_name ) as json_file : return json . load ( json_file , cls = DataSpecJSONDecoder )","title":"Responsibilities"},{"location":"api/dataspec_manager/#dataspec_manager.dataspec_manager.DataSpecManager.save_dataspec","text":"Saves the dataspec_manager data into a JSON file Source code in dataspec_manager\\dataspec_manager.py 29 30 31 32 33 34 35 36 37 38 @staticmethod def save_dataspec ( dataspec , file_name ): \"\"\" Saves the dataspec_manager data into a JSON file \"\"\" if not isinstance ( dataspec , DataSpec ): raise ValueError ( \"dataspec must be an instance of DataSpec\" ) # Who should check whether the filename is valid? with open ( file_name , \"w\" ) as json_file : json . dump ( dataspec , json_file , cls = DataSpecJSONEncoder ) json_file . close ()","title":"save_dataspec"},{"location":"api/contracts/devices/","text":"Devices Bases: type ( ABC ) , type ( QObject ) Metaclass enabling multiple inheritance of ABC and QObject. Overview Resolves metaclass conflicts so DeviceWorker can be both an ABC and a Qt QObject. Combines behavior of ABC and QtCore.QObject metatypes. Usage Notes Use this metaclass only for worker classes that inherit from QObject. Source code in contracts\\device_worker.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class WorkerMeta ( type ( ABC ), type ( QtCore . QObject )): \"\"\" Metaclass enabling multiple inheritance of ABC and QObject. Overview: Resolves metaclass conflicts so `DeviceWorker` can be both an ABC and a Qt QObject. - Combines behavior of `ABC` and `QtCore.QObject` metatypes. Usage Notes: Use this metaclass only for worker classes that inherit from QObject. \"\"\" pass Bases: ABC , QObject Abstract base for device worker objects that run in a Qt context. Overview Defines the required API for workers that accept a DataSpec, run a task, and accept data/processor types. Required methods: set_data, run, set_data_type, set_processor_type. Provides a short identifier used for run labelling. Usage Notes Concrete workers should implement thread-safe run logic and emit signals. Source code in contracts\\device_worker.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class DeviceWorker ( ABC , QtCore . QObject , metaclass = WorkerMeta ): \"\"\" Abstract base for device worker objects that run in a Qt context. Overview: Defines the required API for workers that accept a DataSpec, run a task, and accept data/processor types. - Required methods: set_data, run, set_data_type, set_processor_type. - Provides a short `identifier` used for run labelling. Usage Notes: Concrete workers should implement thread-safe run logic and emit signals. \"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . identifier = str ( uuid . uuid4 ())[: 4 ] @abstractmethod def set_data ( self , dataspec : DataSpec ): pass @abstractmethod def run ( self ): pass @abstractmethod def set_data_type ( self , data_type ): pass @abstractmethod def set_processor_type ( self , processor_type ): pass Bases: DeviceWorker Concrete worker base implementing common setup and progress handling. Overview Implements option handling, dataset instantiation and a simple run flow that prepares data processors, emits progress, and calls a plot. Manages device , dataspec , plot_type , options , and data_processors . Populates processors per-file and emits progress / finished signals. set_data_type / set_processor_type are simple setters. Usage Notes Subclasses provide plotting methods referenced by plot_type and may extend run behaviour if needed. Source code in contracts\\device_worker.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 @decorate_class_with_logging ( log_level = DEBUG_WORKER ) class DeviceWorkerCore ( DeviceWorker ): \"\"\" Concrete worker base implementing common setup and progress handling. Overview: Implements option handling, dataset instantiation and a simple run flow that prepares data processors, emits progress, and calls a plot. - Manages `device`, `dataspec`, `plot_type`, `options`, and `data_processors`. - Populates processors per-file and emits `progress`/`finished` signals. - `set_data_type` / `set_processor_type` are simple setters. Usage Notes: Subclasses provide plotting methods referenced by `plot_type` and may extend run behaviour if needed. \"\"\" finished = QtCore . pyqtSignal () progress = QtCore . pyqtSignal ( int ) def __init__ ( self , device , dataspec , plot_type , options : PlotterOptions ): super () . __init__ () self . device = device self . dataspec = dataspec self . plot_type = plot_type self . options = options self . options . add_option ( label = \"experiment_datetime\" , value = dataspec . get_experiment_date ()) self . data_processors = None self . processor_type = None self . data_type = None def set_data_type ( self , data_type ): if not issubclass ( data_type , Data ): raise TypeError ( \"data_type must be a subclass of Data\" ) self . data_type = data_type def set_processor_type ( self , processor_type ): if not issubclass ( processor_type , DataProcessor ): raise TypeError ( \"processor_type must be a subclass of DataProcessor\" ) self . processor_type = processor_type def set_data ( self , dataspec : DataSpec ): if not isinstance ( dataspec , DataSpec ): raise TypeError ( \"dataspec must be an instance of DataSpec\" ) # CHECK: Check that dataspec and processor types have been set # Initialise an empty dict and get the required filepaths self . data_processors = {} filepaths = dataspec . get_filepaths () colours = dataspec . get_all_colours () if colours is not None : self . options . add_option ( label = \"colours\" , value = colours ) # Progress housekeeping nr_of_files = len ( filepaths ) counter = 0 # Read the dataspec and instantiate a processor for each file for key in filepaths : data = self . data_type ( key ) data . read_file ( filepaths [ key ]) self . data_processors [ key ] = self . processor_type ( data ) # Emit progress signal counter += 1 self . progress . emit ( int ( 100 * counter / nr_of_files )) def run ( self ): # Set the data self . set_data ( self . dataspec ) # Grab the correct plot and execute it, including uuid in the title title = f \" { self . dataspec . get_name () } (run { self . identifier } )\" plot_type = getattr ( self , self . plot_type ) plot_type ( title = title ) self . finished . emit ()","title":"Contracts - Devices"},{"location":"api/contracts/devices/#devices","text":"Bases: type ( ABC ) , type ( QObject ) Metaclass enabling multiple inheritance of ABC and QObject. Overview Resolves metaclass conflicts so DeviceWorker can be both an ABC and a Qt QObject. Combines behavior of ABC and QtCore.QObject metatypes. Usage Notes Use this metaclass only for worker classes that inherit from QObject. Source code in contracts\\device_worker.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class WorkerMeta ( type ( ABC ), type ( QtCore . QObject )): \"\"\" Metaclass enabling multiple inheritance of ABC and QObject. Overview: Resolves metaclass conflicts so `DeviceWorker` can be both an ABC and a Qt QObject. - Combines behavior of `ABC` and `QtCore.QObject` metatypes. Usage Notes: Use this metaclass only for worker classes that inherit from QObject. \"\"\" pass Bases: ABC , QObject Abstract base for device worker objects that run in a Qt context. Overview Defines the required API for workers that accept a DataSpec, run a task, and accept data/processor types. Required methods: set_data, run, set_data_type, set_processor_type. Provides a short identifier used for run labelling. Usage Notes Concrete workers should implement thread-safe run logic and emit signals. Source code in contracts\\device_worker.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class DeviceWorker ( ABC , QtCore . QObject , metaclass = WorkerMeta ): \"\"\" Abstract base for device worker objects that run in a Qt context. Overview: Defines the required API for workers that accept a DataSpec, run a task, and accept data/processor types. - Required methods: set_data, run, set_data_type, set_processor_type. - Provides a short `identifier` used for run labelling. Usage Notes: Concrete workers should implement thread-safe run logic and emit signals. \"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . identifier = str ( uuid . uuid4 ())[: 4 ] @abstractmethod def set_data ( self , dataspec : DataSpec ): pass @abstractmethod def run ( self ): pass @abstractmethod def set_data_type ( self , data_type ): pass @abstractmethod def set_processor_type ( self , processor_type ): pass Bases: DeviceWorker Concrete worker base implementing common setup and progress handling. Overview Implements option handling, dataset instantiation and a simple run flow that prepares data processors, emits progress, and calls a plot. Manages device , dataspec , plot_type , options , and data_processors . Populates processors per-file and emits progress / finished signals. set_data_type / set_processor_type are simple setters. Usage Notes Subclasses provide plotting methods referenced by plot_type and may extend run behaviour if needed. Source code in contracts\\device_worker.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 @decorate_class_with_logging ( log_level = DEBUG_WORKER ) class DeviceWorkerCore ( DeviceWorker ): \"\"\" Concrete worker base implementing common setup and progress handling. Overview: Implements option handling, dataset instantiation and a simple run flow that prepares data processors, emits progress, and calls a plot. - Manages `device`, `dataspec`, `plot_type`, `options`, and `data_processors`. - Populates processors per-file and emits `progress`/`finished` signals. - `set_data_type` / `set_processor_type` are simple setters. Usage Notes: Subclasses provide plotting methods referenced by `plot_type` and may extend run behaviour if needed. \"\"\" finished = QtCore . pyqtSignal () progress = QtCore . pyqtSignal ( int ) def __init__ ( self , device , dataspec , plot_type , options : PlotterOptions ): super () . __init__ () self . device = device self . dataspec = dataspec self . plot_type = plot_type self . options = options self . options . add_option ( label = \"experiment_datetime\" , value = dataspec . get_experiment_date ()) self . data_processors = None self . processor_type = None self . data_type = None def set_data_type ( self , data_type ): if not issubclass ( data_type , Data ): raise TypeError ( \"data_type must be a subclass of Data\" ) self . data_type = data_type def set_processor_type ( self , processor_type ): if not issubclass ( processor_type , DataProcessor ): raise TypeError ( \"processor_type must be a subclass of DataProcessor\" ) self . processor_type = processor_type def set_data ( self , dataspec : DataSpec ): if not isinstance ( dataspec , DataSpec ): raise TypeError ( \"dataspec must be an instance of DataSpec\" ) # CHECK: Check that dataspec and processor types have been set # Initialise an empty dict and get the required filepaths self . data_processors = {} filepaths = dataspec . get_filepaths () colours = dataspec . get_all_colours () if colours is not None : self . options . add_option ( label = \"colours\" , value = colours ) # Progress housekeeping nr_of_files = len ( filepaths ) counter = 0 # Read the dataspec and instantiate a processor for each file for key in filepaths : data = self . data_type ( key ) data . read_file ( filepaths [ key ]) self . data_processors [ key ] = self . processor_type ( data ) # Emit progress signal counter += 1 self . progress . emit ( int ( 100 * counter / nr_of_files )) def run ( self ): # Set the data self . set_data ( self . dataspec ) # Grab the correct plot and execute it, including uuid in the title title = f \" { self . dataspec . get_name () } (run { self . identifier } )\" plot_type = getattr ( self , self . plot_type ) plot_type ( title = title ) self . finished . emit ()","title":"Devices"},{"location":"api/contracts/file_readers/","text":"File Readers File reader contracts for use by DataCore and DataProcessingCore. Defines the canonical function signature and return type used by all file readers in the X-LAB plotting ecosystem. A file reader is any callable matching FileReaderFn : (path: str) -> ReaderOutput Responsibilities Open and parse a file at the given path. Return structured raw data as a mapping of semantic keys (e.g. \"x_axis\", \"y_axis\", \"current\", \"meta\") to Python objects. Perform no higher-level processing or conversion to observables.","title":"Contracts - File Readers"},{"location":"api/contracts/file_readers/#file-readers","text":"File reader contracts for use by DataCore and DataProcessingCore. Defines the canonical function signature and return type used by all file readers in the X-LAB plotting ecosystem. A file reader is any callable matching FileReaderFn : (path: str) -> ReaderOutput Responsibilities Open and parse a file at the given path. Return structured raw data as a mapping of semantic keys (e.g. \"x_axis\", \"y_axis\", \"current\", \"meta\") to Python objects. Perform no higher-level processing or conversion to observables.","title":"File Readers"},{"location":"api/contracts/observable/","text":"Observable Observable contract used by DataCore and DataProcessorCore. Defines the canonical structure for observable entries stored in raw_data and processed_data mappings throughout the X-LAB plotting ecosystem. An Observable bundles a payload together with its display units: units : Human-readable unit string, or None for unitless data. data : The underlying payload (e.g. list, array, scalar, etc.).","title":"Contracts - Observable"},{"location":"api/contracts/observable/#observable","text":"Observable contract used by DataCore and DataProcessorCore. Defines the canonical structure for observable entries stored in raw_data and processed_data mappings throughout the X-LAB plotting ecosystem. An Observable bundles a payload together with its display units: units : Human-readable unit string, or None for unitless data. data : The underlying payload (e.g. list, array, scalar, etc.).","title":"Observable"},{"location":"api/contracts/data/data_processors/","text":"Data Processors Bases: ABC Abstract interface for data processors that derive observables from raw Data. Overview Defines the minimal contract for processing layers that expose computed observables and their units. Abstract methods: get_data, get_units, validate_observables. Focused on returning data and unit strings for named observables. Usage Notes Implementations should delegate raw observables to a Data instance and compute derived observables on demand. Source code in contracts\\data_processors.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class DataProcessor ( ABC ): \"\"\" Abstract interface for data processors that derive observables from raw Data. Overview: Defines the minimal contract for processing layers that expose computed observables and their units. - Abstract methods: get_data, get_units, validate_observables. - Focused on returning data and unit strings for named observables. Usage Notes: Implementations should delegate raw observables to a Data instance and compute derived observables on demand. \"\"\" @abstractmethod def get_data ( self , observable : str , * args , ** kwargs ) -> Any : pass @abstractmethod def get_units ( self , observable : str , * args , ** kwargs ) -> str : pass @abstractmethod def validate_observables ( self , * args , ** kwargs ) -> None : pass Bases: DataProcessor Default on\u2011demand processing core for derived observables. Overview Provides a processing-functions registry and a cache for computed results. Delegates raw observables to the wrapped Data object and computes others using registered functions. Maintains _processing_functions and processed_data cache. get_data/get_units compute lazily and raise ValueError if unknown. validate_observables remains abstract for concrete checks. Usage Notes Register per-observable processing functions in _processing_functions and ensure they return {\"units\": str, \"data\": ...} . Source code in contracts\\data_processors.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @decorate_class_with_logging ( log_level = DEBUG_DATA_PROCESSOR ) class DataProcessorCore ( DataProcessor ): \"\"\" Default on\u2011demand processing core for derived observables. Overview: Provides a processing-functions registry and a cache for computed results. Delegates raw observables to the wrapped Data object and computes others using registered functions. - Maintains `_processing_functions` and `processed_data` cache. - get_data/get_units compute lazily and raise ValueError if unknown. - validate_observables remains abstract for concrete checks. Usage Notes: Register per-observable processing functions in `_processing_functions` and ensure they return `{\"units\": str, \"data\": ...}`. \"\"\" processed_data : dict [ str , Observable ] processing_functions : dict [ str , Callable ] def __init__ ( self , data : Data ): self . data = data self . _processing_functions = { \"elapsed_time\" : self . elapsed_time } self . processed_data : dict [ str , Observable ] = {} for key in self . _processing_functions : self . processed_data [ key ] = None self . _processed_observables = self . processed_data . keys () def get_data ( self , observable : str , * args , ** kwargs ): # If observable is available from raw data delegate to Data if observable in self . data . get_allowed_observables (): return self . data . get_data ( observable ) # Compute processed data if needed elif observable in self . _processed_observables : if self . processed_data [ observable ] is None : # Adds the data to the processed_data dict after computing it self . processed_data [ observable ] = self . _processing_functions [ observable ]( * args , ** kwargs ) # Simply return if already set return self . processed_data [ observable ][ 'data' ] else : # FIXME: Apparently object has no attribute '__name__'. Did you mean: '__ne__'? gets triggered when ValueError is raised raise ValueError ( f \" { self . __class__ . __name__ } does not contain { observable } data\" ) def get_units ( self , observable : str , * args , ** kwargs ) -> str : self . get_data ( observable ) # Return raw data if observable in self . data . get_allowed_observables (): return self . data . get_units ( observable ) elif observable in self . _processed_observables : return self . processed_data [ observable ][ \"units\" ] else : raise ValueError ( f \" { self . __class__ . __name__ } does not contain { observable } data\" ) @abstractmethod def validate_observables ( self , * args , ** kwargs ) -> None : \"\"\" This function will check whether all requested observables are available. This should be implemented by the individual subclasses \"\"\" pass def elapsed_time ( self , * args , ** kwargs ) -> Observable : # Get a reference timestamp from *args reference_datetime = kwargs [ \"experiment_datetime\" ] data_datetime = self . get_data ( \"datetime\" ) return { \"units\" : \"$Elapsed ~time ~(hrs)$\" , \"data\" : data_datetime - reference_datetime } validate_observables ( * args , ** kwargs ) abstractmethod This function will check whether all requested observables are available. This should be implemented by the individual subclasses Source code in contracts\\data_processors.py 96 97 98 99 100 101 102 @abstractmethod def validate_observables ( self , * args , ** kwargs ) -> None : \"\"\" This function will check whether all requested observables are available. This should be implemented by the individual subclasses \"\"\" pass","title":"Data Processors"},{"location":"api/contracts/data/data_processors/#data-processors","text":"Bases: ABC Abstract interface for data processors that derive observables from raw Data. Overview Defines the minimal contract for processing layers that expose computed observables and their units. Abstract methods: get_data, get_units, validate_observables. Focused on returning data and unit strings for named observables. Usage Notes Implementations should delegate raw observables to a Data instance and compute derived observables on demand. Source code in contracts\\data_processors.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class DataProcessor ( ABC ): \"\"\" Abstract interface for data processors that derive observables from raw Data. Overview: Defines the minimal contract for processing layers that expose computed observables and their units. - Abstract methods: get_data, get_units, validate_observables. - Focused on returning data and unit strings for named observables. Usage Notes: Implementations should delegate raw observables to a Data instance and compute derived observables on demand. \"\"\" @abstractmethod def get_data ( self , observable : str , * args , ** kwargs ) -> Any : pass @abstractmethod def get_units ( self , observable : str , * args , ** kwargs ) -> str : pass @abstractmethod def validate_observables ( self , * args , ** kwargs ) -> None : pass Bases: DataProcessor Default on\u2011demand processing core for derived observables. Overview Provides a processing-functions registry and a cache for computed results. Delegates raw observables to the wrapped Data object and computes others using registered functions. Maintains _processing_functions and processed_data cache. get_data/get_units compute lazily and raise ValueError if unknown. validate_observables remains abstract for concrete checks. Usage Notes Register per-observable processing functions in _processing_functions and ensure they return {\"units\": str, \"data\": ...} . Source code in contracts\\data_processors.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @decorate_class_with_logging ( log_level = DEBUG_DATA_PROCESSOR ) class DataProcessorCore ( DataProcessor ): \"\"\" Default on\u2011demand processing core for derived observables. Overview: Provides a processing-functions registry and a cache for computed results. Delegates raw observables to the wrapped Data object and computes others using registered functions. - Maintains `_processing_functions` and `processed_data` cache. - get_data/get_units compute lazily and raise ValueError if unknown. - validate_observables remains abstract for concrete checks. Usage Notes: Register per-observable processing functions in `_processing_functions` and ensure they return `{\"units\": str, \"data\": ...}`. \"\"\" processed_data : dict [ str , Observable ] processing_functions : dict [ str , Callable ] def __init__ ( self , data : Data ): self . data = data self . _processing_functions = { \"elapsed_time\" : self . elapsed_time } self . processed_data : dict [ str , Observable ] = {} for key in self . _processing_functions : self . processed_data [ key ] = None self . _processed_observables = self . processed_data . keys () def get_data ( self , observable : str , * args , ** kwargs ): # If observable is available from raw data delegate to Data if observable in self . data . get_allowed_observables (): return self . data . get_data ( observable ) # Compute processed data if needed elif observable in self . _processed_observables : if self . processed_data [ observable ] is None : # Adds the data to the processed_data dict after computing it self . processed_data [ observable ] = self . _processing_functions [ observable ]( * args , ** kwargs ) # Simply return if already set return self . processed_data [ observable ][ 'data' ] else : # FIXME: Apparently object has no attribute '__name__'. Did you mean: '__ne__'? gets triggered when ValueError is raised raise ValueError ( f \" { self . __class__ . __name__ } does not contain { observable } data\" ) def get_units ( self , observable : str , * args , ** kwargs ) -> str : self . get_data ( observable ) # Return raw data if observable in self . data . get_allowed_observables (): return self . data . get_units ( observable ) elif observable in self . _processed_observables : return self . processed_data [ observable ][ \"units\" ] else : raise ValueError ( f \" { self . __class__ . __name__ } does not contain { observable } data\" ) @abstractmethod def validate_observables ( self , * args , ** kwargs ) -> None : \"\"\" This function will check whether all requested observables are available. This should be implemented by the individual subclasses \"\"\" pass def elapsed_time ( self , * args , ** kwargs ) -> Observable : # Get a reference timestamp from *args reference_datetime = kwargs [ \"experiment_datetime\" ] data_datetime = self . get_data ( \"datetime\" ) return { \"units\" : \"$Elapsed ~time ~(hrs)$\" , \"data\" : data_datetime - reference_datetime }","title":"Data Processors"},{"location":"api/contracts/data/data_processors/#contracts.data_processors.DataProcessorCore.validate_observables","text":"This function will check whether all requested observables are available. This should be implemented by the individual subclasses Source code in contracts\\data_processors.py 96 97 98 99 100 101 102 @abstractmethod def validate_observables ( self , * args , ** kwargs ) -> None : \"\"\" This function will check whether all requested observables are available. This should be implemented by the individual subclasses \"\"\" pass","title":"validate_observables"},{"location":"api/contracts/data/data_types/","text":"Data Types Bases: ABC Abstract interface for data containers. Overview Declares the contract for concrete data types used across the project. Abstract methods: read_file, get_data, get_units, get_allowed_observables. Intended as a minimal API that all data loaders/adapters must implement. Usage Notes Implementations should populate an internal representation and match the return expectations used by callers elsewhere in the codebase. Source code in contracts\\data_types.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Data ( ABC ): \"\"\" Abstract interface for data containers. Overview: Declares the contract for concrete data types used across the project. - Abstract methods: read_file, get_data, get_units, get_allowed_observables. - Intended as a minimal API that all data loaders/adapters must implement. Usage Notes: Implementations should populate an internal representation and match the return expectations used by callers elsewhere in the codebase. \"\"\" @abstractmethod def read_file ( self , filepath : str ) -> None : pass @abstractmethod def get_data ( self , observable : str ) -> list : pass @abstractmethod def get_units ( self , observable : str ) -> str : pass @abstractmethod def get_allowed_observables ( self ): pass Bases: Data Base implementation providing common behaviors for data types. Overview Supplies shared storage and partial method implementations useful to subclasses. Manages raw_data and _allowed_observables . Requires a file_reader conforming to FileReaderFn for loading raw data. Implements datetime extraction from filenames, get_data , get_units , and get_allowed_observables . Leaves read_file abstract so subclasses can: call self.file_reader(filepath) interpret its output into domain-specific observables. Usage Notes Subclasses must implement read_file and populate raw_data / _allowed_observables . get_data raises ValueError for unsupported observables. Source code in contracts\\data_types.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @decorate_class_with_logging ( log_level = DEBUG_DATA_TYPE ) class DataCore ( Data ): \"\"\" Base implementation providing common behaviors for data types. Overview: Supplies shared storage and partial method implementations useful to subclasses. - Manages `raw_data` and `_allowed_observables`. - Requires a `file_reader` conforming to `FileReaderFn` for loading raw data. - Implements datetime extraction from filenames, `get_data`, `get_units`, and `get_allowed_observables`. - Leaves `read_file` abstract so subclasses can: - call `self.file_reader(filepath)` - interpret its output into domain-specific observables. Usage Notes: Subclasses must implement `read_file` and populate `raw_data` / `_allowed_observables`. `get_data` raises ValueError for unsupported observables. \"\"\" raw_data : dict [ str , Observable ] def __init__ ( self , file_reader : FileReaderFn ): self . raw_data : dict [ str , Observable ] = {} self . _allowed_observables = {} self . file_reader = file_reader @abstractmethod def read_file ( self , filepath : str ) -> None : pass def _get_datetime_from_filename ( self , filepath : str ) -> None : datetime = CustomDatetime () filename = os . path . basename ( filepath ) self . raw_data [ 'datetime' ] = { \"units\" : None , \"data\" : datetime . create_datetime_from_string ( filename )} def get_data ( self , observable : str ) -> Any : if observable in self . _allowed_observables : return self . raw_data [ observable ][ 'data' ] else : raise ValueError ( f \" { self . __class__ . __name__ } does not contain { observable } data\" ) def get_units ( self , observable : str ) -> str : self . get_data ( observable ) return self . raw_data [ observable ][ \"units\" ] def get_allowed_observables ( self ): return self . _allowed_observables","title":"Data Types"},{"location":"api/contracts/data/data_types/#data-types","text":"Bases: ABC Abstract interface for data containers. Overview Declares the contract for concrete data types used across the project. Abstract methods: read_file, get_data, get_units, get_allowed_observables. Intended as a minimal API that all data loaders/adapters must implement. Usage Notes Implementations should populate an internal representation and match the return expectations used by callers elsewhere in the codebase. Source code in contracts\\data_types.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Data ( ABC ): \"\"\" Abstract interface for data containers. Overview: Declares the contract for concrete data types used across the project. - Abstract methods: read_file, get_data, get_units, get_allowed_observables. - Intended as a minimal API that all data loaders/adapters must implement. Usage Notes: Implementations should populate an internal representation and match the return expectations used by callers elsewhere in the codebase. \"\"\" @abstractmethod def read_file ( self , filepath : str ) -> None : pass @abstractmethod def get_data ( self , observable : str ) -> list : pass @abstractmethod def get_units ( self , observable : str ) -> str : pass @abstractmethod def get_allowed_observables ( self ): pass Bases: Data Base implementation providing common behaviors for data types. Overview Supplies shared storage and partial method implementations useful to subclasses. Manages raw_data and _allowed_observables . Requires a file_reader conforming to FileReaderFn for loading raw data. Implements datetime extraction from filenames, get_data , get_units , and get_allowed_observables . Leaves read_file abstract so subclasses can: call self.file_reader(filepath) interpret its output into domain-specific observables. Usage Notes Subclasses must implement read_file and populate raw_data / _allowed_observables . get_data raises ValueError for unsupported observables. Source code in contracts\\data_types.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @decorate_class_with_logging ( log_level = DEBUG_DATA_TYPE ) class DataCore ( Data ): \"\"\" Base implementation providing common behaviors for data types. Overview: Supplies shared storage and partial method implementations useful to subclasses. - Manages `raw_data` and `_allowed_observables`. - Requires a `file_reader` conforming to `FileReaderFn` for loading raw data. - Implements datetime extraction from filenames, `get_data`, `get_units`, and `get_allowed_observables`. - Leaves `read_file` abstract so subclasses can: - call `self.file_reader(filepath)` - interpret its output into domain-specific observables. Usage Notes: Subclasses must implement `read_file` and populate `raw_data` / `_allowed_observables`. `get_data` raises ValueError for unsupported observables. \"\"\" raw_data : dict [ str , Observable ] def __init__ ( self , file_reader : FileReaderFn ): self . raw_data : dict [ str , Observable ] = {} self . _allowed_observables = {} self . file_reader = file_reader @abstractmethod def read_file ( self , filepath : str ) -> None : pass def _get_datetime_from_filename ( self , filepath : str ) -> None : datetime = CustomDatetime () filename = os . path . basename ( filepath ) self . raw_data [ 'datetime' ] = { \"units\" : None , \"data\" : datetime . create_datetime_from_string ( filename )} def get_data ( self , observable : str ) -> Any : if observable in self . _allowed_observables : return self . raw_data [ observable ][ 'data' ] else : raise ValueError ( f \" { self . __class__ . __name__ } does not contain { observable } data\" ) def get_units ( self , observable : str ) -> str : self . get_data ( observable ) return self . raw_data [ observable ][ \"units\" ] def get_allowed_observables ( self ): return self . _allowed_observables","title":"Data Types"},{"location":"api/contracts/plotters/plotter/","text":"Plotter Bases: ABC Abstract plotting interface for rendering data from processors. Overview Specifies the minimal lifecycle for a plot: prepare with processors and options, then draw. Abstract methods: ready_plot(processors, options) and draw_plot(). Intended to separate data preparation from rendering. Usage Notes Implementations should be lightweight and accept a DataProcessor instance. Source code in contracts\\plotter.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Plotter ( ABC ): \"\"\" Abstract plotting interface for rendering data from processors. Overview: Specifies the minimal lifecycle for a plot: prepare with processors and options, then draw. - Abstract methods: ready_plot(processors, options) and draw_plot(). - Intended to separate data preparation from rendering. Usage Notes: Implementations should be lightweight and accept a DataProcessor instance. \"\"\" @abstractmethod def ready_plot ( self , processors : DataProcessor , options : dict ): pass @abstractmethod def draw_plot ( self ): pass","title":"Plotter"},{"location":"api/contracts/plotters/plotter/#plotter","text":"Bases: ABC Abstract plotting interface for rendering data from processors. Overview Specifies the minimal lifecycle for a plot: prepare with processors and options, then draw. Abstract methods: ready_plot(processors, options) and draw_plot(). Intended to separate data preparation from rendering. Usage Notes Implementations should be lightweight and accept a DataProcessor instance. Source code in contracts\\plotter.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Plotter ( ABC ): \"\"\" Abstract plotting interface for rendering data from processors. Overview: Specifies the minimal lifecycle for a plot: prepare with processors and options, then draw. - Abstract methods: ready_plot(processors, options) and draw_plot(). - Intended to separate data preparation from rendering. Usage Notes: Implementations should be lightweight and accept a DataProcessor instance. \"\"\" @abstractmethod def ready_plot ( self , processors : DataProcessor , options : dict ): pass @abstractmethod def draw_plot ( self ): pass","title":"Plotter"},{"location":"api/contracts/plotters/plotter_options/","text":"Plotter Options Small, dictionary-backed container for named plotter options. Overview Stores arbitrary named options, offers safe retrieval and as_kwargs filtering for passing options as **kwargs. Supports add_option, get_option, has_options, as_kwargs. Raises clear exceptions for missing keys or bad argument types. Usage Notes Use as a simple options bag shared between workers and plotters. Source code in contracts\\plotter_options.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @decorate_class_with_logging ( log_level = DEBUG_PLOTTER ) class PlotterOptions : \"\"\" Small, dictionary-backed container for named plotter options. Overview: Stores arbitrary named options, offers safe retrieval and `as_kwargs` filtering for passing options as **kwargs. - Supports add_option, get_option, has_options, as_kwargs. - Raises clear exceptions for missing keys or bad argument types. Usage Notes: Use as a simple options bag shared between workers and plotters. \"\"\" def __init__ ( self ): self . options = {} def add_option ( self , label : str , value ) -> bool : \"\"\" Add option if it does not already exist, if it does and the values conflict raise KeyError \"\"\" if not self . has_options ( label ): self . options [ label ] = value elif self . get_option ( label ) != value : raise KeyError ( f \"Option with label { label } already exists in PlotterOptions\" ) return True def update_option ( self , label : str , value ) -> bool : \"\"\" Update option if it exists, if not set option by calling add_option \"\"\" if self . has_options ( label ): self . options [ label ] = value else : self . add_option ( label , value ) return True # Return option def get_option ( self , label : str ): # Check option existance before returning if self . has_options ( label ): return self . options [ label ] else : return None # Check whether the option exists def has_options ( self , options_to_check ): # Single option will typically be a string, put in list to be handled below if isinstance ( options_to_check , str ): options_to_check = [ options_to_check ] # Check if a list was passed if isinstance ( options_to_check , list ): # Verify that all listed options are present in the keys, return false for first missing option for option in options_to_check : if option not in self . options . keys (): return False return True # Fail if options_to_check is neither list not string else : raise ValueError ( f \"Passed incorrect type to PlotterOptions class, { type ( options_to_check ) } of { options_to_check } is not list or string\" ) def __str__ ( self ): return_string = '' for key in self . options . keys (): return_string += f \" { key } : { self . options [ key ] } \" return return_string def as_kwargs ( self , keys = None ) -> dict : \"\"\" Return a dict of options that can be passed as **kwargs. \"\"\" # No filtering: return everything if keys is None : return dict ( self . options ) # Normalise single string to list if isinstance ( keys , str ): keys = [ keys ] # Sanity check try : iter ( keys ) except TypeError : raise TypeError ( \"keys must be None, a string, or an iterable of strings\" ) # Check all keys missing = [ k for k in keys if k not in self . options ] if missing : raise KeyError ( f \"Requested options not present: { missing } \" ) # Return kwarg dict return { k : self . options [ k ] for k in keys } add_option ( label , value ) Add option if it does not already exist, if it does and the values conflict raise KeyError Source code in contracts\\plotter_options.py 21 22 23 24 25 26 27 def add_option ( self , label : str , value ) -> bool : \"\"\" Add option if it does not already exist, if it does and the values conflict raise KeyError \"\"\" if not self . has_options ( label ): self . options [ label ] = value elif self . get_option ( label ) != value : raise KeyError ( f \"Option with label { label } already exists in PlotterOptions\" ) return True as_kwargs ( keys = None ) Return a dict of options that can be passed as **kwargs. Source code in contracts\\plotter_options.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def as_kwargs ( self , keys = None ) -> dict : \"\"\" Return a dict of options that can be passed as **kwargs. \"\"\" # No filtering: return everything if keys is None : return dict ( self . options ) # Normalise single string to list if isinstance ( keys , str ): keys = [ keys ] # Sanity check try : iter ( keys ) except TypeError : raise TypeError ( \"keys must be None, a string, or an iterable of strings\" ) # Check all keys missing = [ k for k in keys if k not in self . options ] if missing : raise KeyError ( f \"Requested options not present: { missing } \" ) # Return kwarg dict return { k : self . options [ k ] for k in keys } update_option ( label , value ) Update option if it exists, if not set option by calling add_option Source code in contracts\\plotter_options.py 29 30 31 32 33 34 35 def update_option ( self , label : str , value ) -> bool : \"\"\" Update option if it exists, if not set option by calling add_option \"\"\" if self . has_options ( label ): self . options [ label ] = value else : self . add_option ( label , value ) return True","title":"PlotterOptions"},{"location":"api/contracts/plotters/plotter_options/#plotter-options","text":"Small, dictionary-backed container for named plotter options. Overview Stores arbitrary named options, offers safe retrieval and as_kwargs filtering for passing options as **kwargs. Supports add_option, get_option, has_options, as_kwargs. Raises clear exceptions for missing keys or bad argument types. Usage Notes Use as a simple options bag shared between workers and plotters. Source code in contracts\\plotter_options.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @decorate_class_with_logging ( log_level = DEBUG_PLOTTER ) class PlotterOptions : \"\"\" Small, dictionary-backed container for named plotter options. Overview: Stores arbitrary named options, offers safe retrieval and `as_kwargs` filtering for passing options as **kwargs. - Supports add_option, get_option, has_options, as_kwargs. - Raises clear exceptions for missing keys or bad argument types. Usage Notes: Use as a simple options bag shared between workers and plotters. \"\"\" def __init__ ( self ): self . options = {} def add_option ( self , label : str , value ) -> bool : \"\"\" Add option if it does not already exist, if it does and the values conflict raise KeyError \"\"\" if not self . has_options ( label ): self . options [ label ] = value elif self . get_option ( label ) != value : raise KeyError ( f \"Option with label { label } already exists in PlotterOptions\" ) return True def update_option ( self , label : str , value ) -> bool : \"\"\" Update option if it exists, if not set option by calling add_option \"\"\" if self . has_options ( label ): self . options [ label ] = value else : self . add_option ( label , value ) return True # Return option def get_option ( self , label : str ): # Check option existance before returning if self . has_options ( label ): return self . options [ label ] else : return None # Check whether the option exists def has_options ( self , options_to_check ): # Single option will typically be a string, put in list to be handled below if isinstance ( options_to_check , str ): options_to_check = [ options_to_check ] # Check if a list was passed if isinstance ( options_to_check , list ): # Verify that all listed options are present in the keys, return false for first missing option for option in options_to_check : if option not in self . options . keys (): return False return True # Fail if options_to_check is neither list not string else : raise ValueError ( f \"Passed incorrect type to PlotterOptions class, { type ( options_to_check ) } of { options_to_check } is not list or string\" ) def __str__ ( self ): return_string = '' for key in self . options . keys (): return_string += f \" { key } : { self . options [ key ] } \" return return_string def as_kwargs ( self , keys = None ) -> dict : \"\"\" Return a dict of options that can be passed as **kwargs. \"\"\" # No filtering: return everything if keys is None : return dict ( self . options ) # Normalise single string to list if isinstance ( keys , str ): keys = [ keys ] # Sanity check try : iter ( keys ) except TypeError : raise TypeError ( \"keys must be None, a string, or an iterable of strings\" ) # Check all keys missing = [ k for k in keys if k not in self . options ] if missing : raise KeyError ( f \"Requested options not present: { missing } \" ) # Return kwarg dict return { k : self . options [ k ] for k in keys }","title":"Plotter Options"},{"location":"api/contracts/plotters/plotter_options/#contracts.plotter_options.PlotterOptions.add_option","text":"Add option if it does not already exist, if it does and the values conflict raise KeyError Source code in contracts\\plotter_options.py 21 22 23 24 25 26 27 def add_option ( self , label : str , value ) -> bool : \"\"\" Add option if it does not already exist, if it does and the values conflict raise KeyError \"\"\" if not self . has_options ( label ): self . options [ label ] = value elif self . get_option ( label ) != value : raise KeyError ( f \"Option with label { label } already exists in PlotterOptions\" ) return True","title":"add_option"},{"location":"api/contracts/plotters/plotter_options/#contracts.plotter_options.PlotterOptions.as_kwargs","text":"Return a dict of options that can be passed as **kwargs. Source code in contracts\\plotter_options.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def as_kwargs ( self , keys = None ) -> dict : \"\"\" Return a dict of options that can be passed as **kwargs. \"\"\" # No filtering: return everything if keys is None : return dict ( self . options ) # Normalise single string to list if isinstance ( keys , str ): keys = [ keys ] # Sanity check try : iter ( keys ) except TypeError : raise TypeError ( \"keys must be None, a string, or an iterable of strings\" ) # Check all keys missing = [ k for k in keys if k not in self . options ] if missing : raise KeyError ( f \"Requested options not present: { missing } \" ) # Return kwarg dict return { k : self . options [ k ] for k in keys }","title":"as_kwargs"},{"location":"api/contracts/plotters/plotter_options/#contracts.plotter_options.PlotterOptions.update_option","text":"Update option if it exists, if not set option by calling add_option Source code in contracts\\plotter_options.py 29 30 31 32 33 34 35 def update_option ( self , label : str , value ) -> bool : \"\"\" Update option if it exists, if not set option by calling add_option \"\"\" if self . has_options ( label ): self . options [ label ] = value else : self . add_option ( label , value ) return True","title":"update_option"},{"location":"api/gui/plot_manager/","text":"Plot Manager Orchestrate a plotting run in a background thread to keep the GUI responsive. Workflow Collect the selected file labels from the main window. Build a reduced DataSpec containing only the selected files, colours, device, structure type, and name. Collect plotting options from the active device widget (via alias properties) and from global GUI controls, storing them in PlotterOptions . Resolve and instantiate the appropriate device worker class from the implementations.devices.workers namespace. Configure the worker with the reduced dataspec, selected plot function, and options. Move the worker to a QThread , wire up progress/finished signals, and start the thread. The function logs a concise summary of the run (including a short run identifier) to the GUI console once the worker is started. Parameters window : QMainWindow Main application window providing access to the dataspec, widgets (file selection, stacked options, checkboxes, etc.), and console API. Source code in gui\\plot_manager.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @with_logging def plot_manager ( window , * args , ** kwargs ): \"\"\" Orchestrate a plotting run in a background thread to keep the GUI responsive. Workflow -------- 1. Collect the selected file labels from the main window. 2. Build a reduced `DataSpec` containing only the selected files, colours, device, structure type, and name. 3. Collect plotting options from the active device widget (via `alias` properties) and from global GUI controls, storing them in `PlotterOptions`. 4. Resolve and instantiate the appropriate device worker class from the `implementations.devices.workers` namespace. 5. Configure the worker with the reduced dataspec, selected plot function, and options. 6. Move the worker to a `QThread`, wire up progress/finished signals, and start the thread. The function logs a concise summary of the run (including a short run identifier) to the GUI console once the worker is started. Parameters ---------- window : QMainWindow Main application window providing access to the dataspec, widgets (file selection, stacked options, checkboxes, etc.), and console API. \"\"\" # Grab the selected files for plotting and build a reduced dataspec dataspec_time = datetime . datetime . now () . strftime ( constants . DATETIME_FORMAT ) experiment_time = window . dataspec . get_experiment_date () . strftime ( constants . DATETIME_FORMAT ) dataspec_selection = dataspec_manager . DataSpec ( dataspec_time ) dataspec_selection . set_experiment_date ( experiment_time ) for item in window . selectedFilesList . selectedItems (): lbl = item . text () structure = window . dataspec . get_structure_type () dataspec_selection . set_structure_type ( structure ) path = window . dataspec . get_filepath ( lbl ) dataspec_selection . add_filepath ( path , lbl ) colour = window . dataspec . get_single_colour ( lbl ) dataspec_selection . add_colour ( colour , lbl ) dataspec_selection . set_device ( window . dataspec . get_device ()) dataspec_selection . set_structure_type ( window . dataspec . get_structure_type ()) dataspec_selection . set_name ( window . dataspec . get_name ()) # Recursively search for QWidget children with an alias to collect options and get their values # TODO: Options should be a class whose instance can be passed options = PlotterOptions () for option in window . stackedWidget . currentWidget () . findChildren ( QtWidgets . QWidget ): alias = option . property ( \"alias\" ) if alias is not None : option_value = get_qwidget_value ( option ) if option_value is not None : options . add_option ( label = alias , value = option_value ) options . add_option ( label = \"presentation\" , value = get_qwidget_value ( window . presentationCheckBox )) options . add_option ( label = \"legend_title\" , value = get_qwidget_value ( window . legendTitleLineEdit )) # Instantiate proper device class and set the data current_device_class = window . dataspec . get_device () device_module = getattr ( implementations . devices . workers , current_device_class . lower ()) experiment_cls = getattr ( device_module , current_device_class ) # # Grab the correct plotting function and pass all options to it plot_function = window . get_current_plot_function () # Create a new thread for the device class to run in window . thread = QtCore . QThread () window . experiment_worker = experiment_cls ( current_device_class , dataspec_selection , plot_function , options = options ) window . experiment_worker . moveToThread ( window . thread ) # Connect signals and slots for the worker thread window . thread . started . connect ( window . experiment_worker . run ) window . experiment_worker . finished . connect ( window . thread . quit ) window . experiment_worker . finished . connect ( window . experiment_worker . deleteLater ) window . thread . finished . connect ( window . thread . deleteLater ) window . experiment_worker . progress . connect ( window . report_progress ) # Start the thread window . thread . start () window . console_print ( f \"(run { window . experiment_worker . identifier } ) producing { current_device_class } - { plot_function } plot for { window . get_dataspec_name () } with options { options } \" )","title":"GUI - Plot Manager"},{"location":"api/gui/plot_manager/#plot-manager","text":"Orchestrate a plotting run in a background thread to keep the GUI responsive.","title":"Plot Manager"},{"location":"api/gui/plot_manager/#gui.plot_manager.plot_manager--workflow","text":"Collect the selected file labels from the main window. Build a reduced DataSpec containing only the selected files, colours, device, structure type, and name. Collect plotting options from the active device widget (via alias properties) and from global GUI controls, storing them in PlotterOptions . Resolve and instantiate the appropriate device worker class from the implementations.devices.workers namespace. Configure the worker with the reduced dataspec, selected plot function, and options. Move the worker to a QThread , wire up progress/finished signals, and start the thread. The function logs a concise summary of the run (including a short run identifier) to the GUI console once the worker is started.","title":"Workflow"},{"location":"api/gui/plot_manager/#gui.plot_manager.plot_manager--parameters","text":"window : QMainWindow Main application window providing access to the dataspec, widgets (file selection, stacked options, checkboxes, etc.), and console API. Source code in gui\\plot_manager.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @with_logging def plot_manager ( window , * args , ** kwargs ): \"\"\" Orchestrate a plotting run in a background thread to keep the GUI responsive. Workflow -------- 1. Collect the selected file labels from the main window. 2. Build a reduced `DataSpec` containing only the selected files, colours, device, structure type, and name. 3. Collect plotting options from the active device widget (via `alias` properties) and from global GUI controls, storing them in `PlotterOptions`. 4. Resolve and instantiate the appropriate device worker class from the `implementations.devices.workers` namespace. 5. Configure the worker with the reduced dataspec, selected plot function, and options. 6. Move the worker to a `QThread`, wire up progress/finished signals, and start the thread. The function logs a concise summary of the run (including a short run identifier) to the GUI console once the worker is started. Parameters ---------- window : QMainWindow Main application window providing access to the dataspec, widgets (file selection, stacked options, checkboxes, etc.), and console API. \"\"\" # Grab the selected files for plotting and build a reduced dataspec dataspec_time = datetime . datetime . now () . strftime ( constants . DATETIME_FORMAT ) experiment_time = window . dataspec . get_experiment_date () . strftime ( constants . DATETIME_FORMAT ) dataspec_selection = dataspec_manager . DataSpec ( dataspec_time ) dataspec_selection . set_experiment_date ( experiment_time ) for item in window . selectedFilesList . selectedItems (): lbl = item . text () structure = window . dataspec . get_structure_type () dataspec_selection . set_structure_type ( structure ) path = window . dataspec . get_filepath ( lbl ) dataspec_selection . add_filepath ( path , lbl ) colour = window . dataspec . get_single_colour ( lbl ) dataspec_selection . add_colour ( colour , lbl ) dataspec_selection . set_device ( window . dataspec . get_device ()) dataspec_selection . set_structure_type ( window . dataspec . get_structure_type ()) dataspec_selection . set_name ( window . dataspec . get_name ()) # Recursively search for QWidget children with an alias to collect options and get their values # TODO: Options should be a class whose instance can be passed options = PlotterOptions () for option in window . stackedWidget . currentWidget () . findChildren ( QtWidgets . QWidget ): alias = option . property ( \"alias\" ) if alias is not None : option_value = get_qwidget_value ( option ) if option_value is not None : options . add_option ( label = alias , value = option_value ) options . add_option ( label = \"presentation\" , value = get_qwidget_value ( window . presentationCheckBox )) options . add_option ( label = \"legend_title\" , value = get_qwidget_value ( window . legendTitleLineEdit )) # Instantiate proper device class and set the data current_device_class = window . dataspec . get_device () device_module = getattr ( implementations . devices . workers , current_device_class . lower ()) experiment_cls = getattr ( device_module , current_device_class ) # # Grab the correct plotting function and pass all options to it plot_function = window . get_current_plot_function () # Create a new thread for the device class to run in window . thread = QtCore . QThread () window . experiment_worker = experiment_cls ( current_device_class , dataspec_selection , plot_function , options = options ) window . experiment_worker . moveToThread ( window . thread ) # Connect signals and slots for the worker thread window . thread . started . connect ( window . experiment_worker . run ) window . experiment_worker . finished . connect ( window . thread . quit ) window . experiment_worker . finished . connect ( window . experiment_worker . deleteLater ) window . thread . finished . connect ( window . thread . deleteLater ) window . experiment_worker . progress . connect ( window . report_progress ) # Start the thread window . thread . start () window . console_print ( f \"(run { window . experiment_worker . identifier } ) producing { current_device_class } - { plot_function } plot for { window . get_dataspec_name () } with options { options } \" )","title":"Parameters"},{"location":"api/gui/utils/","text":"Utils Clear Fully reset the GUI state and remove all in-memory data. This helper: - Clears the active DataSpec and GUI fields via clear_data . - Empties the console widget. - Writes a confirmation message to the GUI console. Parameters window : QMainWindow Main application window whose state should be cleared. Source code in gui\\utils\\clear\\clear_all.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def clear_all ( window : QtWidgets . QMainWindow ): \"\"\" Fully reset the GUI state and remove all in-memory data. This helper: - Clears the active `DataSpec` and GUI fields via `clear_data`. - Empties the console widget. - Writes a confirmation message to the GUI console. Parameters ---------- window : QMainWindow Main application window whose state should be cleared. \"\"\" clear_data ( window ) window . consoleTextEdit . clear () window . console_print ( \"Cleared memory\" ) Clear the currently loaded dataspec and reset all GUI widgets tied to it. Resets: - Stored DataSpec object and its disk location. - Set name, device name, notes, and list widgets. - Plot type combobox and stacked widget view. A console message is printed to confirm completion. Parameters window : QMainWindow Main GUI instance that holds dataspec-related widgets. Source code in gui\\utils\\clear\\clear_data.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def clear_data ( window : QtWidgets . QMainWindow ): \"\"\" Clear the currently loaded dataspec and reset all GUI widgets tied to it. Resets: - Stored `DataSpec` object and its disk location. - Set name, device name, notes, and list widgets. - Plot type combobox and stacked widget view. A console message is printed to confirm completion. Parameters ---------- window : QMainWindow Main GUI instance that holds dataspec-related widgets. \"\"\" window . dataspec = None window . dataspec_location = None window . currSetNameLineEdit . clear () window . currDeviceLineEdit . clear () window . notesPlainText . clear () window . console_print ( \"Cleared dataspec from memory\" ) window . stackedWidget . setCurrentWidget ( window . stackedWidget . widget ( 0 )) window . selectedFilesList . clear () window . plotTypeCombo . clear () DataSpec Tools Launch the DataSpec creation dialog and construct a new dataspec from user input. Workflow: - Opens the DataSpec creator window populated with available devices. - On confirmation: * Clears existing state. * Stores the newly created dataspec. * Loads it into the GUI and updates the header. * Immediately saves it to disk. - If cancelled, informs the user that no dataspec was created. Parameters window : QMainWindow Main application window controlling dataspec creation. Source code in gui\\utils\\dataspec_tools\\create_dataspec.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @with_logging def create_dataspec ( window : QtWidgets . QMainWindow , * args , ** kwargs ): \"\"\" Launch the DataSpec creation dialog and construct a new dataspec from user input. Workflow: - Opens the DataSpec creator window populated with available devices. - On confirmation: * Clears existing state. * Stores the newly created dataspec. * Loads it into the GUI and updates the header. * Immediately saves it to disk. - If cancelled, informs the user that no dataspec was created. Parameters ---------- window : QMainWindow Main application window controlling dataspec creation. \"\"\" window . set_dataspec_window ( gui . windows . DataSpecCreatorWindow . UiDataCreatorWindow ( devices = [ k for k in window . devices ])) window . get_dataspec_window () . show () if window . dataWindow . exec () == 1 : # If the window was properly closed (Done button) then creation was successful # Copy dataspec_tools and print to console clear_data ( window ) window . set_dataspec ( window . get_dataspec_window () . get_dataspec ()) window . console_print ( f \"DataSpec file created\" ) load_dataspec ( window ) window . update_header () save_dataspec ( window ) else : # Warn user that window was improperly closed and that no dataspec_tools was created window . console_print ( \"No DataSpec file was created\" ) Populate the GUI with data from the currently loaded dataspec. Actions: - Adds all dataspec labels to the file selection list. - Selects all items by default. - Populates the plot-type combobox with device-appropriate plotting functions. Raises IncompatibleDeviceTypeFound If the dataspec\u2019s device type does not match available plot handlers. Parameters window : QMainWindow GUI instance holding a loaded dataspec. Source code in gui\\utils\\dataspec_tools\\load_dataspec.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @with_logging def load_dataspec ( window : QtWidgets . QMainWindow ): \"\"\" Populate the GUI with data from the currently loaded dataspec. Actions: - Adds all dataspec labels to the file selection list. - Selects all items by default. - Populates the plot-type combobox with device-appropriate plotting functions. Raises ------ IncompatibleDeviceTypeFound If the dataspec\u2019s device type does not match available plot handlers. Parameters ---------- window : QMainWindow GUI instance holding a loaded dataspec. \"\"\" # Add all top level keys to the selection list of the gui for label in window . dataspec . get_labels (): window . selectedFilesList . addItem ( label ) # FEATURE REQUEST: Make this a setting # Select all items by default window . selectedFilesList . selectAll () # Edit combobox to show all available plot types try : for function in window . get_plot_functions ( window . get_current_device ()): window . plotTypeCombo . addItem ( function ) except KeyError : window . console_print ( f \"Incompatible device type [ { window . get_current_device () } ] found in { window . get_dataspec_name () } , select another dataspec or implement the device type. DataSpec path: N/A\" ) raise IncompatibleDeviceTypeFound window . console_print ( \"DataSpec loaded\" ) Save the currently loaded dataspec to disk using a file dialog. Behaviour: - Ensures a dataspec is loaded before saving. - Opens a save-file dialog and writes the dataspec via DataSpecJSONEncoder . - Auto-appends a valid extension if necessary. - Updates the stored dataspec location and logs status messages. Parameters window : QMainWindow GUI window containing the active dataspec. Source code in gui\\utils\\dataspec_tools\\save_dataspec.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @with_logging def save_dataspec ( window : QtWidgets . QMainWindow , * args , ** kwargs ): \"\"\" Save the currently loaded dataspec to disk using a file dialog. Behaviour: - Ensures a dataspec is loaded before saving. - Opens a save-file dialog and writes the dataspec via `DataSpecJSONEncoder`. - Auto-appends a valid extension if necessary. - Updates the stored dataspec location and logs status messages. Parameters ---------- window : QMainWindow GUI window containing the active dataspec. \"\"\" # Make sure there is a dataspec to save if window . get_dataspec_name () is None : return window . console_print ( \"Err: Must first load dataspec\" , level = \"warning\" ) # Run the file dialog # TODO: There's a bug in ubuntu 24 that has the filter reinitialised when navigating the path file_name = QtWidgets . QFileDialog . getSaveFileName ( parent = window , caption = \"Save file to disk\" , filter = \"DataSpecs (*.json *.dataspec *.ds);;All (*)\" , initialFilter = \"DataSpecs (*.json *.dataspec *.ds)\" )[ 0 ] if file_name != \"\" : # Dump the dataspec_tools into a json file and remember the location # TODO: Dataspec should be aware of its location # Ensure the file name has a valid extension if file_name : if not any ( file_name . endswith ( ext ) for ext in ( '.json' , '.dataspec' , '.ds' )): # Default to .dataspec if no valid extension file_name += '.ds' with open ( file_name , \"w\" ) as json_file : current_dataspec = window . get_dataspec () json . dump ( current_dataspec , json_file , cls = fs . DataSpecJSONEncoder ) current_dataspec . set_location ( file_name ) json_file . close () return window . console_print ( f \"Saved dataspec file to { file_name } \" ) else : # File dialog was exited without choosing a file return window . console_print ( f \"No file selected\" ) Other Extract the current value from common Qt widget types. Supported widgets: - QDoubleSpinBox / QSpinBox \u2192 numeric value - QCheckBox \u2192 boolean isChecked - QLineEdit / QComboBox \u2192 text, with \"None\"/\"none\" mapped to None Raises NotImplementedError if the widget type is unsupported. Parameters widget : QWidget The widget whose value should be extracted. Returns Any The widget's value in a Python-friendly type. Source code in gui\\utils\\get_qwidget_value.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def get_qwidget_value ( widget ): \"\"\" Extract the current value from common Qt widget types. Supported widgets: - QDoubleSpinBox / QSpinBox \u2192 numeric value - QCheckBox \u2192 boolean `isChecked` - QLineEdit / QComboBox \u2192 text, with \"None\"/\"none\" mapped to `None` Raises `NotImplementedError` if the widget type is unsupported. Parameters ---------- widget : QWidget The widget whose value should be extracted. Returns ------- Any The widget's value in a Python-friendly type. \"\"\" if not isinstance ( widget , QtWidgets . QWidget ): raise ValueError ( \"Input must be a QWidget instance\" ) if isinstance ( widget , QtWidgets . QDoubleSpinBox ) or isinstance ( widget , QtWidgets . QSpinBox ): return widget . value () elif isinstance ( widget , QtWidgets . QCheckBox ): return widget . isChecked () elif isinstance ( widget , QtWidgets . QLineEdit ): return _cast_none_string_to_none_type ( widget . text ()) elif isinstance ( widget , QtWidgets . QComboBox ): return _cast_none_string_to_none_type ( widget . currentText ()) else : raise NotImplementedError ( f \"Widget type { type ( widget ) } not supported\" ) Find and return the checked QRadioButton within a dialog. Scans all child radio buttons and returns the first active one. Parameters dialog : QDialog Container widget containing radio buttons. Returns QRadioButton or None The checked radio button, or None if no selection exists. Source code in gui\\utils\\search_for_first_active_radio_button.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def search_for_first_active_radio_button ( dialog : QtWidgets . QDialog ) -> QtWidgets . QRadioButton : \"\"\" Find and return the checked QRadioButton within a dialog. Scans all child radio buttons and returns the first active one. Parameters ---------- dialog : QDialog Container widget containing radio buttons. Returns ------- QRadioButton or None The checked radio button, or `None` if no selection exists. \"\"\" for radio_button in dialog . findChildren ( QtWidgets . QRadioButton ): if radio_button . isChecked (): return radio_button return None Split a CamelCase string into its component words. Examples \"MyPlotType\" \u2192 [\"My\", \"Plot\", \"Type\"] Parameters camel_case : str Input CamelCase string. Returns list[str] List of lowercase/uppercase-correct word segments. Source code in gui\\utils\\split_camelCase.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def split_camel_case ( camel_case ) -> list [ str ]: \"\"\" Split a CamelCase string into its component words. Examples -------- \"MyPlotType\" \u2192 [\"My\", \"Plot\", \"Type\"] Parameters ---------- camel_case : str Input CamelCase string. Returns ------- list[str] List of lowercase/uppercase-correct word segments. \"\"\" return re . findall ( r '[A-Z]?[a-z]+|[A-Z]+(?=[A-Z]|$)' , camel_case )","title":"GUI - Utils"},{"location":"api/gui/utils/#utils","text":"","title":"Utils"},{"location":"api/gui/utils/#clear","text":"Fully reset the GUI state and remove all in-memory data. This helper: - Clears the active DataSpec and GUI fields via clear_data . - Empties the console widget. - Writes a confirmation message to the GUI console.","title":"Clear"},{"location":"api/gui/utils/#gui.utils.clear.clear_all.clear_all--parameters","text":"window : QMainWindow Main application window whose state should be cleared. Source code in gui\\utils\\clear\\clear_all.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def clear_all ( window : QtWidgets . QMainWindow ): \"\"\" Fully reset the GUI state and remove all in-memory data. This helper: - Clears the active `DataSpec` and GUI fields via `clear_data`. - Empties the console widget. - Writes a confirmation message to the GUI console. Parameters ---------- window : QMainWindow Main application window whose state should be cleared. \"\"\" clear_data ( window ) window . consoleTextEdit . clear () window . console_print ( \"Cleared memory\" ) Clear the currently loaded dataspec and reset all GUI widgets tied to it. Resets: - Stored DataSpec object and its disk location. - Set name, device name, notes, and list widgets. - Plot type combobox and stacked widget view. A console message is printed to confirm completion.","title":"Parameters"},{"location":"api/gui/utils/#gui.utils.clear.clear_data.clear_data--parameters","text":"window : QMainWindow Main GUI instance that holds dataspec-related widgets. Source code in gui\\utils\\clear\\clear_data.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def clear_data ( window : QtWidgets . QMainWindow ): \"\"\" Clear the currently loaded dataspec and reset all GUI widgets tied to it. Resets: - Stored `DataSpec` object and its disk location. - Set name, device name, notes, and list widgets. - Plot type combobox and stacked widget view. A console message is printed to confirm completion. Parameters ---------- window : QMainWindow Main GUI instance that holds dataspec-related widgets. \"\"\" window . dataspec = None window . dataspec_location = None window . currSetNameLineEdit . clear () window . currDeviceLineEdit . clear () window . notesPlainText . clear () window . console_print ( \"Cleared dataspec from memory\" ) window . stackedWidget . setCurrentWidget ( window . stackedWidget . widget ( 0 )) window . selectedFilesList . clear () window . plotTypeCombo . clear ()","title":"Parameters"},{"location":"api/gui/utils/#dataspec-tools","text":"Launch the DataSpec creation dialog and construct a new dataspec from user input. Workflow: - Opens the DataSpec creator window populated with available devices. - On confirmation: * Clears existing state. * Stores the newly created dataspec. * Loads it into the GUI and updates the header. * Immediately saves it to disk. - If cancelled, informs the user that no dataspec was created.","title":"DataSpec Tools"},{"location":"api/gui/utils/#gui.utils.dataspec_tools.create_dataspec.create_dataspec--parameters","text":"window : QMainWindow Main application window controlling dataspec creation. Source code in gui\\utils\\dataspec_tools\\create_dataspec.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @with_logging def create_dataspec ( window : QtWidgets . QMainWindow , * args , ** kwargs ): \"\"\" Launch the DataSpec creation dialog and construct a new dataspec from user input. Workflow: - Opens the DataSpec creator window populated with available devices. - On confirmation: * Clears existing state. * Stores the newly created dataspec. * Loads it into the GUI and updates the header. * Immediately saves it to disk. - If cancelled, informs the user that no dataspec was created. Parameters ---------- window : QMainWindow Main application window controlling dataspec creation. \"\"\" window . set_dataspec_window ( gui . windows . DataSpecCreatorWindow . UiDataCreatorWindow ( devices = [ k for k in window . devices ])) window . get_dataspec_window () . show () if window . dataWindow . exec () == 1 : # If the window was properly closed (Done button) then creation was successful # Copy dataspec_tools and print to console clear_data ( window ) window . set_dataspec ( window . get_dataspec_window () . get_dataspec ()) window . console_print ( f \"DataSpec file created\" ) load_dataspec ( window ) window . update_header () save_dataspec ( window ) else : # Warn user that window was improperly closed and that no dataspec_tools was created window . console_print ( \"No DataSpec file was created\" ) Populate the GUI with data from the currently loaded dataspec. Actions: - Adds all dataspec labels to the file selection list. - Selects all items by default. - Populates the plot-type combobox with device-appropriate plotting functions.","title":"Parameters"},{"location":"api/gui/utils/#gui.utils.dataspec_tools.load_dataspec.load_dataspec--raises","text":"IncompatibleDeviceTypeFound If the dataspec\u2019s device type does not match available plot handlers.","title":"Raises"},{"location":"api/gui/utils/#gui.utils.dataspec_tools.load_dataspec.load_dataspec--parameters","text":"window : QMainWindow GUI instance holding a loaded dataspec. Source code in gui\\utils\\dataspec_tools\\load_dataspec.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @with_logging def load_dataspec ( window : QtWidgets . QMainWindow ): \"\"\" Populate the GUI with data from the currently loaded dataspec. Actions: - Adds all dataspec labels to the file selection list. - Selects all items by default. - Populates the plot-type combobox with device-appropriate plotting functions. Raises ------ IncompatibleDeviceTypeFound If the dataspec\u2019s device type does not match available plot handlers. Parameters ---------- window : QMainWindow GUI instance holding a loaded dataspec. \"\"\" # Add all top level keys to the selection list of the gui for label in window . dataspec . get_labels (): window . selectedFilesList . addItem ( label ) # FEATURE REQUEST: Make this a setting # Select all items by default window . selectedFilesList . selectAll () # Edit combobox to show all available plot types try : for function in window . get_plot_functions ( window . get_current_device ()): window . plotTypeCombo . addItem ( function ) except KeyError : window . console_print ( f \"Incompatible device type [ { window . get_current_device () } ] found in { window . get_dataspec_name () } , select another dataspec or implement the device type. DataSpec path: N/A\" ) raise IncompatibleDeviceTypeFound window . console_print ( \"DataSpec loaded\" ) Save the currently loaded dataspec to disk using a file dialog. Behaviour: - Ensures a dataspec is loaded before saving. - Opens a save-file dialog and writes the dataspec via DataSpecJSONEncoder . - Auto-appends a valid extension if necessary. - Updates the stored dataspec location and logs status messages.","title":"Parameters"},{"location":"api/gui/utils/#gui.utils.dataspec_tools.save_dataspec.save_dataspec--parameters","text":"window : QMainWindow GUI window containing the active dataspec. Source code in gui\\utils\\dataspec_tools\\save_dataspec.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @with_logging def save_dataspec ( window : QtWidgets . QMainWindow , * args , ** kwargs ): \"\"\" Save the currently loaded dataspec to disk using a file dialog. Behaviour: - Ensures a dataspec is loaded before saving. - Opens a save-file dialog and writes the dataspec via `DataSpecJSONEncoder`. - Auto-appends a valid extension if necessary. - Updates the stored dataspec location and logs status messages. Parameters ---------- window : QMainWindow GUI window containing the active dataspec. \"\"\" # Make sure there is a dataspec to save if window . get_dataspec_name () is None : return window . console_print ( \"Err: Must first load dataspec\" , level = \"warning\" ) # Run the file dialog # TODO: There's a bug in ubuntu 24 that has the filter reinitialised when navigating the path file_name = QtWidgets . QFileDialog . getSaveFileName ( parent = window , caption = \"Save file to disk\" , filter = \"DataSpecs (*.json *.dataspec *.ds);;All (*)\" , initialFilter = \"DataSpecs (*.json *.dataspec *.ds)\" )[ 0 ] if file_name != \"\" : # Dump the dataspec_tools into a json file and remember the location # TODO: Dataspec should be aware of its location # Ensure the file name has a valid extension if file_name : if not any ( file_name . endswith ( ext ) for ext in ( '.json' , '.dataspec' , '.ds' )): # Default to .dataspec if no valid extension file_name += '.ds' with open ( file_name , \"w\" ) as json_file : current_dataspec = window . get_dataspec () json . dump ( current_dataspec , json_file , cls = fs . DataSpecJSONEncoder ) current_dataspec . set_location ( file_name ) json_file . close () return window . console_print ( f \"Saved dataspec file to { file_name } \" ) else : # File dialog was exited without choosing a file return window . console_print ( f \"No file selected\" )","title":"Parameters"},{"location":"api/gui/utils/#other","text":"Extract the current value from common Qt widget types. Supported widgets: - QDoubleSpinBox / QSpinBox \u2192 numeric value - QCheckBox \u2192 boolean isChecked - QLineEdit / QComboBox \u2192 text, with \"None\"/\"none\" mapped to None Raises NotImplementedError if the widget type is unsupported.","title":"Other"},{"location":"api/gui/utils/#gui.utils.get_qwidget_value.get_qwidget_value--parameters","text":"widget : QWidget The widget whose value should be extracted.","title":"Parameters"},{"location":"api/gui/utils/#gui.utils.get_qwidget_value.get_qwidget_value--returns","text":"Any The widget's value in a Python-friendly type. Source code in gui\\utils\\get_qwidget_value.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def get_qwidget_value ( widget ): \"\"\" Extract the current value from common Qt widget types. Supported widgets: - QDoubleSpinBox / QSpinBox \u2192 numeric value - QCheckBox \u2192 boolean `isChecked` - QLineEdit / QComboBox \u2192 text, with \"None\"/\"none\" mapped to `None` Raises `NotImplementedError` if the widget type is unsupported. Parameters ---------- widget : QWidget The widget whose value should be extracted. Returns ------- Any The widget's value in a Python-friendly type. \"\"\" if not isinstance ( widget , QtWidgets . QWidget ): raise ValueError ( \"Input must be a QWidget instance\" ) if isinstance ( widget , QtWidgets . QDoubleSpinBox ) or isinstance ( widget , QtWidgets . QSpinBox ): return widget . value () elif isinstance ( widget , QtWidgets . QCheckBox ): return widget . isChecked () elif isinstance ( widget , QtWidgets . QLineEdit ): return _cast_none_string_to_none_type ( widget . text ()) elif isinstance ( widget , QtWidgets . QComboBox ): return _cast_none_string_to_none_type ( widget . currentText ()) else : raise NotImplementedError ( f \"Widget type { type ( widget ) } not supported\" ) Find and return the checked QRadioButton within a dialog. Scans all child radio buttons and returns the first active one.","title":"Returns"},{"location":"api/gui/utils/#gui.utils.search_for_first_active_radio_button.search_for_first_active_radio_button--parameters","text":"dialog : QDialog Container widget containing radio buttons.","title":"Parameters"},{"location":"api/gui/utils/#gui.utils.search_for_first_active_radio_button.search_for_first_active_radio_button--returns","text":"QRadioButton or None The checked radio button, or None if no selection exists. Source code in gui\\utils\\search_for_first_active_radio_button.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def search_for_first_active_radio_button ( dialog : QtWidgets . QDialog ) -> QtWidgets . QRadioButton : \"\"\" Find and return the checked QRadioButton within a dialog. Scans all child radio buttons and returns the first active one. Parameters ---------- dialog : QDialog Container widget containing radio buttons. Returns ------- QRadioButton or None The checked radio button, or `None` if no selection exists. \"\"\" for radio_button in dialog . findChildren ( QtWidgets . QRadioButton ): if radio_button . isChecked (): return radio_button return None Split a CamelCase string into its component words.","title":"Returns"},{"location":"api/gui/utils/#gui.utils.split_camelCase.split_camel_case--examples","text":"\"MyPlotType\" \u2192 [\"My\", \"Plot\", \"Type\"]","title":"Examples"},{"location":"api/gui/utils/#gui.utils.split_camelCase.split_camel_case--parameters","text":"camel_case : str Input CamelCase string.","title":"Parameters"},{"location":"api/gui/utils/#gui.utils.split_camelCase.split_camel_case--returns","text":"list[str] List of lowercase/uppercase-correct word segments. Source code in gui\\utils\\split_camelCase.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def split_camel_case ( camel_case ) -> list [ str ]: \"\"\" Split a CamelCase string into its component words. Examples -------- \"MyPlotType\" \u2192 [\"My\", \"Plot\", \"Type\"] Parameters ---------- camel_case : str Input CamelCase string. Returns ------- list[str] List of lowercase/uppercase-correct word segments. \"\"\" return re . findall ( r '[A-Z]?[a-z]+|[A-Z]+(?=[A-Z]|$)' , camel_case )","title":"Returns"},{"location":"api/gui/windows_and_dialogs/","text":"Windows and Dialogs Bases: QMainWindow Main GUI window for interactive, automated plotting of experimental data. Responsibilities Load the main QtDesigner-generated UI file and dynamically attach device- specific option panels to the central QStackedWidget . Manage the currently loaded DataSpec : Creating, loading, saving, and autosaving dataspecs. Displaying raw JSON content and console history in helper dialogs. Updating header fields (set name, device type) when dataspecs change. Integrate logging with a QTextEdit-based console for time-stamped messages. Provide a thin controller layer for: Launching the plotting pipeline via plot_manager . Handling progress updates and console appends. Adding notes and console history back into the dataspec. On construction, the window: - Discovers available devices from implementations.devices . - Loads and registers per-device widgets and their plot functions. - Wires menu actions and buttons to dataspec, plotting, and utility actions. - Optionally auto-opens a demo dataspec if a file name is supplied. The class is intended to be the central hub of the GUI application, with device-specific logic pushed into worker classes and implementations. Source code in gui\\windows\\MainWindow.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 class UiMainWindow ( QtWidgets . QMainWindow ): \"\"\" Main GUI window for interactive, automated plotting of experimental data. Responsibilities ---------------- - Load the main QtDesigner-generated UI file and dynamically attach device- specific option panels to the central `QStackedWidget`. - Manage the currently loaded `DataSpec`: * Creating, loading, saving, and autosaving dataspecs. * Displaying raw JSON content and console history in helper dialogs. * Updating header fields (set name, device type) when dataspecs change. - Integrate logging with a QTextEdit-based console for time-stamped messages. - Provide a thin controller layer for: * Launching the plotting pipeline via `plot_manager`. * Handling progress updates and console appends. * Adding notes and console history back into the dataspec. On construction, the window: - Discovers available devices from `implementations.devices`. - Loads and registers per-device widgets and their plot functions. - Wires menu actions and buttons to dataspec, plotting, and utility actions. - Optionally auto-opens a demo dataspec if a file name is supplied. The class is intended to be the central hub of the GUI application, with device-specific logic pushed into worker classes and implementations. \"\"\" def __init__ ( self , demo_file_name : str = None ): super ( UiMainWindow , self ) . __init__ () self . thread = None self . experiment_worker = None self . dataspec = None # FEATURE REQUEST: Dataspec file location is def'ed here self . dataspec_location = None # Load the UI, Note that loadUI adds objects to 'self' using objectName self . dataWindow = None uic . loadUi ( constants . WINDOW_PATH , self ) # Read the config file self . config = read_config ( constants . CONFIG_PATH ) # Create/Get a logger with the desired settings self . logger = logging . getLogger ( constants . LOG_NAME ) self . consoleTextEdit . setFormatter ( logging . Formatter ( \" %(asctime)s [ %(levelname)8.8s ] %(message)s \" , datefmt = f ' { constants . DATETIME_FORMAT } : ' ) ) self . logger . addHandler ( self . consoleTextEdit ) self . logger . setLevel ( self . config [ 'log_level' ]) self . plot_functions = {} self . devices = {} # Get list of devices as defined manually in the.devices __init__.py file for entry in devices . __all__ : # Find and load the widget for any given device and add it to the stackedWidget entry_ui_file = entry . lower () + \".ui\" entry_widget = uic . loadUi ( constants . WIDGET_PATH + entry_ui_file ) entry_index = self . stackedWidget . addWidget ( entry_widget ) self . devices [ entry ] = entry_index # Import the corresponding module and get the class methods to set the plot_functions combobox when needed module = importlib . import_module ( f \" { devices . workers . __name__ } . { entry . lower () } \" ) entry_cls = getattr ( module , entry ) self . plot_functions [ entry ] = get_class_methods ( entry_cls , ignore = [ \"run\" ]) # Reset stacked widget to empty page self . stackedWidget . setCurrentWidget ( self . stackedWidget . widget ( 0 )) # Define menubar actions self . actionCreate_Set . triggered . connect ( partial ( create_dataspec , self )) self . actionSave_Set . triggered . connect ( partial ( save_dataspec , self )) self . actionLoad_Set . triggered . connect ( partial ( open_dataspec_file , self )) self . actionPreferences . triggered . connect ( self . not_implemented ) self . actionQuit . triggered . connect ( self . quit ) self . actionSave_format . triggered . connect ( self . not_implemented ) self . actionColour_scheme . triggered . connect ( self . not_implemented ) self . actionLine_width . triggered . connect ( self . not_implemented ) self . actionDocumentation . triggered . connect ( self . navigate_to_docs ) self . actionAbout . triggered . connect ( self . show_about ) # Define gui button actions self . showDataBtn . clicked . connect ( self . display_data ) self . showHistoryBtn . clicked . connect ( self . display_history ) self . addNotesBtn . clicked . connect ( self . add_notes ) self . appendBtn . clicked . connect ( self . append_console_to_set ) self . clearBtn . clicked . connect ( partial ( clear_data , window = self )) self . clearAllBtn . clicked . connect ( partial ( clear_all , window = self )) self . quitBtn . clicked . connect ( self . quit ) # Define stackedWidget widget actions self . plotBtn . clicked . connect ( partial ( plot_manager , self )) # Make sure the progress bar is cleared self . progressBar . setValue ( 0 ) # Show the app self . show () self . console_print ( \"Program Started\" ) # Getters def get_plot_functions ( self , device = 'Generic' ) -> list : return self . plot_functions [ device ] def get_current_plot_function ( self ) -> str : return self . plotTypeCombo . currentText () def get_current_device ( self ) -> str : return self . dataspec . get_device () def get_dataspec ( self ): return self . dataspec def get_dataspec_name ( self ) -> str : if self . dataspec is None : return None return self . dataspec . get_name () def get_dataspec_window ( self ) -> QtWidgets . QDialog : return self . dataWindow # Setters def set_dataspec_window ( self , dataspec_window : QtWidgets . QDialog ): self . dataWindow = dataspec_window def set_dataspec ( self , dataspec : dataspec_manager . dataspec . DataSpec ): self . dataspec = dataspec # FUNCTIONALITY def autosave ( self ): file_name = self . dataspec . get_location () if file_name is None : return self . console_print ( \"Cannot autosave, no file location known. Open or create dataset first\" ) with open ( file_name , \"w\" ) as json_file : json . dump ( self . dataspec , json_file , cls = dataspec_manager . DataSpecJSONEncoder ) json_file . close () return self . console_print ( f \"Saved dataspec to { file_name } \" ) def display_data ( self ): # Abort if no dataspec was loaded if self . dataspec is None : return self . console_print ( \"Err: Must first load DataSpec\" , level = \"warning\" ) # Pretty print the dataspec in a simple dialog pretty_json = json . dumps ( self . dataspec , indent = 4 , separators = ( ',' , ': ' ), cls = dataspec_manager . DataSpecJSONEncoder ) dialog_print ( window = self , title = f \"DataSpec RAW: { self . dataspec . get_name () } \" , contents = pretty_json ) return None def display_history ( self ): if self . dataspec is None : return self . console_print ( \"Err: Must first load DataSpec\" , level = \"warning\" ) # Prints only the console history to a simple dialog pretty_history = \"\" for k , v in sorted ( self . dataspec . get_console () . items ()): line = f \" { v } \\n \" pretty_history += line dialog_print ( window = self , title = f \"DataSpec History: { self . dataspec . get_name () } \" , contents = pretty_history ) return None def add_notes ( self ): if self . dataspec is None : return self . console_print ( \"Err: Must first load DataSpec\" , level = \"warning\" ) # Add any notes to the dataspec_manager with a trailing new line self . dataspec . add_notes ( self . notesPlainText . toPlainText () + \" \\n \" ) self . console_print ( \"Notes added to dataspec_manager\" ) self . autosave () return None def update_header ( self ): # Header should reflect opened dataspec self . currSetNameLineEdit . setText ( self . dataspec . get_name ()) self . currDeviceLineEdit . setText ( self . dataspec . get_device ()) # Stacked widget should show the correct widget for the opened dataspec new_page = self . stackedWidget . widget ( self . devices [ self . dataspec . get_device ()]) self . stackedWidget . setCurrentWidget ( new_page ) def report_progress ( self , progress : int ): if not ( isinstance ( progress , int ) and 0 <= progress <= 100 ): raise ValueError ( \"Progress must be an integer between 0 and 100\" ) self . progressBar . setValue ( progress ) def save_to_file ( self , plaintext : str ): file_dialog = QtWidgets . QFileDialog . getSaveFileName ( self , \"Save File\" , \"\" , \"Text Files (*.txt);;All Files (*)\" ) if file_dialog [ 0 ]: # Check if a file was selected file_path = file_dialog [ 0 ] with open ( file_path , 'w' ) as file : file . write ( plaintext ) def console_print ( self , fstring , level = \"normal\" ): # Print a message to the gui console now = datetime . datetime . now () fstring_to_print = now . strftime ( f \" { constants . DATETIME_FORMAT } : \" ) + fstring c = ConsoleColours () self . consoleTextEdit . setTextColor ( c . get_colour ( level )) self . consoleTextEdit . append ( fstring_to_print ) self . consoleTextEdit . setTextColor ( c . get_colour ( \"normal\" )) def append_console_to_set ( self ): if self . dataspec is None : return self . console_print ( \"Err: Must first load DataSpec\" , level = \"warning\" ) # Append console contents to the dataspec_manager console_text = self . consoleTextEdit . toPlainText () now = datetime . datetime . now () self . dataspec . add_console ( now . strftime ( constants . DATETIME_FORMAT ), console_text ) self . console_print ( \"Added console contents to set\" ) self . autosave () return None def show_about ( self ): \"\"\" Shows a simple window with licence, authorship and build information \"\"\" # Grab the \"about\" info from about.txt with open ( constants . ABOUT_PATH ) as about_file : about_contents = about_file . read () about_dialog = generate_about_dialog ( about_contents , self . centralWidget (), constants . LOGO_PATH ) # Show the about dialog about_dialog . exec_ () def navigate_to_docs ( self ): \"\"\" Opens the default web browser and navigates to the documentation URL. \"\"\" import webbrowser webbrowser . open ( constants . DOCS_URL ) def not_implemented ( self ): \"\"\" Shows the user a message that the current feature is planned but not yet implemented. \"\"\" self . console_print ( \"Feature not implemented\" , level = 'warning' ) # ESC now triggers a program exit def keyPressEvent ( self , event ) -> None : if event . key () == QtCore . Qt . Key . Key_Escape : self . quit () else : super ( UiMainWindow , self ) . keyPressEvent ( event ) # CHECK: Program exit is not safe @staticmethod def quit (): # Terminate the application sys . exit () navigate_to_docs () Opens the default web browser and navigates to the documentation URL. Source code in gui\\windows\\MainWindow.py 289 290 291 292 293 294 def navigate_to_docs ( self ): \"\"\" Opens the default web browser and navigates to the documentation URL. \"\"\" import webbrowser webbrowser . open ( constants . DOCS_URL ) not_implemented () Shows the user a message that the current feature is planned but not yet implemented. Source code in gui\\windows\\MainWindow.py 296 297 298 299 300 def not_implemented ( self ): \"\"\" Shows the user a message that the current feature is planned but not yet implemented. \"\"\" self . console_print ( \"Feature not implemented\" , level = 'warning' ) show_about () Shows a simple window with licence, authorship and build information Source code in gui\\windows\\MainWindow.py 276 277 278 279 280 281 282 283 284 285 286 287 def show_about ( self ): \"\"\" Shows a simple window with licence, authorship and build information \"\"\" # Grab the \"about\" info from about.txt with open ( constants . ABOUT_PATH ) as about_file : about_contents = about_file . read () about_dialog = generate_about_dialog ( about_contents , self . centralWidget (), constants . LOGO_PATH ) # Show the about dialog about_dialog . exec_ () Bases: QDialog Dialog for interactively creating new DataSpec instances. Overview This window guides the user through constructing a dataspec by: - Selecting a device type from a combobox. - Adding individual files with custom labels, or - Auto-generating filepaths from a directory according to a chosen structure. - Setting the experiment name and experiment date/time. Behaviour Maintains an internal DataSpec object that is updated as the user adds files or generates sets from directories. Displays the current file mapping as formatted JSON in a plain-text widget. Validates that both a name and at least one file are present before enabling the \u201cDone\u201d button. On completion ( finish ), writes name, device type, and experiment datetime into the dataspec and closes with an accepted result. Parameters devices : list[str], optional List of available device names to present in the device selection combo box. Defaults to a single \"N/A\" entry when not specified. Source code in gui\\windows\\DataSpecCreatorWindow.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class UiDataCreatorWindow ( QtWidgets . QDialog ): \"\"\" Dialog for interactively creating new `DataSpec` instances. Overview -------- This window guides the user through constructing a dataspec by: - Selecting a device type from a combobox. - Adding individual files with custom labels, or - Auto-generating filepaths from a directory according to a chosen structure. - Setting the experiment name and experiment date/time. Behaviour --------- - Maintains an internal `DataSpec` object that is updated as the user adds files or generates sets from directories. - Displays the current file mapping as formatted JSON in a plain-text widget. - Validates that both a name and at least one file are present before enabling the \u201cDone\u201d button. - On completion (`finish`), writes name, device type, and experiment datetime into the dataspec and closes with an accepted result. Parameters ---------- devices : list[str], optional List of available device names to present in the device selection combo box. Defaults to a single `\"N/A\"` entry when not specified. \"\"\" def __init__ ( self , devices : list [ str ] = [ \"N/A\" ]): super ( UiDataCreatorWindow , self ) . __init__ () # Load the UI, # Note that loadUI adds objects to 'self' using objectName uic . loadUi ( \"gui/windows/DataSpecCreatorWindow.ui\" , self ) self . dataspec = dataspec_manager . DataSpec ( datetime . datetime . now () . strftime ( \"%Y.%m. %d _%H.%M.%S\" )) # Add the correct devices to the experiment combo box self . dataTypeCombo . addItems ( devices ) # Set date to today by default self . dateTimeEdit . setDateTime ( datetime . datetime . now ()) # Set starting tab to manual dataspec creation self . tabWidget . setCurrentIndex ( 0 ) # Define widget action self . browseFilesBtn . clicked . connect ( self . browse_files ) self . browseDirBtn . clicked . connect ( self . browse_dir ) self . addLabelBtn . clicked . connect ( self . add_file_to_set ) self . generateBtn . clicked . connect ( self . generate_set ) self . resetBtn . clicked . connect ( self . reset ) self . doneBtn . clicked . connect ( self . finish ) # Enable button when all is filled self . showSetPlainText . textChanged . connect ( self . button_state ) self . nameEdit . textChanged . connect ( self . button_state ) # Show the app self . show () def get_dataspec ( self ) -> dataspec_manager . dataspec . DataSpec : return self . dataspec def browse_files ( self ): \"\"\" # Open file selection dialog to get a file path and update gui when confirmed \"\"\" file_name = QtWidgets . QFileDialog . getOpenFileName ( self , \"Open File\" ) self . browseFilesText . setPlainText ( file_name [ 0 ]) def browse_dir ( self ): \"\"\" # Open directory selection dialog to get a path and update gui when confirmed \"\"\" dir_name = QtWidgets . QFileDialog . getExistingDirectory ( self , 'Select Directory' ) self . browseDirText . setPlainText ( dir_name ) def add_file_to_set ( self ): \"\"\" # Gets the path and label and adds it to the current DataSpec instance while updating GUI \"\"\" # Read name and legend label from gui file_name = self . browseFilesText . toPlainText () file_label = self . labelEdit . text () # Check for duplicate label if file_label in self . dataspec . get_labels (): self . show_message ( title = \"Duplicate Label\" , message = \"\"\"This label has already been used. Choose another label and try again.\"\"\" ) else : # Add the file to the dataset and update the gui self . dataspec . set_structure_type ( \"flat\" ) self . dataspec . add_filepath ( file_name , file_label ) self . showSetPlainText . setPlainText ( json . dumps ( self . dataspec . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . browseFilesText . clear () # Empty label widget self . labelEdit . clear () def generate_set ( self ): \"\"\" Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired \"\"\" path = self . browseDirText . toPlainText () # If path is not selected, show message and return None if not path : self . show_message ( title = \"No directory selected\" , message = \"\"\"No directory was selected, please select directory and try again\"\"\" ) return None # Construct the filepaths for this dataspec active_button = split_camel_case ( search_for_first_active_radio_button ( self ) . objectName ())[ 0 ] errors = self . dataspec . construct_filepaths ( root_dir = path , type = active_button ) # Show the directories/files that were ignored to the user if errors != \"\" : self . show_message ( title = \"Files were ignored\" , message = errors ) # Show the files in the gui self . showSetPlainText . setPlainText ( json . dumps ( self . dataspec . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . dataspec . set_structure_type ( active_button ) def button_state ( self ): \"\"\" Only enable closing when some data was included \"\"\" # TODO: hmmmmmmmmmmmm, should I be able to close the window if I mistakenly opened it? nameTxt = self . nameEdit . text () files = self . showSetPlainText . toPlainText () if ( files != \"\" ) and ( nameTxt != \"\" ): self . doneBtn . setEnabled ( True ) else : self . doneBtn . setEnabled ( False ) @staticmethod def show_message ( title , message ): msg = QtWidgets . QMessageBox () msg . setWindowTitle ( title ) msg . setText ( message ) x = msg . exec_ () def reset ( self ): \"\"\" Completely reset this UI by clearing all elements \"\"\" self . nameEdit . clear () self . labelEdit . clear () self . browseDirText . clear () self . browseFilesText . clear () self . showSetPlainText . clear () self . button_state () def finish ( self ): \"\"\" Add name, device type, and date and time dataspec before exiting \"\"\" self . dataspec . set_name ( self . nameEdit . text ()) self . dataspec . set_device ( self . dataTypeCombo . currentText ()) experiment_date_time = self . dateTimeEdit . dateTime () . toPyDateTime () . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) self . dataspec . set_experiment_date ( experiment_date_time ) self . done ( 1 ) add_file_to_set () Gets the path and label and adds it to the current DataSpec instance while updating GUI Source code in gui\\windows\\DataSpecCreatorWindow.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def add_file_to_set ( self ): \"\"\" # Gets the path and label and adds it to the current DataSpec instance while updating GUI \"\"\" # Read name and legend label from gui file_name = self . browseFilesText . toPlainText () file_label = self . labelEdit . text () # Check for duplicate label if file_label in self . dataspec . get_labels (): self . show_message ( title = \"Duplicate Label\" , message = \"\"\"This label has already been used. Choose another label and try again.\"\"\" ) else : # Add the file to the dataset and update the gui self . dataspec . set_structure_type ( \"flat\" ) self . dataspec . add_filepath ( file_name , file_label ) self . showSetPlainText . setPlainText ( json . dumps ( self . dataspec . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . browseFilesText . clear () # Empty label widget self . labelEdit . clear () browse_dir () Open directory selection dialog to get a path and update gui when confirmed Source code in gui\\windows\\DataSpecCreatorWindow.py 82 83 84 85 86 87 def browse_dir ( self ): \"\"\" # Open directory selection dialog to get a path and update gui when confirmed \"\"\" dir_name = QtWidgets . QFileDialog . getExistingDirectory ( self , 'Select Directory' ) self . browseDirText . setPlainText ( dir_name ) browse_files () Open file selection dialog to get a file path and update gui when confirmed Source code in gui\\windows\\DataSpecCreatorWindow.py 75 76 77 78 79 80 def browse_files ( self ): \"\"\" # Open file selection dialog to get a file path and update gui when confirmed \"\"\" file_name = QtWidgets . QFileDialog . getOpenFileName ( self , \"Open File\" ) self . browseFilesText . setPlainText ( file_name [ 0 ]) button_state () Only enable closing when some data was included Source code in gui\\windows\\DataSpecCreatorWindow.py 148 149 150 151 152 153 154 155 156 def button_state ( self ): \"\"\" Only enable closing when some data was included \"\"\" # TODO: hmmmmmmmmmmmm, should I be able to close the window if I mistakenly opened it? nameTxt = self . nameEdit . text () files = self . showSetPlainText . toPlainText () if ( files != \"\" ) and ( nameTxt != \"\" ): self . doneBtn . setEnabled ( True ) else : self . doneBtn . setEnabled ( False ) finish () Add name, device type, and date and time dataspec before exiting Source code in gui\\windows\\DataSpecCreatorWindow.py 174 175 176 177 178 179 180 181 def finish ( self ): \"\"\" Add name, device type, and date and time dataspec before exiting \"\"\" self . dataspec . set_name ( self . nameEdit . text ()) self . dataspec . set_device ( self . dataTypeCombo . currentText ()) experiment_date_time = self . dateTimeEdit . dateTime () . toPyDateTime () . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) self . dataspec . set_experiment_date ( experiment_date_time ) self . done ( 1 ) generate_set () Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired Source code in gui\\windows\\DataSpecCreatorWindow.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def generate_set ( self ): \"\"\" Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired \"\"\" path = self . browseDirText . toPlainText () # If path is not selected, show message and return None if not path : self . show_message ( title = \"No directory selected\" , message = \"\"\"No directory was selected, please select directory and try again\"\"\" ) return None # Construct the filepaths for this dataspec active_button = split_camel_case ( search_for_first_active_radio_button ( self ) . objectName ())[ 0 ] errors = self . dataspec . construct_filepaths ( root_dir = path , type = active_button ) # Show the directories/files that were ignored to the user if errors != \"\" : self . show_message ( title = \"Files were ignored\" , message = errors ) # Show the files in the gui self . showSetPlainText . setPlainText ( json . dumps ( self . dataspec . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . dataspec . set_structure_type ( active_button ) reset () Completely reset this UI by clearing all elements Source code in gui\\windows\\DataSpecCreatorWindow.py 165 166 167 168 169 170 171 172 def reset ( self ): \"\"\" Completely reset this UI by clearing all elements \"\"\" self . nameEdit . clear () self . labelEdit . clear () self . browseDirText . clear () self . browseFilesText . clear () self . showSetPlainText . clear () self . button_state () Bases: Handler , QTextEdit QTextEdit-based logging console widget for the GUI. This class bridges the logging module with a Qt text widget by: - Subclassing both logging.Handler and QTextEdit . - Emitting formatted log messages through a dedicated Qt signal ( appendTextEdit ), which is connected to the widget's append slot. - Keeping the text area read-only so it behaves like a console. Typical usage Create an instance and add it as a handler to a logging.Logger . Configure a formatter for the handler. Logged messages will appear in the GUI with the configured format. Parameters parent : QWidget Parent widget that will own this console. Source code in gui\\windows\\qtexteditconsole.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class QTextEditConsole ( logging . Handler , QtWidgets . QTextEdit ): \"\"\" QTextEdit-based logging console widget for the GUI. This class bridges the `logging` module with a Qt text widget by: - Subclassing both `logging.Handler` and `QTextEdit`. - Emitting formatted log messages through a dedicated Qt signal (`appendTextEdit`), which is connected to the widget's `append` slot. - Keeping the text area read-only so it behaves like a console. Typical usage ------------- - Create an instance and add it as a handler to a `logging.Logger`. - Configure a formatter for the handler. - Logged messages will appear in the GUI with the configured format. Parameters ---------- parent : QWidget Parent widget that will own this console. \"\"\" appendTextEdit = QtCore . pyqtSignal ( str ) def __init__ ( self , parent ): logging . Handler . __init__ ( self ) super ( QtWidgets . QTextEdit , self ) . __init__ ( parent ) self . setReadOnly ( True ) self . appendTextEdit . connect ( self . append ) def emit ( self , record ): msg = self . format ( record ) self . appendTextEdit . emit ( msg ) Display text content inside a modal dialog with optional saving. The dialog contains: - A read-only text editor showing contents . - \u201cOK\u201d to close the dialog. - \u201cSAVE\u201d to delegate saving via window.save_to_file . Parameters window : QMainWindow Parent window providing the save callback. title : str Dialog title bar text. contents : str Text content to display. Source code in gui\\windows\\dialogs\\dialog_print.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def dialog_print ( window : QtWidgets . QMainWindow , title , contents ): \"\"\" Display text content inside a modal dialog with optional saving. The dialog contains: - A read-only text editor showing `contents`. - \u201cOK\u201d to close the dialog. - \u201cSAVE\u201d to delegate saving via `window.save_to_file`. Parameters ---------- window : QMainWindow Parent window providing the save callback. title : str Dialog title bar text. contents : str Text content to display. \"\"\" # Prepare a text edit widget to host the contents history_text_edit = QtWidgets . QTextEdit ( window ) history_text_edit . setPlainText ( contents ) # Initialise the window dialog = QtWidgets . QDialog ( window ) dialog . setWindowTitle ( title ) # Set a default width and minimum height for the dialog dialog . resize ( 600 , 400 ) # Create a QVBoxLayout for the dialog layout = QtWidgets . QVBoxLayout ( dialog ) # Add the QTextEdit widget to the layout layout . addWidget ( history_text_edit ) # Create a QHBoxLayout and host buttons button_layout = QtWidgets . QHBoxLayout () ok_button = QtWidgets . QPushButton ( \"OK\" ) save_button = QtWidgets . QPushButton ( \"SAVE\" ) button_layout . addWidget ( ok_button ) button_layout . addWidget ( save_button ) # Add the button layout to the main layout layout . addLayout ( button_layout ) # Connect the \"OK\" button to close the dialog ok_button . clicked . connect ( dialog . accept ) save_button . clicked . connect ( lambda : window . save_to_file ( contents )) # Show the dialog dialog . exec_ () Build and return an 'About' information dialog containing a logo and text. Features: - Displays an application logo loaded via QPixmap. - Shows about text with HTML formatting support. - Uses a fixed-size vertical layout. Parameters about_contents : str HTML/markdown-like text describing the application. centralwidget : QWidget Parent widget for modal behavior. logo_path : str Directory path to the logo image file. Returns QDialog Configured dialog ready to be shown. Source code in gui\\windows\\dialogs\\generate_about_dialog.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def generate_about_dialog ( about_contents , centralwidget , logo_path ): \"\"\" Build and return an 'About' information dialog containing a logo and text. Features: - Displays an application logo loaded via QPixmap. - Shows about text with HTML formatting support. - Uses a fixed-size vertical layout. Parameters ---------- about_contents : str HTML/markdown-like text describing the application. centralwidget : QWidget Parent widget for modal behavior. logo_path : str Directory path to the logo image file. Returns ------- QDialog Configured dialog ready to be shown. \"\"\" # Create a custom QDialog for the about information about_dialog = QtWidgets . QDialog ( centralwidget ) about_dialog . setWindowTitle ( \"About\" ) # Set the fixed size of the dialog about_dialog . setFixedSize ( 650 , 700 ) # Adjust the dimensions as needed # Load and set the image using QPixmap (make sure the path is correct) pixmap = QtGui . QPixmap ( logo_path + \"X_logo_x-lab_baseline_KL.png\" ) pixmap = pixmap . scaled ( 600 , 200 , QtCore . Qt . KeepAspectRatio ) image_label = QtWidgets . QLabel ( about_dialog ) image_label . setPixmap ( pixmap ) # Create a QLabel for the text (using HTML formatting) text_label = QtWidgets . QLabel ( about_dialog ) text_label . setWordWrap ( True ) text_label . setText ( about_contents ) # Create a QVBoxLayout for the dialog and add the image and text labels layout = QtWidgets . QVBoxLayout ( about_dialog ) layout . addWidget ( image_label ) layout . addWidget ( text_label ) about_dialog . setLayout ( layout ) return about_dialog","title":"GUI - Windows"},{"location":"api/gui/windows_and_dialogs/#windows-and-dialogs","text":"Bases: QMainWindow Main GUI window for interactive, automated plotting of experimental data.","title":"Windows and Dialogs"},{"location":"api/gui/windows_and_dialogs/#gui.windows.MainWindow.UiMainWindow--responsibilities","text":"Load the main QtDesigner-generated UI file and dynamically attach device- specific option panels to the central QStackedWidget . Manage the currently loaded DataSpec : Creating, loading, saving, and autosaving dataspecs. Displaying raw JSON content and console history in helper dialogs. Updating header fields (set name, device type) when dataspecs change. Integrate logging with a QTextEdit-based console for time-stamped messages. Provide a thin controller layer for: Launching the plotting pipeline via plot_manager . Handling progress updates and console appends. Adding notes and console history back into the dataspec. On construction, the window: - Discovers available devices from implementations.devices . - Loads and registers per-device widgets and their plot functions. - Wires menu actions and buttons to dataspec, plotting, and utility actions. - Optionally auto-opens a demo dataspec if a file name is supplied. The class is intended to be the central hub of the GUI application, with device-specific logic pushed into worker classes and implementations. Source code in gui\\windows\\MainWindow.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 class UiMainWindow ( QtWidgets . QMainWindow ): \"\"\" Main GUI window for interactive, automated plotting of experimental data. Responsibilities ---------------- - Load the main QtDesigner-generated UI file and dynamically attach device- specific option panels to the central `QStackedWidget`. - Manage the currently loaded `DataSpec`: * Creating, loading, saving, and autosaving dataspecs. * Displaying raw JSON content and console history in helper dialogs. * Updating header fields (set name, device type) when dataspecs change. - Integrate logging with a QTextEdit-based console for time-stamped messages. - Provide a thin controller layer for: * Launching the plotting pipeline via `plot_manager`. * Handling progress updates and console appends. * Adding notes and console history back into the dataspec. On construction, the window: - Discovers available devices from `implementations.devices`. - Loads and registers per-device widgets and their plot functions. - Wires menu actions and buttons to dataspec, plotting, and utility actions. - Optionally auto-opens a demo dataspec if a file name is supplied. The class is intended to be the central hub of the GUI application, with device-specific logic pushed into worker classes and implementations. \"\"\" def __init__ ( self , demo_file_name : str = None ): super ( UiMainWindow , self ) . __init__ () self . thread = None self . experiment_worker = None self . dataspec = None # FEATURE REQUEST: Dataspec file location is def'ed here self . dataspec_location = None # Load the UI, Note that loadUI adds objects to 'self' using objectName self . dataWindow = None uic . loadUi ( constants . WINDOW_PATH , self ) # Read the config file self . config = read_config ( constants . CONFIG_PATH ) # Create/Get a logger with the desired settings self . logger = logging . getLogger ( constants . LOG_NAME ) self . consoleTextEdit . setFormatter ( logging . Formatter ( \" %(asctime)s [ %(levelname)8.8s ] %(message)s \" , datefmt = f ' { constants . DATETIME_FORMAT } : ' ) ) self . logger . addHandler ( self . consoleTextEdit ) self . logger . setLevel ( self . config [ 'log_level' ]) self . plot_functions = {} self . devices = {} # Get list of devices as defined manually in the.devices __init__.py file for entry in devices . __all__ : # Find and load the widget for any given device and add it to the stackedWidget entry_ui_file = entry . lower () + \".ui\" entry_widget = uic . loadUi ( constants . WIDGET_PATH + entry_ui_file ) entry_index = self . stackedWidget . addWidget ( entry_widget ) self . devices [ entry ] = entry_index # Import the corresponding module and get the class methods to set the plot_functions combobox when needed module = importlib . import_module ( f \" { devices . workers . __name__ } . { entry . lower () } \" ) entry_cls = getattr ( module , entry ) self . plot_functions [ entry ] = get_class_methods ( entry_cls , ignore = [ \"run\" ]) # Reset stacked widget to empty page self . stackedWidget . setCurrentWidget ( self . stackedWidget . widget ( 0 )) # Define menubar actions self . actionCreate_Set . triggered . connect ( partial ( create_dataspec , self )) self . actionSave_Set . triggered . connect ( partial ( save_dataspec , self )) self . actionLoad_Set . triggered . connect ( partial ( open_dataspec_file , self )) self . actionPreferences . triggered . connect ( self . not_implemented ) self . actionQuit . triggered . connect ( self . quit ) self . actionSave_format . triggered . connect ( self . not_implemented ) self . actionColour_scheme . triggered . connect ( self . not_implemented ) self . actionLine_width . triggered . connect ( self . not_implemented ) self . actionDocumentation . triggered . connect ( self . navigate_to_docs ) self . actionAbout . triggered . connect ( self . show_about ) # Define gui button actions self . showDataBtn . clicked . connect ( self . display_data ) self . showHistoryBtn . clicked . connect ( self . display_history ) self . addNotesBtn . clicked . connect ( self . add_notes ) self . appendBtn . clicked . connect ( self . append_console_to_set ) self . clearBtn . clicked . connect ( partial ( clear_data , window = self )) self . clearAllBtn . clicked . connect ( partial ( clear_all , window = self )) self . quitBtn . clicked . connect ( self . quit ) # Define stackedWidget widget actions self . plotBtn . clicked . connect ( partial ( plot_manager , self )) # Make sure the progress bar is cleared self . progressBar . setValue ( 0 ) # Show the app self . show () self . console_print ( \"Program Started\" ) # Getters def get_plot_functions ( self , device = 'Generic' ) -> list : return self . plot_functions [ device ] def get_current_plot_function ( self ) -> str : return self . plotTypeCombo . currentText () def get_current_device ( self ) -> str : return self . dataspec . get_device () def get_dataspec ( self ): return self . dataspec def get_dataspec_name ( self ) -> str : if self . dataspec is None : return None return self . dataspec . get_name () def get_dataspec_window ( self ) -> QtWidgets . QDialog : return self . dataWindow # Setters def set_dataspec_window ( self , dataspec_window : QtWidgets . QDialog ): self . dataWindow = dataspec_window def set_dataspec ( self , dataspec : dataspec_manager . dataspec . DataSpec ): self . dataspec = dataspec # FUNCTIONALITY def autosave ( self ): file_name = self . dataspec . get_location () if file_name is None : return self . console_print ( \"Cannot autosave, no file location known. Open or create dataset first\" ) with open ( file_name , \"w\" ) as json_file : json . dump ( self . dataspec , json_file , cls = dataspec_manager . DataSpecJSONEncoder ) json_file . close () return self . console_print ( f \"Saved dataspec to { file_name } \" ) def display_data ( self ): # Abort if no dataspec was loaded if self . dataspec is None : return self . console_print ( \"Err: Must first load DataSpec\" , level = \"warning\" ) # Pretty print the dataspec in a simple dialog pretty_json = json . dumps ( self . dataspec , indent = 4 , separators = ( ',' , ': ' ), cls = dataspec_manager . DataSpecJSONEncoder ) dialog_print ( window = self , title = f \"DataSpec RAW: { self . dataspec . get_name () } \" , contents = pretty_json ) return None def display_history ( self ): if self . dataspec is None : return self . console_print ( \"Err: Must first load DataSpec\" , level = \"warning\" ) # Prints only the console history to a simple dialog pretty_history = \"\" for k , v in sorted ( self . dataspec . get_console () . items ()): line = f \" { v } \\n \" pretty_history += line dialog_print ( window = self , title = f \"DataSpec History: { self . dataspec . get_name () } \" , contents = pretty_history ) return None def add_notes ( self ): if self . dataspec is None : return self . console_print ( \"Err: Must first load DataSpec\" , level = \"warning\" ) # Add any notes to the dataspec_manager with a trailing new line self . dataspec . add_notes ( self . notesPlainText . toPlainText () + \" \\n \" ) self . console_print ( \"Notes added to dataspec_manager\" ) self . autosave () return None def update_header ( self ): # Header should reflect opened dataspec self . currSetNameLineEdit . setText ( self . dataspec . get_name ()) self . currDeviceLineEdit . setText ( self . dataspec . get_device ()) # Stacked widget should show the correct widget for the opened dataspec new_page = self . stackedWidget . widget ( self . devices [ self . dataspec . get_device ()]) self . stackedWidget . setCurrentWidget ( new_page ) def report_progress ( self , progress : int ): if not ( isinstance ( progress , int ) and 0 <= progress <= 100 ): raise ValueError ( \"Progress must be an integer between 0 and 100\" ) self . progressBar . setValue ( progress ) def save_to_file ( self , plaintext : str ): file_dialog = QtWidgets . QFileDialog . getSaveFileName ( self , \"Save File\" , \"\" , \"Text Files (*.txt);;All Files (*)\" ) if file_dialog [ 0 ]: # Check if a file was selected file_path = file_dialog [ 0 ] with open ( file_path , 'w' ) as file : file . write ( plaintext ) def console_print ( self , fstring , level = \"normal\" ): # Print a message to the gui console now = datetime . datetime . now () fstring_to_print = now . strftime ( f \" { constants . DATETIME_FORMAT } : \" ) + fstring c = ConsoleColours () self . consoleTextEdit . setTextColor ( c . get_colour ( level )) self . consoleTextEdit . append ( fstring_to_print ) self . consoleTextEdit . setTextColor ( c . get_colour ( \"normal\" )) def append_console_to_set ( self ): if self . dataspec is None : return self . console_print ( \"Err: Must first load DataSpec\" , level = \"warning\" ) # Append console contents to the dataspec_manager console_text = self . consoleTextEdit . toPlainText () now = datetime . datetime . now () self . dataspec . add_console ( now . strftime ( constants . DATETIME_FORMAT ), console_text ) self . console_print ( \"Added console contents to set\" ) self . autosave () return None def show_about ( self ): \"\"\" Shows a simple window with licence, authorship and build information \"\"\" # Grab the \"about\" info from about.txt with open ( constants . ABOUT_PATH ) as about_file : about_contents = about_file . read () about_dialog = generate_about_dialog ( about_contents , self . centralWidget (), constants . LOGO_PATH ) # Show the about dialog about_dialog . exec_ () def navigate_to_docs ( self ): \"\"\" Opens the default web browser and navigates to the documentation URL. \"\"\" import webbrowser webbrowser . open ( constants . DOCS_URL ) def not_implemented ( self ): \"\"\" Shows the user a message that the current feature is planned but not yet implemented. \"\"\" self . console_print ( \"Feature not implemented\" , level = 'warning' ) # ESC now triggers a program exit def keyPressEvent ( self , event ) -> None : if event . key () == QtCore . Qt . Key . Key_Escape : self . quit () else : super ( UiMainWindow , self ) . keyPressEvent ( event ) # CHECK: Program exit is not safe @staticmethod def quit (): # Terminate the application sys . exit ()","title":"Responsibilities"},{"location":"api/gui/windows_and_dialogs/#gui.windows.MainWindow.UiMainWindow.navigate_to_docs","text":"Opens the default web browser and navigates to the documentation URL. Source code in gui\\windows\\MainWindow.py 289 290 291 292 293 294 def navigate_to_docs ( self ): \"\"\" Opens the default web browser and navigates to the documentation URL. \"\"\" import webbrowser webbrowser . open ( constants . DOCS_URL )","title":"navigate_to_docs"},{"location":"api/gui/windows_and_dialogs/#gui.windows.MainWindow.UiMainWindow.not_implemented","text":"Shows the user a message that the current feature is planned but not yet implemented. Source code in gui\\windows\\MainWindow.py 296 297 298 299 300 def not_implemented ( self ): \"\"\" Shows the user a message that the current feature is planned but not yet implemented. \"\"\" self . console_print ( \"Feature not implemented\" , level = 'warning' )","title":"not_implemented"},{"location":"api/gui/windows_and_dialogs/#gui.windows.MainWindow.UiMainWindow.show_about","text":"Shows a simple window with licence, authorship and build information Source code in gui\\windows\\MainWindow.py 276 277 278 279 280 281 282 283 284 285 286 287 def show_about ( self ): \"\"\" Shows a simple window with licence, authorship and build information \"\"\" # Grab the \"about\" info from about.txt with open ( constants . ABOUT_PATH ) as about_file : about_contents = about_file . read () about_dialog = generate_about_dialog ( about_contents , self . centralWidget (), constants . LOGO_PATH ) # Show the about dialog about_dialog . exec_ () Bases: QDialog Dialog for interactively creating new DataSpec instances.","title":"show_about"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSpecCreatorWindow.UiDataCreatorWindow--overview","text":"This window guides the user through constructing a dataspec by: - Selecting a device type from a combobox. - Adding individual files with custom labels, or - Auto-generating filepaths from a directory according to a chosen structure. - Setting the experiment name and experiment date/time.","title":"Overview"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSpecCreatorWindow.UiDataCreatorWindow--behaviour","text":"Maintains an internal DataSpec object that is updated as the user adds files or generates sets from directories. Displays the current file mapping as formatted JSON in a plain-text widget. Validates that both a name and at least one file are present before enabling the \u201cDone\u201d button. On completion ( finish ), writes name, device type, and experiment datetime into the dataspec and closes with an accepted result.","title":"Behaviour"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSpecCreatorWindow.UiDataCreatorWindow--parameters","text":"devices : list[str], optional List of available device names to present in the device selection combo box. Defaults to a single \"N/A\" entry when not specified. Source code in gui\\windows\\DataSpecCreatorWindow.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class UiDataCreatorWindow ( QtWidgets . QDialog ): \"\"\" Dialog for interactively creating new `DataSpec` instances. Overview -------- This window guides the user through constructing a dataspec by: - Selecting a device type from a combobox. - Adding individual files with custom labels, or - Auto-generating filepaths from a directory according to a chosen structure. - Setting the experiment name and experiment date/time. Behaviour --------- - Maintains an internal `DataSpec` object that is updated as the user adds files or generates sets from directories. - Displays the current file mapping as formatted JSON in a plain-text widget. - Validates that both a name and at least one file are present before enabling the \u201cDone\u201d button. - On completion (`finish`), writes name, device type, and experiment datetime into the dataspec and closes with an accepted result. Parameters ---------- devices : list[str], optional List of available device names to present in the device selection combo box. Defaults to a single `\"N/A\"` entry when not specified. \"\"\" def __init__ ( self , devices : list [ str ] = [ \"N/A\" ]): super ( UiDataCreatorWindow , self ) . __init__ () # Load the UI, # Note that loadUI adds objects to 'self' using objectName uic . loadUi ( \"gui/windows/DataSpecCreatorWindow.ui\" , self ) self . dataspec = dataspec_manager . DataSpec ( datetime . datetime . now () . strftime ( \"%Y.%m. %d _%H.%M.%S\" )) # Add the correct devices to the experiment combo box self . dataTypeCombo . addItems ( devices ) # Set date to today by default self . dateTimeEdit . setDateTime ( datetime . datetime . now ()) # Set starting tab to manual dataspec creation self . tabWidget . setCurrentIndex ( 0 ) # Define widget action self . browseFilesBtn . clicked . connect ( self . browse_files ) self . browseDirBtn . clicked . connect ( self . browse_dir ) self . addLabelBtn . clicked . connect ( self . add_file_to_set ) self . generateBtn . clicked . connect ( self . generate_set ) self . resetBtn . clicked . connect ( self . reset ) self . doneBtn . clicked . connect ( self . finish ) # Enable button when all is filled self . showSetPlainText . textChanged . connect ( self . button_state ) self . nameEdit . textChanged . connect ( self . button_state ) # Show the app self . show () def get_dataspec ( self ) -> dataspec_manager . dataspec . DataSpec : return self . dataspec def browse_files ( self ): \"\"\" # Open file selection dialog to get a file path and update gui when confirmed \"\"\" file_name = QtWidgets . QFileDialog . getOpenFileName ( self , \"Open File\" ) self . browseFilesText . setPlainText ( file_name [ 0 ]) def browse_dir ( self ): \"\"\" # Open directory selection dialog to get a path and update gui when confirmed \"\"\" dir_name = QtWidgets . QFileDialog . getExistingDirectory ( self , 'Select Directory' ) self . browseDirText . setPlainText ( dir_name ) def add_file_to_set ( self ): \"\"\" # Gets the path and label and adds it to the current DataSpec instance while updating GUI \"\"\" # Read name and legend label from gui file_name = self . browseFilesText . toPlainText () file_label = self . labelEdit . text () # Check for duplicate label if file_label in self . dataspec . get_labels (): self . show_message ( title = \"Duplicate Label\" , message = \"\"\"This label has already been used. Choose another label and try again.\"\"\" ) else : # Add the file to the dataset and update the gui self . dataspec . set_structure_type ( \"flat\" ) self . dataspec . add_filepath ( file_name , file_label ) self . showSetPlainText . setPlainText ( json . dumps ( self . dataspec . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . browseFilesText . clear () # Empty label widget self . labelEdit . clear () def generate_set ( self ): \"\"\" Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired \"\"\" path = self . browseDirText . toPlainText () # If path is not selected, show message and return None if not path : self . show_message ( title = \"No directory selected\" , message = \"\"\"No directory was selected, please select directory and try again\"\"\" ) return None # Construct the filepaths for this dataspec active_button = split_camel_case ( search_for_first_active_radio_button ( self ) . objectName ())[ 0 ] errors = self . dataspec . construct_filepaths ( root_dir = path , type = active_button ) # Show the directories/files that were ignored to the user if errors != \"\" : self . show_message ( title = \"Files were ignored\" , message = errors ) # Show the files in the gui self . showSetPlainText . setPlainText ( json . dumps ( self . dataspec . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . dataspec . set_structure_type ( active_button ) def button_state ( self ): \"\"\" Only enable closing when some data was included \"\"\" # TODO: hmmmmmmmmmmmm, should I be able to close the window if I mistakenly opened it? nameTxt = self . nameEdit . text () files = self . showSetPlainText . toPlainText () if ( files != \"\" ) and ( nameTxt != \"\" ): self . doneBtn . setEnabled ( True ) else : self . doneBtn . setEnabled ( False ) @staticmethod def show_message ( title , message ): msg = QtWidgets . QMessageBox () msg . setWindowTitle ( title ) msg . setText ( message ) x = msg . exec_ () def reset ( self ): \"\"\" Completely reset this UI by clearing all elements \"\"\" self . nameEdit . clear () self . labelEdit . clear () self . browseDirText . clear () self . browseFilesText . clear () self . showSetPlainText . clear () self . button_state () def finish ( self ): \"\"\" Add name, device type, and date and time dataspec before exiting \"\"\" self . dataspec . set_name ( self . nameEdit . text ()) self . dataspec . set_device ( self . dataTypeCombo . currentText ()) experiment_date_time = self . dateTimeEdit . dateTime () . toPyDateTime () . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) self . dataspec . set_experiment_date ( experiment_date_time ) self . done ( 1 )","title":"Parameters"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSpecCreatorWindow.UiDataCreatorWindow.add_file_to_set","text":"","title":"add_file_to_set"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSpecCreatorWindow.UiDataCreatorWindow.add_file_to_set--gets-the-path-and-label-and-adds-it-to-the-current-dataspec-instance-while-updating-gui","text":"Source code in gui\\windows\\DataSpecCreatorWindow.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def add_file_to_set ( self ): \"\"\" # Gets the path and label and adds it to the current DataSpec instance while updating GUI \"\"\" # Read name and legend label from gui file_name = self . browseFilesText . toPlainText () file_label = self . labelEdit . text () # Check for duplicate label if file_label in self . dataspec . get_labels (): self . show_message ( title = \"Duplicate Label\" , message = \"\"\"This label has already been used. Choose another label and try again.\"\"\" ) else : # Add the file to the dataset and update the gui self . dataspec . set_structure_type ( \"flat\" ) self . dataspec . add_filepath ( file_name , file_label ) self . showSetPlainText . setPlainText ( json . dumps ( self . dataspec . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . browseFilesText . clear () # Empty label widget self . labelEdit . clear ()","title":"Gets the path and label and adds it to the current DataSpec instance while updating GUI"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSpecCreatorWindow.UiDataCreatorWindow.browse_dir","text":"","title":"browse_dir"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSpecCreatorWindow.UiDataCreatorWindow.browse_dir--open-directory-selection-dialog-to-get-a-path-and-update-gui-when-confirmed","text":"Source code in gui\\windows\\DataSpecCreatorWindow.py 82 83 84 85 86 87 def browse_dir ( self ): \"\"\" # Open directory selection dialog to get a path and update gui when confirmed \"\"\" dir_name = QtWidgets . QFileDialog . getExistingDirectory ( self , 'Select Directory' ) self . browseDirText . setPlainText ( dir_name )","title":"Open directory selection dialog to get a path and update gui when confirmed"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSpecCreatorWindow.UiDataCreatorWindow.browse_files","text":"","title":"browse_files"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSpecCreatorWindow.UiDataCreatorWindow.browse_files--open-file-selection-dialog-to-get-a-file-path-and-update-gui-when-confirmed","text":"Source code in gui\\windows\\DataSpecCreatorWindow.py 75 76 77 78 79 80 def browse_files ( self ): \"\"\" # Open file selection dialog to get a file path and update gui when confirmed \"\"\" file_name = QtWidgets . QFileDialog . getOpenFileName ( self , \"Open File\" ) self . browseFilesText . setPlainText ( file_name [ 0 ])","title":"Open file selection dialog to get a file path and update gui when confirmed"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSpecCreatorWindow.UiDataCreatorWindow.button_state","text":"Only enable closing when some data was included Source code in gui\\windows\\DataSpecCreatorWindow.py 148 149 150 151 152 153 154 155 156 def button_state ( self ): \"\"\" Only enable closing when some data was included \"\"\" # TODO: hmmmmmmmmmmmm, should I be able to close the window if I mistakenly opened it? nameTxt = self . nameEdit . text () files = self . showSetPlainText . toPlainText () if ( files != \"\" ) and ( nameTxt != \"\" ): self . doneBtn . setEnabled ( True ) else : self . doneBtn . setEnabled ( False )","title":"button_state"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSpecCreatorWindow.UiDataCreatorWindow.finish","text":"Add name, device type, and date and time dataspec before exiting Source code in gui\\windows\\DataSpecCreatorWindow.py 174 175 176 177 178 179 180 181 def finish ( self ): \"\"\" Add name, device type, and date and time dataspec before exiting \"\"\" self . dataspec . set_name ( self . nameEdit . text ()) self . dataspec . set_device ( self . dataTypeCombo . currentText ()) experiment_date_time = self . dateTimeEdit . dateTime () . toPyDateTime () . strftime ( \"%Y.%m. %d _%H.%M.%S\" ) self . dataspec . set_experiment_date ( experiment_date_time ) self . done ( 1 )","title":"finish"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSpecCreatorWindow.UiDataCreatorWindow.generate_set","text":"Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired Source code in gui\\windows\\DataSpecCreatorWindow.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def generate_set ( self ): \"\"\" Automatically generate a set of filepaths based on a directory path. Will create nested structure if desired \"\"\" path = self . browseDirText . toPlainText () # If path is not selected, show message and return None if not path : self . show_message ( title = \"No directory selected\" , message = \"\"\"No directory was selected, please select directory and try again\"\"\" ) return None # Construct the filepaths for this dataspec active_button = split_camel_case ( search_for_first_active_radio_button ( self ) . objectName ())[ 0 ] errors = self . dataspec . construct_filepaths ( root_dir = path , type = active_button ) # Show the directories/files that were ignored to the user if errors != \"\" : self . show_message ( title = \"Files were ignored\" , message = errors ) # Show the files in the gui self . showSetPlainText . setPlainText ( json . dumps ( self . dataspec . get_filepaths (), indent = 4 , separators = ( ',' , ': ' ) ) ) self . dataspec . set_structure_type ( active_button )","title":"generate_set"},{"location":"api/gui/windows_and_dialogs/#gui.windows.DataSpecCreatorWindow.UiDataCreatorWindow.reset","text":"Completely reset this UI by clearing all elements Source code in gui\\windows\\DataSpecCreatorWindow.py 165 166 167 168 169 170 171 172 def reset ( self ): \"\"\" Completely reset this UI by clearing all elements \"\"\" self . nameEdit . clear () self . labelEdit . clear () self . browseDirText . clear () self . browseFilesText . clear () self . showSetPlainText . clear () self . button_state () Bases: Handler , QTextEdit QTextEdit-based logging console widget for the GUI. This class bridges the logging module with a Qt text widget by: - Subclassing both logging.Handler and QTextEdit . - Emitting formatted log messages through a dedicated Qt signal ( appendTextEdit ), which is connected to the widget's append slot. - Keeping the text area read-only so it behaves like a console.","title":"reset"},{"location":"api/gui/windows_and_dialogs/#gui.windows.qtexteditconsole.QTextEditConsole--typical-usage","text":"Create an instance and add it as a handler to a logging.Logger . Configure a formatter for the handler. Logged messages will appear in the GUI with the configured format.","title":"Typical usage"},{"location":"api/gui/windows_and_dialogs/#gui.windows.qtexteditconsole.QTextEditConsole--parameters","text":"parent : QWidget Parent widget that will own this console. Source code in gui\\windows\\qtexteditconsole.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class QTextEditConsole ( logging . Handler , QtWidgets . QTextEdit ): \"\"\" QTextEdit-based logging console widget for the GUI. This class bridges the `logging` module with a Qt text widget by: - Subclassing both `logging.Handler` and `QTextEdit`. - Emitting formatted log messages through a dedicated Qt signal (`appendTextEdit`), which is connected to the widget's `append` slot. - Keeping the text area read-only so it behaves like a console. Typical usage ------------- - Create an instance and add it as a handler to a `logging.Logger`. - Configure a formatter for the handler. - Logged messages will appear in the GUI with the configured format. Parameters ---------- parent : QWidget Parent widget that will own this console. \"\"\" appendTextEdit = QtCore . pyqtSignal ( str ) def __init__ ( self , parent ): logging . Handler . __init__ ( self ) super ( QtWidgets . QTextEdit , self ) . __init__ ( parent ) self . setReadOnly ( True ) self . appendTextEdit . connect ( self . append ) def emit ( self , record ): msg = self . format ( record ) self . appendTextEdit . emit ( msg ) Display text content inside a modal dialog with optional saving. The dialog contains: - A read-only text editor showing contents . - \u201cOK\u201d to close the dialog. - \u201cSAVE\u201d to delegate saving via window.save_to_file .","title":"Parameters"},{"location":"api/gui/windows_and_dialogs/#gui.windows.dialogs.dialog_print.dialog_print--parameters","text":"window : QMainWindow Parent window providing the save callback. title : str Dialog title bar text. contents : str Text content to display. Source code in gui\\windows\\dialogs\\dialog_print.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def dialog_print ( window : QtWidgets . QMainWindow , title , contents ): \"\"\" Display text content inside a modal dialog with optional saving. The dialog contains: - A read-only text editor showing `contents`. - \u201cOK\u201d to close the dialog. - \u201cSAVE\u201d to delegate saving via `window.save_to_file`. Parameters ---------- window : QMainWindow Parent window providing the save callback. title : str Dialog title bar text. contents : str Text content to display. \"\"\" # Prepare a text edit widget to host the contents history_text_edit = QtWidgets . QTextEdit ( window ) history_text_edit . setPlainText ( contents ) # Initialise the window dialog = QtWidgets . QDialog ( window ) dialog . setWindowTitle ( title ) # Set a default width and minimum height for the dialog dialog . resize ( 600 , 400 ) # Create a QVBoxLayout for the dialog layout = QtWidgets . QVBoxLayout ( dialog ) # Add the QTextEdit widget to the layout layout . addWidget ( history_text_edit ) # Create a QHBoxLayout and host buttons button_layout = QtWidgets . QHBoxLayout () ok_button = QtWidgets . QPushButton ( \"OK\" ) save_button = QtWidgets . QPushButton ( \"SAVE\" ) button_layout . addWidget ( ok_button ) button_layout . addWidget ( save_button ) # Add the button layout to the main layout layout . addLayout ( button_layout ) # Connect the \"OK\" button to close the dialog ok_button . clicked . connect ( dialog . accept ) save_button . clicked . connect ( lambda : window . save_to_file ( contents )) # Show the dialog dialog . exec_ () Build and return an 'About' information dialog containing a logo and text. Features: - Displays an application logo loaded via QPixmap. - Shows about text with HTML formatting support. - Uses a fixed-size vertical layout.","title":"Parameters"},{"location":"api/gui/windows_and_dialogs/#gui.windows.dialogs.generate_about_dialog.generate_about_dialog--parameters","text":"about_contents : str HTML/markdown-like text describing the application. centralwidget : QWidget Parent widget for modal behavior. logo_path : str Directory path to the logo image file.","title":"Parameters"},{"location":"api/gui/windows_and_dialogs/#gui.windows.dialogs.generate_about_dialog.generate_about_dialog--returns","text":"QDialog Configured dialog ready to be shown. Source code in gui\\windows\\dialogs\\generate_about_dialog.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def generate_about_dialog ( about_contents , centralwidget , logo_path ): \"\"\" Build and return an 'About' information dialog containing a logo and text. Features: - Displays an application logo loaded via QPixmap. - Shows about text with HTML formatting support. - Uses a fixed-size vertical layout. Parameters ---------- about_contents : str HTML/markdown-like text describing the application. centralwidget : QWidget Parent widget for modal behavior. logo_path : str Directory path to the logo image file. Returns ------- QDialog Configured dialog ready to be shown. \"\"\" # Create a custom QDialog for the about information about_dialog = QtWidgets . QDialog ( centralwidget ) about_dialog . setWindowTitle ( \"About\" ) # Set the fixed size of the dialog about_dialog . setFixedSize ( 650 , 700 ) # Adjust the dimensions as needed # Load and set the image using QPixmap (make sure the path is correct) pixmap = QtGui . QPixmap ( logo_path + \"X_logo_x-lab_baseline_KL.png\" ) pixmap = pixmap . scaled ( 600 , 200 , QtCore . Qt . KeepAspectRatio ) image_label = QtWidgets . QLabel ( about_dialog ) image_label . setPixmap ( pixmap ) # Create a QLabel for the text (using HTML formatting) text_label = QtWidgets . QLabel ( about_dialog ) text_label . setWordWrap ( True ) text_label . setText ( about_contents ) # Create a QVBoxLayout for the dialog and add the image and text labels layout = QtWidgets . QVBoxLayout ( about_dialog ) layout . addWidget ( image_label ) layout . addWidget ( text_label ) about_dialog . setLayout ( layout ) return about_dialog","title":"Returns"},{"location":"api/utils/class_utils/","text":"Class Utils Scan a package for class_utils definitions without importing all modules at once. Returns a dict mapping class_utils name to (module_name, class_name). Source code in utils\\class_utils\\build_class_index.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def build_class_index ( package_name : str ): \"\"\" Scan a package for class_utils definitions without importing all modules at once. Returns a dict mapping class_utils name to (module_name, class_name). \"\"\" index = {} package = importlib . import_module ( package_name ) for _ , module_name , _ in pkgutil . walk_packages ( package . __path__ , package . __name__ + \".\" ): module = importlib . import_module ( module_name ) # minimal import to inspect for name , obj in inspect . getmembers ( module , inspect . isclass ): if obj . __module__ == module . __name__ : index [ name ] = ( module_name , name ) return index Given a class_utils index (from build_class_index) and a class_utils name, import and return the class_utils object. Source code in utils\\class_utils\\load_class_from_index.py 4 5 6 7 8 9 10 11 12 13 14 def load_class_from_index ( class_index , class_name : str ): \"\"\" Given a class_utils index (from build_class_index) and a class_utils name, import and return the class_utils object. \"\"\" if class_name not in class_index : raise ValueError ( f \"Class ' { class_name } ' not found.\" ) module_name , cls_name = class_index [ class_name ] module = importlib . import_module ( module_name ) return getattr ( module , cls_name ) Return the names of public methods defined directly on a class. Parameters cls: Class whose methods should be inspected. ignore: Optional list of method names to exclude from the result. Returns list[str] Names of methods defined on cls that are: - plain functions (no descriptors), - not dunder methods, - not starting with set , - not listed in ignore . Source code in utils\\class_utils\\get_class_methods.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def get_class_methods ( cls , ignore = []) -> list : \"\"\" Return the names of public methods defined directly on a class. Parameters ---------- cls: Class whose methods should be inspected. ignore: Optional list of method names to exclude from the result. Returns ------- list[str] Names of methods defined on ``cls`` that are: - plain functions (no descriptors), - not dunder methods, - not starting with ``set``, - not listed in ``ignore``. \"\"\" methods = [] for name , func in cls . __dict__ . items (): # Skip items that are not of the function type if type ( func ) != FunctionType : continue # ignore dunder_methods, setters and explicitly ignored function names if not name . startswith ( '_' ) and not name . startswith ( 'set' ) and name not in ignore : methods . append ( name ) return methods","title":"Utils - Class Utils"},{"location":"api/utils/class_utils/#class-utils","text":"Scan a package for class_utils definitions without importing all modules at once. Returns a dict mapping class_utils name to (module_name, class_name). Source code in utils\\class_utils\\build_class_index.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def build_class_index ( package_name : str ): \"\"\" Scan a package for class_utils definitions without importing all modules at once. Returns a dict mapping class_utils name to (module_name, class_name). \"\"\" index = {} package = importlib . import_module ( package_name ) for _ , module_name , _ in pkgutil . walk_packages ( package . __path__ , package . __name__ + \".\" ): module = importlib . import_module ( module_name ) # minimal import to inspect for name , obj in inspect . getmembers ( module , inspect . isclass ): if obj . __module__ == module . __name__ : index [ name ] = ( module_name , name ) return index Given a class_utils index (from build_class_index) and a class_utils name, import and return the class_utils object. Source code in utils\\class_utils\\load_class_from_index.py 4 5 6 7 8 9 10 11 12 13 14 def load_class_from_index ( class_index , class_name : str ): \"\"\" Given a class_utils index (from build_class_index) and a class_utils name, import and return the class_utils object. \"\"\" if class_name not in class_index : raise ValueError ( f \"Class ' { class_name } ' not found.\" ) module_name , cls_name = class_index [ class_name ] module = importlib . import_module ( module_name ) return getattr ( module , cls_name ) Return the names of public methods defined directly on a class.","title":"Class Utils"},{"location":"api/utils/class_utils/#utils.class_utils.get_class_methods.get_class_methods--parameters","text":"cls: Class whose methods should be inspected. ignore: Optional list of method names to exclude from the result.","title":"Parameters"},{"location":"api/utils/class_utils/#utils.class_utils.get_class_methods.get_class_methods--returns","text":"list[str] Names of methods defined on cls that are: - plain functions (no descriptors), - not dunder methods, - not starting with set , - not listed in ignore . Source code in utils\\class_utils\\get_class_methods.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def get_class_methods ( cls , ignore = []) -> list : \"\"\" Return the names of public methods defined directly on a class. Parameters ---------- cls: Class whose methods should be inspected. ignore: Optional list of method names to exclude from the result. Returns ------- list[str] Names of methods defined on ``cls`` that are: - plain functions (no descriptors), - not dunder methods, - not starting with ``set``, - not listed in ``ignore``. \"\"\" methods = [] for name , func in cls . __dict__ . items (): # Skip items that are not of the function type if type ( func ) != FunctionType : continue # ignore dunder_methods, setters and explicitly ignored function names if not name . startswith ( '_' ) and not name . startswith ( 'set' ) and name not in ignore : methods . append ( name ) return methods","title":"Returns"},{"location":"api/utils/errors/","text":"Error Handling Bases: ValueError Raised when an open-circuit voltage (Voc) value cannot be located. Source code in utils\\errors\\errors.py 1 2 3 class VocNotFoundError ( ValueError ): \"\"\"Raised when an open-circuit voltage (Voc) value cannot be located.\"\"\" pass Bases: ValueError Raised when a short-circuit current (Isc) value cannot be located. Source code in utils\\errors\\errors.py 6 7 8 class IscNotFoundError ( ValueError ): \"\"\"Raised when a short-circuit current (Isc) value cannot be located.\"\"\" pass Bases: ValueError Raised when a requested observable cannot be derived from the available data. Source code in utils\\errors\\errors.py 11 12 13 class ObservableNotComputableError ( ValueError ): \"\"\"Raised when a requested observable cannot be derived from the available data.\"\"\" pass Bases: KeyError Raised when a dataspec or configuration refers to an unknown device type. Source code in utils\\errors\\errors.py 16 17 18 class IncompatibleDeviceTypeFound ( KeyError ): \"\"\"Raised when a dataspec or configuration refers to an unknown device type.\"\"\" pass Bases: RuntimeError Raised when the implementations package fails validation. Source code in utils\\errors\\errors.py 21 22 class ImplementationError ( RuntimeError ): \"\"\"Raised when the implementations package fails validation.\"\"\" Wrap a function so that :class: VocNotFoundError is logged and suppressed. Parameters func: Callable to execute. logger: Logger instance used to record the error. Returns Callable[..., Any] A wrapper that calls func and logs any :class: VocNotFoundError instead of propagating it. Source code in utils\\errors\\logging.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def error_with_logging ( func : Callable [ ... , Any ], logger : logging . Logger ) -> Callable [ ... , Any ]: \"\"\" Wrap a function so that :class:`VocNotFoundError` is logged and suppressed. Parameters ---------- func: Callable to execute. logger: Logger instance used to record the error. Returns ------- Callable[..., Any] A wrapper that calls ``func`` and logs any :class:`VocNotFoundError` instead of propagating it. \"\"\" @functools . wraps ( func ) def wrapper ( * args : Any , ** kwargs : Any ) -> Any : try : func ( * args , ** kwargs ) except VocNotFoundError as err : logger . error ( f \"Found error { err } calling { func . __name__ } \" ) return wrapper Decorator that logs and re-raises any exception raised by func . Parameters func: Callable to wrap. logger: Logger instance used to record the exception and traceback. Returns Callable[..., Any] A wrapper that logs the exception details before re-raising them. Source code in utils\\errors\\logging.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def exceptions_logging ( func : Callable [ ... , Any ], logger : logging . Logger ) -> Callable [ ... , Any ]: \"\"\" Decorator that logs and re-raises any exception raised by ``func``. Parameters ---------- func: Callable to wrap. logger: Logger instance used to record the exception and traceback. Returns ------- Callable[..., Any] A wrapper that logs the exception details before re-raising them. \"\"\" @functools . wraps ( func ) def wrapper ( * args , ** kwargs ): try : func ( * args , ** kwargs ) except Exception as exc : import traceback logger . error ( f \"Found error { exc } calling { func . __name__ } \" ) logger . error ( f \"Reported trace: { traceback . format_exc () } \" ) raise return wrapper","title":"Utils - Errors"},{"location":"api/utils/errors/#error-handling","text":"Bases: ValueError Raised when an open-circuit voltage (Voc) value cannot be located. Source code in utils\\errors\\errors.py 1 2 3 class VocNotFoundError ( ValueError ): \"\"\"Raised when an open-circuit voltage (Voc) value cannot be located.\"\"\" pass Bases: ValueError Raised when a short-circuit current (Isc) value cannot be located. Source code in utils\\errors\\errors.py 6 7 8 class IscNotFoundError ( ValueError ): \"\"\"Raised when a short-circuit current (Isc) value cannot be located.\"\"\" pass Bases: ValueError Raised when a requested observable cannot be derived from the available data. Source code in utils\\errors\\errors.py 11 12 13 class ObservableNotComputableError ( ValueError ): \"\"\"Raised when a requested observable cannot be derived from the available data.\"\"\" pass Bases: KeyError Raised when a dataspec or configuration refers to an unknown device type. Source code in utils\\errors\\errors.py 16 17 18 class IncompatibleDeviceTypeFound ( KeyError ): \"\"\"Raised when a dataspec or configuration refers to an unknown device type.\"\"\" pass Bases: RuntimeError Raised when the implementations package fails validation. Source code in utils\\errors\\errors.py 21 22 class ImplementationError ( RuntimeError ): \"\"\"Raised when the implementations package fails validation.\"\"\" Wrap a function so that :class: VocNotFoundError is logged and suppressed.","title":"Error Handling"},{"location":"api/utils/errors/#utils.errors.logging.error_with_logging--parameters","text":"func: Callable to execute. logger: Logger instance used to record the error.","title":"Parameters"},{"location":"api/utils/errors/#utils.errors.logging.error_with_logging--returns","text":"Callable[..., Any] A wrapper that calls func and logs any :class: VocNotFoundError instead of propagating it. Source code in utils\\errors\\logging.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def error_with_logging ( func : Callable [ ... , Any ], logger : logging . Logger ) -> Callable [ ... , Any ]: \"\"\" Wrap a function so that :class:`VocNotFoundError` is logged and suppressed. Parameters ---------- func: Callable to execute. logger: Logger instance used to record the error. Returns ------- Callable[..., Any] A wrapper that calls ``func`` and logs any :class:`VocNotFoundError` instead of propagating it. \"\"\" @functools . wraps ( func ) def wrapper ( * args : Any , ** kwargs : Any ) -> Any : try : func ( * args , ** kwargs ) except VocNotFoundError as err : logger . error ( f \"Found error { err } calling { func . __name__ } \" ) return wrapper Decorator that logs and re-raises any exception raised by func .","title":"Returns"},{"location":"api/utils/errors/#utils.errors.logging.exceptions_logging--parameters","text":"func: Callable to wrap. logger: Logger instance used to record the exception and traceback.","title":"Parameters"},{"location":"api/utils/errors/#utils.errors.logging.exceptions_logging--returns","text":"Callable[..., Any] A wrapper that logs the exception details before re-raising them. Source code in utils\\errors\\logging.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def exceptions_logging ( func : Callable [ ... , Any ], logger : logging . Logger ) -> Callable [ ... , Any ]: \"\"\" Decorator that logs and re-raises any exception raised by ``func``. Parameters ---------- func: Callable to wrap. logger: Logger instance used to record the exception and traceback. Returns ------- Callable[..., Any] A wrapper that logs the exception details before re-raising them. \"\"\" @functools . wraps ( func ) def wrapper ( * args , ** kwargs ): try : func ( * args , ** kwargs ) except Exception as exc : import traceback logger . error ( f \"Found error { exc } calling { func . __name__ } \" ) logger . error ( f \"Reported trace: { traceback . format_exc () } \" ) raise return wrapper","title":"Returns"},{"location":"api/utils/logging/","text":"Logging Thin wrapper around the shared application logger. The class provides a simple console_print method used by the GUI to write messages to the configured logger identified by constants.LOG_NAME . Source code in utils\\logging.py 14 15 16 17 18 19 20 21 22 23 24 class ConsoleLogging : \"\"\"Thin wrapper around the shared application logger. The class provides a simple ``console_print`` method used by the GUI to write messages to the configured logger identified by ``constants.LOG_NAME``. \"\"\" def __init__ ( self ): self . logger = logging . getLogger ( constants . LOG_NAME ) def console_print ( self , level = 10 , message = None ): self . logger . log ( level , message ) Logging decorator usable as @with_logging @with_logging() @with_logging(log_level=...) Source code in utils\\logging.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def with_logging ( func = None , * , log_level : int = 10 ): \"\"\" Logging decorator usable as: @with_logging @with_logging() @with_logging(log_level=...) \"\"\" def decorator ( func ): @functools . wraps ( func ) def wrapper ( * args , ** kwargs ): logger = logging . getLogger ( constants . LOG_NAME ) logger . log ( log_level , f \"Calling { func . __qualname__ } \" ) value = func ( * args , ** kwargs ) logger . log ( log_level , f \"Finished calling { func . __qualname__ } \" ) return value return wrapper # CASE 1: @with_logging \u2192 func is the decorated function if callable ( func ): return decorator ( func ) # CASE 2: @with_logging(...) \u2192 func is None, return real decorator return decorator Class decorator that wraps explicitly defined methods on a class with with_logging , without touching Qt signals or other descriptors. Only items in cls.__dict__ that are real functions (or class/staticmethods) are wrapped. By default, public methods (no leading underscore) are wrapped. You can narrow/adjust behaviour with include / exclude . Source code in utils\\logging.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def decorate_class_with_logging ( log_level : int = 10 , include : set [ str ] | None = None , exclude : set [ str ] | None = None , ): \"\"\" Class decorator that wraps explicitly defined *methods* on a class with `with_logging`, without touching Qt signals or other descriptors. - Only items in `cls.__dict__` that are real functions (or class/staticmethods) are wrapped. - By default, public methods (no leading underscore) are wrapped. - You can narrow/adjust behaviour with `include` / `exclude`. \"\"\" def decorator ( cls ): for name , attr in cls . __dict__ . items (): # unwrap classmethod / staticmethod is_classmethod = isinstance ( attr , classmethod ) is_staticmethod = isinstance ( attr , staticmethod ) func = attr . __func__ if ( is_classmethod or is_staticmethod ) else attr # only wrap *real* functions, not pyqtSignal, properties, etc. if not isinstance ( func , FunctionType ): continue # skip dunder + private-ish names if name . startswith ( \"__\" ) and name . endswith ( \"__\" ): continue if name . startswith ( \"_\" ): continue # optional filters if include is not None and name not in include : continue if exclude is not None and name in exclude : continue # your existing with_logging(func, log_level=...) wrapped_func = with_logging ( func , log_level = log_level ) # re-wrap as classmethod/staticmethod if needed if is_classmethod : wrapped_attr = classmethod ( wrapped_func ) elif is_staticmethod : wrapped_attr = staticmethod ( wrapped_func ) else : wrapped_attr = wrapped_func setattr ( cls , name , wrapped_attr ) return cls return decorator","title":"Utils - Logging"},{"location":"api/utils/logging/#logging","text":"Thin wrapper around the shared application logger. The class provides a simple console_print method used by the GUI to write messages to the configured logger identified by constants.LOG_NAME . Source code in utils\\logging.py 14 15 16 17 18 19 20 21 22 23 24 class ConsoleLogging : \"\"\"Thin wrapper around the shared application logger. The class provides a simple ``console_print`` method used by the GUI to write messages to the configured logger identified by ``constants.LOG_NAME``. \"\"\" def __init__ ( self ): self . logger = logging . getLogger ( constants . LOG_NAME ) def console_print ( self , level = 10 , message = None ): self . logger . log ( level , message ) Logging decorator usable as @with_logging @with_logging() @with_logging(log_level=...) Source code in utils\\logging.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def with_logging ( func = None , * , log_level : int = 10 ): \"\"\" Logging decorator usable as: @with_logging @with_logging() @with_logging(log_level=...) \"\"\" def decorator ( func ): @functools . wraps ( func ) def wrapper ( * args , ** kwargs ): logger = logging . getLogger ( constants . LOG_NAME ) logger . log ( log_level , f \"Calling { func . __qualname__ } \" ) value = func ( * args , ** kwargs ) logger . log ( log_level , f \"Finished calling { func . __qualname__ } \" ) return value return wrapper # CASE 1: @with_logging \u2192 func is the decorated function if callable ( func ): return decorator ( func ) # CASE 2: @with_logging(...) \u2192 func is None, return real decorator return decorator Class decorator that wraps explicitly defined methods on a class with with_logging , without touching Qt signals or other descriptors. Only items in cls.__dict__ that are real functions (or class/staticmethods) are wrapped. By default, public methods (no leading underscore) are wrapped. You can narrow/adjust behaviour with include / exclude . Source code in utils\\logging.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def decorate_class_with_logging ( log_level : int = 10 , include : set [ str ] | None = None , exclude : set [ str ] | None = None , ): \"\"\" Class decorator that wraps explicitly defined *methods* on a class with `with_logging`, without touching Qt signals or other descriptors. - Only items in `cls.__dict__` that are real functions (or class/staticmethods) are wrapped. - By default, public methods (no leading underscore) are wrapped. - You can narrow/adjust behaviour with `include` / `exclude`. \"\"\" def decorator ( cls ): for name , attr in cls . __dict__ . items (): # unwrap classmethod / staticmethod is_classmethod = isinstance ( attr , classmethod ) is_staticmethod = isinstance ( attr , staticmethod ) func = attr . __func__ if ( is_classmethod or is_staticmethod ) else attr # only wrap *real* functions, not pyqtSignal, properties, etc. if not isinstance ( func , FunctionType ): continue # skip dunder + private-ish names if name . startswith ( \"__\" ) and name . endswith ( \"__\" ): continue if name . startswith ( \"_\" ): continue # optional filters if include is not None and name not in include : continue if exclude is not None and name in exclude : continue # your existing with_logging(func, log_level=...) wrapped_func = with_logging ( func , log_level = log_level ) # re-wrap as classmethod/staticmethod if needed if is_classmethod : wrapped_attr = classmethod ( wrapped_func ) elif is_staticmethod : wrapped_attr = staticmethod ( wrapped_func ) else : wrapped_attr = wrapped_func setattr ( cls , name , wrapped_attr ) return cls return decorator","title":"Logging"},{"location":"api/utils/others/","text":"Additional utilities Run all checks on the implementations package. Source code in utils\\check_implementations.py 23 24 25 26 27 28 29 30 def check_implementations () -> None : \"\"\"Run all checks on the `implementations` package.\"\"\" _ , impl_root = _require_implementations_package () _check_directory_structure ( impl_root ) modules = _import_impl_modules () _check_contract_implementations ( modules ) _check_device_ui_files ( impl_root , modules [ \"devices_workers\" ]) _check_config_file ( impl_root ) Helper for mapping message level names to QColor instances. The colours are used by the GUI console to display messages with different visual emphasis (alert, warning, normal). Source code in utils\\console_colours.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ConsoleColours : \"\"\" Helper for mapping message level names to QColor instances. The colours are used by the GUI console to display messages with different visual emphasis (alert, warning, normal). \"\"\" def __init__ ( self ): self . _alert = QtGui . QColor ( 255 , 0 , 0 ) self . _warning = QtGui . QColor ( 255 , 127 , 0 ) self . _normal = QtGui . QColor ( 255 , 255 , 255 ) def get_colour ( self , level ): return getattr ( self , f \"_ { level } \" ) Utility for parsing and serialising my custom timestamp format. The helper supports flexible separators and format strings used to construct filenames and labels, and provides round-tripping between strings and :class: datetime.datetime objects. Source code in utils\\custom_datetime.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class CustomDatetime : \"\"\" Utility for parsing and serialising my custom timestamp format. The helper supports flexible separators and format strings used to construct filenames and labels, and provides round-tripping between strings and :class:`datetime.datetime` objects. \"\"\" def __init__ ( self , separators = \"-_\" , label_format = \"%Y_%m_ %d _%H_%M_%S\" , default_time = \"09_00_00\" , date_pattern = None , time_pattern = None ): self . separators = separators self . label_format = label_format self . default_time = default_time # If user didn't pass custom patterns, use default YYYY_MM_DD / HH_MM_SS self . date_pattern = date_pattern or rf \"(\\d {{ 4 }} )[ { self . separators } ](\\d {{ 2 }} )[ { self . separators } ](\\d {{ 2 }} )\" self . time_pattern = time_pattern or rf \"(\\d {{ 2 }} )[ { self . separators } ](\\d {{ 2 }} )[ { self . separators } ](\\d {{ 2 }} )\" def create_datetime_from_string ( self , input_datetime_str : str = None ) -> datetime : \"\"\" Creates a datetime object from an input datetime string. - Infers %Y vs %y from the year token length. - Allows HH_MM or HH_MM_SS; pads seconds to 00 when missing. \"\"\" if input_datetime_str is None : raise ValueError ( \"Input datetime string cannot be None\" ) # --- Find date --- date_match = re . search ( self . date_pattern , input_datetime_str ) if not date_match : raise ValueError ( f \"Input string { input_datetime_str } does not contain a valid date\" ) date_groups = date_match . groups () if len ( date_groups ) != 3 : raise ValueError ( \"Date pattern must capture exactly 3 groups (Y, m, d)\" ) year_token = date_groups [ 0 ] if len ( year_token ) == 4 : date_fmt = \"%Y_%m_ %d \" elif len ( year_token ) == 2 : date_fmt = \"%y_%m_ %d \" else : raise ValueError ( \"Year group must be 2 or 4 digits\" ) date_str = \"_\" . join ( date_groups ) # --- Find time (search only after date to avoid picking up pre-date tokens) --- remaining_str = input_datetime_str [ date_match . end ():] time_match = re . search ( self . time_pattern , remaining_str ) if time_match : time_groups = time_match . groups () if len ( time_groups ) == 3 : time_str = \"_\" . join ( time_groups ) # HH_MM_SS time_fmt = \"%H_%M_%S\" elif len ( time_groups ) == 2 : time_str = f \" { time_groups [ 0 ] } _ { time_groups [ 1 ] } _00\" # HH_MM_00 time_fmt = \"%H_%M_%S\" else : raise ValueError ( \"Time pattern must capture 2 (H,M) or 3 (H,M,S) groups\" ) else : # Use default time (assumed HH_MM_SS like \"09_00_00\") time_str = self . default_time time_fmt = \"%H_%M_%S\" # Final assemble + parse datetime_str = f \" { date_str } _ { time_str } \" fmt = f \" { date_fmt } _ { time_fmt } \" return datetime . strptime ( datetime_str , fmt ) def write_datetime_to_string ( self , input_datetime : datetime ) -> str : if input_datetime is None : raise ValueError ( \"Input datetime cannot be None\" ) return input_datetime . strftime ( self . label_format ) def get_current_timestamp ( self , now : datetime | None = None ) -> str : \"\"\" Returns a timestamp string using `label_format`, suitable for filenames. Pass `now` for deterministic testing; otherwise uses current local time. \"\"\" current = now or datetime . now () return self . write_datetime_to_string ( current ) create_datetime_from_string ( input_datetime_str = None ) Creates a datetime object from an input datetime string. Infers %Y vs %y from the year token length. Allows HH_MM or HH_MM_SS; pads seconds to 00 when missing. Source code in utils\\custom_datetime.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def create_datetime_from_string ( self , input_datetime_str : str = None ) -> datetime : \"\"\" Creates a datetime object from an input datetime string. - Infers %Y vs %y from the year token length. - Allows HH_MM or HH_MM_SS; pads seconds to 00 when missing. \"\"\" if input_datetime_str is None : raise ValueError ( \"Input datetime string cannot be None\" ) # --- Find date --- date_match = re . search ( self . date_pattern , input_datetime_str ) if not date_match : raise ValueError ( f \"Input string { input_datetime_str } does not contain a valid date\" ) date_groups = date_match . groups () if len ( date_groups ) != 3 : raise ValueError ( \"Date pattern must capture exactly 3 groups (Y, m, d)\" ) year_token = date_groups [ 0 ] if len ( year_token ) == 4 : date_fmt = \"%Y_%m_ %d \" elif len ( year_token ) == 2 : date_fmt = \"%y_%m_ %d \" else : raise ValueError ( \"Year group must be 2 or 4 digits\" ) date_str = \"_\" . join ( date_groups ) # --- Find time (search only after date to avoid picking up pre-date tokens) --- remaining_str = input_datetime_str [ date_match . end ():] time_match = re . search ( self . time_pattern , remaining_str ) if time_match : time_groups = time_match . groups () if len ( time_groups ) == 3 : time_str = \"_\" . join ( time_groups ) # HH_MM_SS time_fmt = \"%H_%M_%S\" elif len ( time_groups ) == 2 : time_str = f \" { time_groups [ 0 ] } _ { time_groups [ 1 ] } _00\" # HH_MM_00 time_fmt = \"%H_%M_%S\" else : raise ValueError ( \"Time pattern must capture 2 (H,M) or 3 (H,M,S) groups\" ) else : # Use default time (assumed HH_MM_SS like \"09_00_00\") time_str = self . default_time time_fmt = \"%H_%M_%S\" # Final assemble + parse datetime_str = f \" { date_str } _ { time_str } \" fmt = f \" { date_fmt } _ { time_fmt } \" return datetime . strptime ( datetime_str , fmt ) get_current_timestamp ( now = None ) Returns a timestamp string using label_format , suitable for filenames. Pass now for deterministic testing; otherwise uses current local time. Source code in utils\\custom_datetime.py 87 88 89 90 91 92 93 def get_current_timestamp ( self , now : datetime | None = None ) -> str : \"\"\" Returns a timestamp string using `label_format`, suitable for filenames. Pass `now` for deterministic testing; otherwise uses current local time. \"\"\" current = now or datetime . now () return self . write_datetime_to_string ( current ) Export matrix to a delimiter-separated text file. Parameters filename: Path to the output file that will be created/overwritten. list_of_lists: List of equal-length iterables, each representing a column of data. header: List of column labels written as the first line of the file. delimiter: String used to join header fields and row values (defaults to tab). Notes The function assumes that all columns in list_of_lists have the same length and will raise IndexError if this is not the case. Source code in utils\\export_to_csv.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def export_to_csv ( filename : str , list_of_lists : list , header : list , delimiter : str = ' \\t ' ): \"\"\" Export matrix to a delimiter-separated text file. Parameters ---------- filename: Path to the output file that will be created/overwritten. list_of_lists: List of equal-length iterables, each representing a column of data. header: List of column labels written as the first line of the file. delimiter: String used to join header fields and row values (defaults to tab). Notes ----- The function assumes that all columns in ``list_of_lists`` have the same length and will raise ``IndexError`` if this is not the case. \"\"\" first_list = list_of_lists [ 0 ] # Open a file with open ( filename , 'w' ) as csv_file : # Save the header row csv_file . write ( delimiter . join ( header )) csv_file . write ( ' \\n ' ) # Go through all columns and write the data for index in range ( len ( first_list )): row = [] for sublist in list_of_lists : row . append ( str ( sublist [ index ])) csv_file . write ( delimiter . join ( row )) csv_file . write ( ' \\n ' ) Read a JSON configuration file and return its contents as a dictionary. Parameters config_path : str The file path to the JSON configuration file. Returns dict A dictionary containing the configuration settings. Source code in utils\\read_config.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def read_config ( config_path : str ) -> dict : \"\"\"Read a JSON configuration file and return its contents as a dictionary. Parameters ---------- config_path : str The file path to the JSON configuration file. Returns ------- dict A dictionary containing the configuration settings. \"\"\" with open ( config_path , 'r' ) as file : config = json . load ( file ) return config","title":"Utils - Others"},{"location":"api/utils/others/#additional-utilities","text":"Run all checks on the implementations package. Source code in utils\\check_implementations.py 23 24 25 26 27 28 29 30 def check_implementations () -> None : \"\"\"Run all checks on the `implementations` package.\"\"\" _ , impl_root = _require_implementations_package () _check_directory_structure ( impl_root ) modules = _import_impl_modules () _check_contract_implementations ( modules ) _check_device_ui_files ( impl_root , modules [ \"devices_workers\" ]) _check_config_file ( impl_root ) Helper for mapping message level names to QColor instances. The colours are used by the GUI console to display messages with different visual emphasis (alert, warning, normal). Source code in utils\\console_colours.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ConsoleColours : \"\"\" Helper for mapping message level names to QColor instances. The colours are used by the GUI console to display messages with different visual emphasis (alert, warning, normal). \"\"\" def __init__ ( self ): self . _alert = QtGui . QColor ( 255 , 0 , 0 ) self . _warning = QtGui . QColor ( 255 , 127 , 0 ) self . _normal = QtGui . QColor ( 255 , 255 , 255 ) def get_colour ( self , level ): return getattr ( self , f \"_ { level } \" ) Utility for parsing and serialising my custom timestamp format. The helper supports flexible separators and format strings used to construct filenames and labels, and provides round-tripping between strings and :class: datetime.datetime objects. Source code in utils\\custom_datetime.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class CustomDatetime : \"\"\" Utility for parsing and serialising my custom timestamp format. The helper supports flexible separators and format strings used to construct filenames and labels, and provides round-tripping between strings and :class:`datetime.datetime` objects. \"\"\" def __init__ ( self , separators = \"-_\" , label_format = \"%Y_%m_ %d _%H_%M_%S\" , default_time = \"09_00_00\" , date_pattern = None , time_pattern = None ): self . separators = separators self . label_format = label_format self . default_time = default_time # If user didn't pass custom patterns, use default YYYY_MM_DD / HH_MM_SS self . date_pattern = date_pattern or rf \"(\\d {{ 4 }} )[ { self . separators } ](\\d {{ 2 }} )[ { self . separators } ](\\d {{ 2 }} )\" self . time_pattern = time_pattern or rf \"(\\d {{ 2 }} )[ { self . separators } ](\\d {{ 2 }} )[ { self . separators } ](\\d {{ 2 }} )\" def create_datetime_from_string ( self , input_datetime_str : str = None ) -> datetime : \"\"\" Creates a datetime object from an input datetime string. - Infers %Y vs %y from the year token length. - Allows HH_MM or HH_MM_SS; pads seconds to 00 when missing. \"\"\" if input_datetime_str is None : raise ValueError ( \"Input datetime string cannot be None\" ) # --- Find date --- date_match = re . search ( self . date_pattern , input_datetime_str ) if not date_match : raise ValueError ( f \"Input string { input_datetime_str } does not contain a valid date\" ) date_groups = date_match . groups () if len ( date_groups ) != 3 : raise ValueError ( \"Date pattern must capture exactly 3 groups (Y, m, d)\" ) year_token = date_groups [ 0 ] if len ( year_token ) == 4 : date_fmt = \"%Y_%m_ %d \" elif len ( year_token ) == 2 : date_fmt = \"%y_%m_ %d \" else : raise ValueError ( \"Year group must be 2 or 4 digits\" ) date_str = \"_\" . join ( date_groups ) # --- Find time (search only after date to avoid picking up pre-date tokens) --- remaining_str = input_datetime_str [ date_match . end ():] time_match = re . search ( self . time_pattern , remaining_str ) if time_match : time_groups = time_match . groups () if len ( time_groups ) == 3 : time_str = \"_\" . join ( time_groups ) # HH_MM_SS time_fmt = \"%H_%M_%S\" elif len ( time_groups ) == 2 : time_str = f \" { time_groups [ 0 ] } _ { time_groups [ 1 ] } _00\" # HH_MM_00 time_fmt = \"%H_%M_%S\" else : raise ValueError ( \"Time pattern must capture 2 (H,M) or 3 (H,M,S) groups\" ) else : # Use default time (assumed HH_MM_SS like \"09_00_00\") time_str = self . default_time time_fmt = \"%H_%M_%S\" # Final assemble + parse datetime_str = f \" { date_str } _ { time_str } \" fmt = f \" { date_fmt } _ { time_fmt } \" return datetime . strptime ( datetime_str , fmt ) def write_datetime_to_string ( self , input_datetime : datetime ) -> str : if input_datetime is None : raise ValueError ( \"Input datetime cannot be None\" ) return input_datetime . strftime ( self . label_format ) def get_current_timestamp ( self , now : datetime | None = None ) -> str : \"\"\" Returns a timestamp string using `label_format`, suitable for filenames. Pass `now` for deterministic testing; otherwise uses current local time. \"\"\" current = now or datetime . now () return self . write_datetime_to_string ( current )","title":"Additional utilities"},{"location":"api/utils/others/#utils.custom_datetime.CustomDatetime.create_datetime_from_string","text":"Creates a datetime object from an input datetime string. Infers %Y vs %y from the year token length. Allows HH_MM or HH_MM_SS; pads seconds to 00 when missing. Source code in utils\\custom_datetime.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def create_datetime_from_string ( self , input_datetime_str : str = None ) -> datetime : \"\"\" Creates a datetime object from an input datetime string. - Infers %Y vs %y from the year token length. - Allows HH_MM or HH_MM_SS; pads seconds to 00 when missing. \"\"\" if input_datetime_str is None : raise ValueError ( \"Input datetime string cannot be None\" ) # --- Find date --- date_match = re . search ( self . date_pattern , input_datetime_str ) if not date_match : raise ValueError ( f \"Input string { input_datetime_str } does not contain a valid date\" ) date_groups = date_match . groups () if len ( date_groups ) != 3 : raise ValueError ( \"Date pattern must capture exactly 3 groups (Y, m, d)\" ) year_token = date_groups [ 0 ] if len ( year_token ) == 4 : date_fmt = \"%Y_%m_ %d \" elif len ( year_token ) == 2 : date_fmt = \"%y_%m_ %d \" else : raise ValueError ( \"Year group must be 2 or 4 digits\" ) date_str = \"_\" . join ( date_groups ) # --- Find time (search only after date to avoid picking up pre-date tokens) --- remaining_str = input_datetime_str [ date_match . end ():] time_match = re . search ( self . time_pattern , remaining_str ) if time_match : time_groups = time_match . groups () if len ( time_groups ) == 3 : time_str = \"_\" . join ( time_groups ) # HH_MM_SS time_fmt = \"%H_%M_%S\" elif len ( time_groups ) == 2 : time_str = f \" { time_groups [ 0 ] } _ { time_groups [ 1 ] } _00\" # HH_MM_00 time_fmt = \"%H_%M_%S\" else : raise ValueError ( \"Time pattern must capture 2 (H,M) or 3 (H,M,S) groups\" ) else : # Use default time (assumed HH_MM_SS like \"09_00_00\") time_str = self . default_time time_fmt = \"%H_%M_%S\" # Final assemble + parse datetime_str = f \" { date_str } _ { time_str } \" fmt = f \" { date_fmt } _ { time_fmt } \" return datetime . strptime ( datetime_str , fmt )","title":"create_datetime_from_string"},{"location":"api/utils/others/#utils.custom_datetime.CustomDatetime.get_current_timestamp","text":"Returns a timestamp string using label_format , suitable for filenames. Pass now for deterministic testing; otherwise uses current local time. Source code in utils\\custom_datetime.py 87 88 89 90 91 92 93 def get_current_timestamp ( self , now : datetime | None = None ) -> str : \"\"\" Returns a timestamp string using `label_format`, suitable for filenames. Pass `now` for deterministic testing; otherwise uses current local time. \"\"\" current = now or datetime . now () return self . write_datetime_to_string ( current ) Export matrix to a delimiter-separated text file.","title":"get_current_timestamp"},{"location":"api/utils/others/#utils.export_to_csv.export_to_csv--parameters","text":"filename: Path to the output file that will be created/overwritten. list_of_lists: List of equal-length iterables, each representing a column of data. header: List of column labels written as the first line of the file. delimiter: String used to join header fields and row values (defaults to tab).","title":"Parameters"},{"location":"api/utils/others/#utils.export_to_csv.export_to_csv--notes","text":"The function assumes that all columns in list_of_lists have the same length and will raise IndexError if this is not the case. Source code in utils\\export_to_csv.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def export_to_csv ( filename : str , list_of_lists : list , header : list , delimiter : str = ' \\t ' ): \"\"\" Export matrix to a delimiter-separated text file. Parameters ---------- filename: Path to the output file that will be created/overwritten. list_of_lists: List of equal-length iterables, each representing a column of data. header: List of column labels written as the first line of the file. delimiter: String used to join header fields and row values (defaults to tab). Notes ----- The function assumes that all columns in ``list_of_lists`` have the same length and will raise ``IndexError`` if this is not the case. \"\"\" first_list = list_of_lists [ 0 ] # Open a file with open ( filename , 'w' ) as csv_file : # Save the header row csv_file . write ( delimiter . join ( header )) csv_file . write ( ' \\n ' ) # Go through all columns and write the data for index in range ( len ( first_list )): row = [] for sublist in list_of_lists : row . append ( str ( sublist [ index ])) csv_file . write ( delimiter . join ( row )) csv_file . write ( ' \\n ' ) Read a JSON configuration file and return its contents as a dictionary.","title":"Notes"},{"location":"api/utils/others/#utils.read_config.read_config--parameters","text":"config_path : str The file path to the JSON configuration file.","title":"Parameters"},{"location":"api/utils/others/#utils.read_config.read_config--returns","text":"dict A dictionary containing the configuration settings. Source code in utils\\read_config.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def read_config ( config_path : str ) -> dict : \"\"\"Read a JSON configuration file and return its contents as a dictionary. Parameters ---------- config_path : str The file path to the JSON configuration file. Returns ------- dict A dictionary containing the configuration settings. \"\"\" with open ( config_path , 'r' ) as file : config = json . load ( file ) return config","title":"Returns"}]}