# Main.py
from PyQt5 import QtWidgets, uic
import datetime
import json
import sys
import Devices as Dev
import fileset as fs
import DataCreatorWindow
import experiment
from experiment import *
from utils.get_class_methods import get_class_methods
from utils.console_colours import ConsoleColours
from utils.class_utils import decorate_class_callables
from utils.logging import with_default_logging


class UiMainWindow(QtWidgets.QMainWindow):
    """
        GUI for automated plotting of various types of data.
        MainWindow.ui is generated by QtDesigner version 6.4.1
    """
    def __init__(self):
        super(UiMainWindow, self).__init__()
        self.fileset = None
        self.fileset_location = None

        # Define experiment indices corresponding to stackedWidget definition (see QtDesigner)
        self.devices = {
            '': 0,
            'Sunbrick': 1,
            'Stability': 2,
            'DW2000': 3,
            'LBIC': 4,
            'PDS': 5,
            'PTI': 6,
            'Generic': 7
        }

        # Define possible plot types to show to the user for each experiment
        self.plot_types = {
            'Sunbrick': get_class_methods(Sunbrick),
            'Stability': get_class_methods(Stability),
            'DW2000': ['plot', 'plot_rainbow'],
            'LBIC': ['show_image', 'show_3d', 'plot_intensities', 'plot_horiz_profile'],
            'PDS': ['plot'],
            'PTI': ['plot'],
            'Generic': ['plot', 'plot_distribution']
        }

        # Load the UI, Note that loadUI adds objects to 'self' using objectName
        self.dataWindow = None
        uic.loadUi("MainWindow.ui", self)

        # Reset stacked widget to empty page
        self.stackedWidget.setCurrentWidget(self.stackedWidget.widget(0))

        # Define widget action
        self.actionQuit.triggered.connect(self.quit)

        self.actionCreate.triggered.connect(self.create_data)
        self.actionSave.triggered.connect(self.save_data)
        self.actionLoad.triggered.connect(self.open_data_file)

        self.actionAbout.triggered.connect(self.show_about)

        self.showDataBtn.clicked.connect(self.display_data)
        self.showHistoryBtn.clicked.connect(self.display_history)
        self.addNotesBtn.clicked.connect(self.add_notes)

        self.appendBtn.clicked.connect(self.append_console_to_set)
        self.clearBtn.clicked.connect(self.clear_data)
        self.clearAllBtn.clicked.connect(self.clear_all)
        self.quitBtn.clicked.connect(self.quit)

        # Define stackedWidget widget actions
        self.lbicProfilesCheckBox.stateChanged.connect(self.toggle_lbic_profile)
        self.plotBtn.clicked.connect(self.plot_manager)

        # Show the app
        self.show()

    def create_data(self):
        # Run the DataCreatorWindow
        self.dataWindow = DataCreatorWindow.UiDataCreatorWindow()
        self.dataWindow.show()

        if self.dataWindow.exec() == 1:
            # If the window was properly closed (Done button) then creation was successful
            #     Copy data and print to console
            self.clear_data()
            self.fileset = self.dataWindow.fileset
            self.console_print(f"Fileset created")
            self.load_data()
            self.update_header()
            self.save_data()
        else:
            # Warn user that window was improperly closed and that no data was created
            self.console_print("No data was created")

    def autosave(self):
        file_name = self.fileset_location
        if file_name is None:
            return self.console_print("Cannot autosave, no file location known. Open or create dataset first")

        with open(file_name, "w") as json_file:
            json.dump(self.fileset, json_file, cls=fs.FilesetJSONEncoder)
        json_file.close()
        return self.console_print(f"Saved data to {file_name}")

    def save_data(self):
        # Make sure there is data to save
        if self.fileset is None:
            return self.console_print("Err: Must first load data", level="warning")

        # Run the file dialog
        file_name = QtWidgets.QFileDialog.getSaveFileName(self, "Save file to disk")[0]
        if file_name != "":
            # Dump the data into a json file and remember the location
            self.fileset_location = file_name
            with open(file_name, "w") as json_file:
                json.dump(self.fileset, json_file, cls=fs.FilesetJSONEncoder)
            json_file.close()

            return self.console_print(f"Saved data to {file_name}")
        else:
            # File dialog was exited without choosing a file
            return self.console_print(f"No file selected")

    def open_data_file(self):
        # Reset
        self.clear_data()
        self.consoleTextEdit.clear()

        # Choose file
        file_name = QtWidgets.QFileDialog.getOpenFileName(self, "Open Files")[0]
        if file_name != '':
            # Open then load the json file, remember the location and update GUI
            self.fileset_location = file_name
            with open(file_name) as json_file:
                self.fileset = json.load(json_file, cls=fs.FilesetJSONDecoder)
                self.console_print(f"Opened {file_name}")
            self.notesPlainText.setPlainText(self.fileset.get_notes())
            self.load_data()
            self.update_header()
        else:
            # File not chosen
            self.console_print(f"Err: No file loaded", level="warning")

    def load_data(self):
        # Add all top level keys to the selection list of the GUI
        for label in self.fileset.get_labels():
            self.selectedFilesList.addItem(label)

        # Some changes depend on the type of experiment
        device = self.fileset.get_device()

        # For lbic plot type set selection to first item, otherwise preselect all items
        if device == "LBIC":
            self.selectedFilesList.setCurrentRow(0)
        else:
            self.selectedFilesList.selectAll()

        # Edit combobox to show all available plot types
        for plot_type in self.plot_types[device]:
            self.plotTypeCombo.addItem(plot_type)

        self.console_print("Fileset loaded")

    def display_data(self):
        # TODO: This should probably be changed from QMessagebox to something else
        #     The width is insufficient and it needs a scrollbar
        # Abort if no data was loaded
        if self.fileset is None:
            return self.console_print("Err: Must first load data", level="warning")

        # Pretty print the data in a simple dialog
        pretty_json = json.dumps(
            self.fileset,
            indent=4,
            separators=(',', ': '),
            cls=fs.FilesetJSONEncoder
        )
        msg = QtWidgets.QMessageBox()
        msg.setWindowTitle(f"Fileset: {self.fileset.get_name()}")
        msg.setText(pretty_json)
        msg.exec_()

    def display_history(self):
        # TODO: This should probably be changed from QMessagebox to something else
        #     The width is insufficient and it needs a scrollbar
        if self.fileset is None:
            return self.console_print("Err: Must first load data", level="warning")

        # Prints only the console history to a simple dialog
        pretty_history = ""
        for k, v in sorted(self.fileset.get_console().items()):
            line = f"{v}\n"
            pretty_history += line
        msg = QtWidgets.QMessageBox()
        msg.setWindowTitle(f"Fileset: {self.fileset.get_name()}")
        msg.setText(pretty_history)
        msg.exec_()

    def add_notes(self):
        if self.fileset is None:
            return self.console_print("Err: Must first load data", level="warning")

        # Add any notes to the fileset
        self.fileset.add_notes(self.notesPlainText.toPlainText())
        self.console_print("Notes added to fileset")
        self.autosave()

    def update_header(self):
        # Header should reflect opened data
        self.currSetNameLineEdit.setText(self.fileset.get_name())
        self.currDeviceLineEdit.setText(self.fileset.get_device())

        # Stacked widget should show the correct widget for the opened data
        new_page = self.stackedWidget.widget(self.devices[self.fileset.get_device()])
        self.stackedWidget.setCurrentWidget(new_page)

    def plot_manager(self):
        # Grab the selected files for plotting
        fileset_time = datetime.datetime.now().strftime("%Y.%m.%d_%H.%M.%S")
        experiment_time = self.fileset.get_experiment_date().strftime("%Y.%m.%d_%H.%M.%S")
        selected_fileset = fs.Fileset(fileset_time)
        selected_fileset.set_experiment_date(experiment_time)
        for item in self.selectedFilesList.selectedItems():
            lbl = item.text()
            path = self.fileset.get_filepath(lbl)
            selected_fileset.add_filepath(path, lbl)
        selected_fileset.set_device(self.fileset.get_device())
        selected_fileset.set_structure_type(self.fileset.get_structure_type())
        selected_fileset.set_name(self.fileset.get_name())

        # Instantiate proper device class and set the data
        device = self.fileset.get_device()
        experiment_cls = getattr(experiment, device)
        experiment_instance = experiment_cls()
        experiment_instance.set_data(selected_fileset)

        # Grab the correct plotting function and pass all options to it
        plot_type = self.plotTypeCombo.currentText()
        self.console_print(f"Producing {device}-{plot_type} plot for {self.fileset.get_name()}")
        plot_type = getattr(experiment_instance, plot_type)
        plot_type(title=self.fileset.get_name(), legend="Some title")

    """
    def plot_sunbrick(self, plot_type: str, fileset: fs.Fileset):
        # Initialise sunbrick with files and grab relevant parameters
        device = Sunbrick()
        device.set_data(fileset)
        p = self.presentationCheckBox.isChecked()

        # Grab the callable method for the desired plot type and call it
        chosen_plot = getattr(device, plot_type)
        chosen_plot(title=self.fileset.get_name(), legend="Some title")

        return "success"

    def plot_dw2000(self, plot_type, selected_files):
        # Initialise DW2000 with a title
        device = Dev.DW2000(self.data['name'])

        # Call the corresponding plot function
        if plot_type == "plot":
            return device.plot(selected_files)
        elif plot_type == "plot_rainbow":
            return device.plot_rainbow(selected_files)
        else:
            return "Unknown plot type, skipped action."

    def plot_lbic(self, plot_type, selected_files):
        if len(selected_files) != 1:
            # TODO: batch production should be possible now using the label as a title
            return "LBIC only produces one image at a time"

        # Initialise LBIC with a title
        device = Dev.LBIC(self.data['name'])
        profiles = self.lbicProfilesCheckBox.isChecked()

        # Call the corresponding plot function with the needed parameters
        if plot_type == "show_image" or plot_type == "show_3d":
            # Intensity range is required for this type of plot
            intensities = [
                self.intRangeLowSpinBox.value() * 10**(-6),
                self.intRangeUpSpinBox.value() * 10**(-6)
            ]
            self.console_print(f"Range set to {intensities} A")

            if plot_type == "show_image":
                return device.show_image(selected_files, range=intensities, profiles=profiles)
            else:
                return device.show_3d(selected_files, range=intensities)

        elif plot_type == "plot_intensities":
            return device.plot_intensities(selected_files)

        elif plot_type == "plot_horiz_profile":
            # Only plot if profiles were enabled in the GUI
            if profiles:
                ycoord = self.lbicProfilesSpinBox.value()
                return device.plot_horiz_profile(selected_files, ycoord)
            else:
                return "Must enable profile for this plot"
        else:
            return "Unknown plot type, skipped action."

    def plot_pds(self, plot_type, selected_files):
        # Initialise PDS with a title and grab parameters
        device = Dev.PDS(self.data['name'])
        n = self.pdsNormCheckBox.isChecked()
        p = self.presentationCheckBox.isChecked()

        # Call the corresponding plot function with the needed parameters
        if plot_type == "plot":
            return device.plot(selected_files, normalised=n, presentation=p)
        else:
            return "Unknown plot type, skipped action."

    def plot_pti(self, plot_type, selected_files):
        # Initialise PDS with a title
        device = Dev.PtiText(self.data['name'])

        # Call the corresponding plot function
        if plot_type == "plot":
            return device.plot(selected_files)
        else:
            return "Unknown plot type, skipped action."

    def plot_generic(self, plot_type, selected_files):
        x_title = self.xTitleLineEdit.text()
        y_title = self.yTitleLineEdit.text()
        l_title = self.lTitleLineEdit.text()
        device = Dev.Generic(
            title=self.data['name'],
            x_title=x_title,
            y_title=y_title,
            l_title=l_title
        )

        n = self.genericNormCheckBox.isChecked()
        p = self.presentationCheckBox.isChecked()
        if plot_type == "plot":
            return device.plot(selected_files, presentation=p)
        elif plot_type == "plot_distribution":
            return device.plot_distribution(selected_files, presentation=p)
        else:
            return "Unknown plot type, skipped action."
    """
    def toggle_lbic_profile(self):
        # Allow the profile position to be selected (LBIC specific)
        if self.lbicProfilesCheckBox.isChecked():
            self.lbicProfilesSpinBox.setEnabled(True)
        else:
            self.lbicProfilesSpinBox.setDisabled(True)

    def console_print(self, fstring, level="normal"):
        # Print a message to the GUI console
        now = datetime.datetime.now()
        fstring_to_print = now.strftime("%d/%m/%Y %H.%M.%S: ") + fstring

        c = ConsoleColours()

        self.consoleTextEdit.setTextColor(c.get_colour(level))
        self.consoleTextEdit.append(fstring_to_print)
        self.consoleTextEdit.setTextColor(c.get_colour("normal"))

    def append_console_to_set(self):
        if self.fileset is None:
            return self.console_print("Err: Must first load data", level="warning")

        # Append console contents to the fileset
        console_text = self.consoleTextEdit.toPlainText()
        now = datetime.datetime.now()
        self.fileset.add_console(now.strftime("%d%m%Y_%H%M%S"), console_text)
        self.console_print("Added console contents to set")
        self.autosave()

    def clear_data(self):
        # Reset fields and properties related to data
        self.fileset = None
        self.fileset_location = None

        self.currSetNameLineEdit.clear()
        self.currDeviceLineEdit.clear()
        self.notesPlainText.clear()
        self.console_print("Cleared data from memory")

        self.stackedWidget.setCurrentWidget(self.stackedWidget.widget(0))
        self.selectedFilesList.clear()
        self.plotTypeCombo.clear()

    def clear_all(self):
        # Reset complete GUI
        self.clear_data()
        self.consoleTextEdit.clear()
        self.console_print("Cleared memory")

    def show_about(self):
        # Grab the "about" info from about.txt
        with open("about.txt") as about_file:
            about_contents = about_file.read()

        # Show a basic about message
        msg = QtWidgets.QMessageBox(self.centralwidget)
        msg.setWindowTitle("About")
        msg.setText(about_contents)
        msg.exec_()

    @staticmethod
    def quit():
        # Terminate the application
        sys.exit()


if __name__ == "__main__":
    # Initialise app, window and start execution
    app = QtWidgets.QApplication(sys.argv)
    window = UiMainWindow()
    app.exec_()
